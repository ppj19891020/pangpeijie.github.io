<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J~杰&#39;s Blog</title>
  
  <subtitle>人生就一条路，走一步有一步的景观</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://v2.ppjys.cn/"/>
  <updated>2018-07-03T14:53:30.958Z</updated>
  <id>http://v2.ppjys.cn/</id>
  
  <author>
    <name>J~杰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分库分表方案对比</title>
    <link href="http://v2.ppjys.cn/2018/04/26/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94/"/>
    <id>http://v2.ppjys.cn/2018/04/26/分库分表方案对比/</id>
    <published>2018-04-26T02:07:35.000Z</published>
    <updated>2018-07-03T14:53:30.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>目前公司业务高速发展，各种业务数据呈井喷的态势，单表数据量急剧膨胀，随之而来是单表读写性能和吞吐量呈下降趋势而且无法应对业务高速增长产生的数据。因此需要使用分库分表机制保证高性能同时支撑和驱动业务发展，选择一款功能强大支持分库分表的中间件就成为当务之急。开源的数据库中间件众多，需要从中挑选一个适合的，并能作为映客长期演进的中间件，因此需要从多个维度对中间件进行相关测试</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>针对数据量过大出现的性能问题，通过分库分表将数据量保持在阀值以下，可以有效分散高并发量和缓解大数据量。分库分表一般分垂直拆分和水平拆分，根据业务将单库（表）拆分为多库（表），常用的字段和不常用的字段拆分至不同的库（表）中，可适当缓解并发量和数据量，但不能根治；垂直拆分之后依然超过单节点所能承载的阈值，则需要水平拆分来进一步处理。 水平拆分则是根据分片算法将一个库（表）拆分为多个库（表）。</p><p>分表虽然可以解决海量数据导致的性能问题，但无法解决过多请求访问同一数据库，导致其响应变慢的问题。所以水平拆分通常要采取分库的方式(合理的配合使用分库+分表)，一并解决数据量和访问量巨大的问题。</p><h1 id="产品调研"><a href="#产品调研" class="headerlink" title="产品调研"></a>产品调研</h1><p>调研分析后Mycat和Sharding-jdbc功能上比较稳定成熟，支持分库分表、读写分离、分布式主键、柔性事务等。</p><p>Sharding-jdbc：类似TDDL，基于JDBC协议的数据库中间件产品，使用客户端直连数据库，以jar包形式提供服务，兼容JDBC和各种ORM框架，使系统在数据访问层直接具有分片化和分布式治理的能力。</p><ul><li>轻量级框架， 直接封装的jdbc协议，jar包形式提供服务，旧代码迁移、新代码开发成本低</li><li>无需额外部署和依赖，客户端直连数据库，无需二次转发，性能高</li><li>运维层面不改动，无需关注中间件本身的 HA</li></ul><h2 id="mycat"><a href="#mycat" class="headerlink" title="mycat"></a>mycat</h2><p>基于阿里开源的Cobar研发，对代码进行了彻底重构，使用NIO重构了网络模块，并优化了Buffer内核，增强了聚合，Join等基本特性.主要原理是拦截用户发送过来的SQL语句，对SQL语句做了特定的分析：如分<br>片分析、路由分析、读写分离分析、缓存分析等，然后将此SQL发往后端的真实数据库，并将返回的结果做适当的处理，最后返回给用户。</p><ul><li>可以负责更多的内容，将数据迁移，分布式事务等纳入 Proxy 的范畴</li><li>针对mycat和mysql有较全性能监控项统计支持</li><li>可结合Storm等分布式实时流引擎，实现数据分析和数据聚合</li></ul><h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>本次对比不是对MySQL数据库进行极限或压力性能测试，而是在同等软硬件环境下对选取的数据库中间件在软件/物理架构、功能特性、扩展性、SQL支持程度、容灾/容错、可用性、可维护性、接入成本等进行综合衡量。</p><table><thead><tr><th>对比点</th><th>mycat</th><th>sharding-jdbc</th><th>Tidb-分布式数据库</th></tr></thead><tbody><tr><td>分库分表</td><td>支持</td><td>支持</td><td>支持</td><td></td></tr><tr><td>分布式事物</td><td>弱XA</td><td>弱XA</td><td>完全ACID</td><td></td></tr><tr><td>复杂聚合查询</td><td>较弱（支持单库内部任意join，支持跨库2表join）</td><td>支持（聚合，分组，排序，分页，OR，关联查询）</td><td>支持</td><td></td></tr><tr><td>主键</td><td>时间戳、数据库、zk</td><td>雪花算法</td><td>区间分段（可能出现重复主键）</td><td></td></tr><tr><td>分片规则</td><td>已支持较多分片，可自定义</td><td>已支持较多分片，可自定义</td><td>内部实现机制，无需业务制定</td><td></td></tr><tr><td>支持数据库</td><td>mysql、nosql(monogdb)</td><td>mysql</td><td>本身就是数据库</td><td></td></tr><tr><td>HA</td><td>haproxy+keeplive</td><td>无</td><td>水平扩展+高可用</td><td></td></tr><tr><td>语言</td><td>java</td><td>java</td><td>go</td><td></td></tr><tr><td>可维护性</td><td>较高（提供管控台）</td><td>较高</td><td>低（虽然提供管控台，但是由于开发语言限制与团队技术栈不一致）</td><td></td></tr><tr><td>接入成本</td><td>低</td><td>较高(业务方需配合)</td><td>高(业务数据需要全部迁移tidb)</td><td></td></tr><tr><td>优点</td><td>有效解决了数据库链接数多的问题，因为各工程应用只连接中间件，中间件代理了真实的物理链接，并且与后端mysql物理链接是复用型的所有的分库分表等规则集中配置在中间件上，更可控</td><td>性能高</td><td>产品较新</td><td></td></tr><tr><td>缺点</td><td>计算过程只能单节点计算，单机扩展只能调优，但是集群可以做负载均衡；相对sharding-jdbc来说，由于增加一层中间代理，性能稍微降低；需要保证中间件的可用性，会增加运维成本及复杂度；</td><td>业务工程里各自配置多数据源（主、从），不能做到统一数据库连接管理，分片规则需要hard code到业务代码中</td><td>业务数据需要全部迁移，并且生产环境配置要求较高，不建议使用</td><td></td></tr></tbody></table><h1 id="分库分表后不支持的sql语法"><a href="#分库分表后不支持的sql语法" class="headerlink" title="分库分表后不支持的sql语法"></a>分库分表后不支持的sql语法</h1><ul><li>SELECT不支持的语法</li></ul><ol><li>不支持跨分片的交叉查询</li><li>跨节点的联合查询，不支持union all，union</li><li>sharding-jdbc不支持DISTINCT聚合,但是mycat支持</li><li>mycat支持跨库2张表的join（可通过Catlet实现多表join），sharding-jdbc支持多表join，由于内部实现复杂度和性能，不推荐使用join，最好由业务改造简单查询</li><li>mycat join支持</li></ol><ul><li>INSERT不支持的语法</li></ul><ol><li>插入的字段不包含分片字段 </li><li>插入的分片字段找不到对应分片</li><li>复制插入 insert into…select… </li><li>多行插入 insert into tab_a(c1,c2) values(v1,v2),(v11,v21)… </li></ol><ul><li>UPDATE不支持的语法</li></ul><ol><li>更新的列包含分片列</li><li>多表更新 update a, b set a.nation=’China’, b.pwd=’123456’ where a.id=b.id </li><li>复杂多表关联更新 update a, b set a.nation=’China’ where a.id=b.id; 但支持子查询方式 update a set a.nation=’China’ where id in (select id from b);</li></ol><ul><li>DELETE不支持语法</li></ul><ol><li>复杂删除sql delete a from a join b on a.id=b.id;  支持子查询方式 delete from a where a.id in (select id from b), 但表不能起别名</li></ol><ul><li>其他</li></ul><ol><li>Call procedure()   MyCat未支持存储过程定义, 因而不允许调用存储过程，但可通过注解来调用各个分片上的存储过程</li><li>Select func(); 不支持这种方式直接调用自定义函数， 但支持 select id, func() from employee 只需employee所在的所有分片上存在这个函数。MySql自带函数可随意使用。</li></ol><h1 id="mycat-使用教程"><a href="#mycat-使用教程" class="headerlink" title="mycat 使用教程"></a>mycat 使用教程</h1><p>mycat分库分表规则主要是修改server.xml、schema.xml和rule.xml。</p><ul><li>server.xml：是Mycat服务器参数调整和用户授权的配置文件。</li><li>schema.xml：是逻辑库定义和表以及分片定义的配置文件。</li><li>rule.xml：是分片规则的配置文件，分片规则的具体一些参数信息单独存放为文件，也在这个目录下，配置文件修改需要重启MyCAT。</li></ul><ol><li><p>mycat服务端server.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:server</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">system</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"nonePasswordLogin"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1为开启实时统计、0为关闭 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useSqlStat"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1为开启全加班一致性检测、0为关闭 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useGlobleTableCheck"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用来指定Mycat全局序列类型，0为本地文件，1为数据库方式，2为时间戳列方式，默认使用本地文件方式，文件方式主要用于测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sequnceHandlerType"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--默认为type 0: DirectByteBufferPool | type 1 ByteBufferArena--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"processorBufferPoolType"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--分布式事务开关，0为不过滤分布式事务，1为过滤分布式事务（如果分布式事务内只涉及全局表，则不过滤），2为不过滤分布式事务,但是记录分布式事务日志--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"handleDistributedTransactions"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置是否启用非堆内存跨分片结果集，1为开启，0为关闭，mycat1.6开始支持该属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useOffHeapForMerge"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单位为m--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"memoryPageSize"</span>&gt;</span>64k<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单位为k--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"spillsFileBufferSize"</span>&gt;</span>1k<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useStreamOutput"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单位为m--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"systemReserveMemorySize"</span>&gt;</span>384m<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--是否采用zookeeper协调切换  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useZKSwitch"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义mycat使用的端口，默认值为8066 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serverPort"</span>&gt;</span>3307<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义mycat管理的端口，默认值为9066 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"managerPort"</span>&gt;</span>9066<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义登录mycat对的用户权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"root"</span> <span class="attr">defaultAccount</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 若要访问TESTDB 必须现在server.xml 中定义，否则无法访问TESTDB--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>dbtest<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置是否允许只读 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"readOnly"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义限制前端整体的连接数，如果其值为0，或者不设置，则表示不限制连接数量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"benchmark"</span>&gt;</span>11111<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置是否开启密码加密功能，默认为0不开启加密，为1则表示开启加密 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usingDecrypt"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:server</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>分库分表schema.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- schema 定义mycat中的逻辑库，可以有多个逻辑库,</span></span><br><span class="line"><span class="comment">1）dataNode属性：绑定逻辑库到具体的Database上面，</span></span><br><span class="line"><span class="comment">2）checkSQLschema：如果为true，则会替换掉schema，如果为false则不会；</span></span><br><span class="line"><span class="comment">3）sqlMaxLimit：如果带了该属性，则每次执行sql的时候如果sql没有limit则会带上这个limit，如果schema为非拆分库，则该属性不会生效。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"dbtest"</span> <span class="attr">checkSQLschema</span>=<span class="string">"true"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- table标签定义了MyCat中的逻辑表，所有拆分的表都需要在table标签中定义。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1）name属性：定义逻辑表的名称--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2）dataNode属性：定义逻辑表所属的dataNode，如果需要引用多个dataNode,则可以用dataNode="dn$0-99" 来代表dn0到dn99的数据库--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3）rule属性：用来指定逻辑表使用的规则名字，规则名字在rule.xml中定义。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4）ruleRequired属性：该属性用于指定表是否绑定分片规则，如果配置为true,但是没有具体的分片规则，则会报错。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 5）type属性：定义逻辑表的类型，分为"全局表（global）"和"普通表"两种类型,不设置该值的时候未global的所有表。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 6）autoIncrement属性：使用该值的时候需要定义auto_increment，使用的时候最好配合数据库模式的全局序列。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 7）subTables属性：dataNode在分表的条件下只能配置一个，不支持各种条件的Join关联查询。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 8）primaryKey属性:逻辑表对应真实表的主键。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 9）needAddLimit属性：指定表是否需要字段再每个语句的后面加上limit限制。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"travelrecord"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">rule</span>=<span class="string">"rule1"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--childTable标签用于定义E-R分片的子表，通过标签上的属性与浮表进行关联--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1)name属性：定义子表的名称--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2）joinKey属性：插入子表时，回使用这个值查找浮表存贮的数据节点--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3）parentKey属性：与父表建立关联关系的列名，程序首先获取joinKey的值，然后通过parentKey属性指定的列名产生查询语句，通过执行语句得知父表存储在哪个分片上，从而确定子表存贮的位置。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4）primaryKey：和table标签一样--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 5）needAddLimit：和table标签一样--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- dataNode标签定义了mycat中的数据节点，这也就是我们通常所说的数据分片，一个单独的dataNode就是一个独立的数据分片--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1）name属性：定义数据节点的唯一名字--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2）dataHost属性：定义该分片所属的数据库实例，属性引用自dataHost标签上定义的name属性--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3）database属性：定义该分片所属的数据库实例上的具体数据库。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn1"</span> <span class="attr">dataHost</span>=<span class="string">"localhost1"</span> <span class="attr">database</span>=<span class="string">"db01"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn2"</span> <span class="attr">dataHost</span>=<span class="string">"localhost1"</span> <span class="attr">database</span>=<span class="string">"db02"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义数据库实例，读写分离和心跳语句--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1)那么属性：标识唯一的dataHost,--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2)maxCon属性：指定每个读写实例连接池的最大连接数。内嵌writeHost、readHost标签会使用这个属性的值来实例化连接池的最大连接数--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3)minCon属性：指定每个读写实例连接池的最小连接数。初始化连接池的大小的属性。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--4）balance属性：负债均衡类型，有四种--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   balance="0" : 不开启读写分离机制，所有的读操作都发送到当前可以用的writeHost上--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   balance="1" : 全部的readHost与stand by writeHost（双主从模式下的master） 都参与select语句的负债均衡--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   balance="2" : 所有的读操作都随机的往writeHost和readHost上分发--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   balance="3" : 所有的读分发到readHost上，writeHost负责写--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--5）writeType属性：负载均衡目前的取值有两种：--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   writeType="0"：所有的写操作都发送到第一个writeHost,writeHost1挂了，则切换到writeHost2上，重新恢复writeHost1后，还是以writeHost2为准--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   writeType="1"：所有的写操作都随机的发送到配置的writeHost上，1.5版本以后不推荐使用该值。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--6）dbType属性：制定后端后端数据的类型：mysql，oracle、mongoDB--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--7）dbDriver属性：制定后端数据库使用的Driver.目前可选的值为native和JDBC。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--8）switchType属性：默认值为1，自动切换。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                  -1表示不自动切换--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                   2表示基于mysql主从同步的状态决定是否切换。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                  3表示基于mysql galaxy cluster 的切换机制--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--9）tempReadHostAvailable属性：如果配置了writeHost属性，下面的readHost依旧可以使用，默认为0--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"localhost1"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span> <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"127.0.0.1:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"123456"</span>&gt;</span> <span class="comment">&lt;!-- url、user、password 设置成你的数据库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>分库分表规则rule.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:rule</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name 属性指定唯一的名字，用于标识不同的表规则</span></span><br><span class="line"><span class="comment">     1）内嵌的 rule 标签则指定对物理表中的哪一列进行拆分和使用什么路由算法。</span></span><br><span class="line"><span class="comment">     2）columns 内指定要拆分的列名字。</span></span><br><span class="line"><span class="comment"> 3)algorithm 使用 function 标签中的 name 属性。连接表规则和具体路由算法。当然，多个表规则可以连接到同一个路由算法上。 table 标签内使用。让逻辑表使用这个规则进行分片。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"rule1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>func1<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--name 指定算法的名字。</span></span><br><span class="line"><span class="comment">1)class 制定路由算法具体的类名字。</span></span><br><span class="line"><span class="comment">2)property 为具体算法需要用到的一些属性。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"func1"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByLong"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionCount"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionLength"</span>&gt;</span>512<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:rule</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="sharding-jdbc-使用教程"><a href="#sharding-jdbc-使用教程" class="headerlink" title="sharding-jdbc 使用教程"></a>sharding-jdbc 使用教程</h1><ol><li><p>maven依赖包</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.shardingsphere&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sharding-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;sharding-sphere.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.shardingsphere&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sharding-jdbc-spring-namespace&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;sharding-sphere.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>分库分表设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  按照 2库+2表分片 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 分库规则-按照user_id取模 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- inline-strategy 行表达式分片策略</span></span><br><span class="line"><span class="comment">  对应InlineShardingStrategy。使用Groovy的表达式，提供对SQL语句中的=和IN的分片操作支持，只支持单分片键。</span></span><br><span class="line"><span class="comment">  对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，</span></span><br><span class="line"><span class="comment">  如: t_user$&#123;u_id % 8&#125; 表示t_user表按照u_id按8取模分成8个表，表名称为t_user0到t_user7。</span></span><br><span class="line"><span class="comment">  1) sharding-column 分片列名称</span></span><br><span class="line"><span class="comment">  2) algorithm-expression 分片算法行表达式，需符合groovy语法</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sharding:inline-strategy</span> <span class="attr">id</span>=<span class="string">"databaseStrategy"</span> <span class="attr">sharding-column</span>=<span class="string">"user_id"</span> <span class="attr">algorithm-expression</span>=<span class="string">"sharding_$-&gt;&#123;user_id % 2&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sharding:inline-strategy</span> <span class="attr">id</span>=<span class="string">"userTableStrategy"</span> <span class="attr">sharding-column</span>=<span class="string">"age"</span> <span class="attr">algorithm-expression</span>=<span class="string">"t_user_$-&gt;&#123;age % 2&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- data-source 分片数据源</span></span><br><span class="line"><span class="comment">  1）sharding-rule data-source-names 原始数据源</span></span><br><span class="line"><span class="comment">  2）table-rules 数据表分片规则列表</span></span><br><span class="line"><span class="comment">  3）table-rule 数据表分片规则</span></span><br><span class="line"><span class="comment">  4）logic-table 逻辑表</span></span><br><span class="line"><span class="comment">  5）generate-key-column-name 分布式主键指定，默认使用雪花算法计算id</span></span><br><span class="line"><span class="comment">  6）actual-data-nodes 由数据源名 + 表名组成，以小数点分隔。多个表以逗号分隔，支持inline表达式。缺省表示使用已知数据源与逻辑表名称生成数据节点。用于广播表（即每个库中都需要一个同样的表用于关联查询，多为字典表）或只分库不分表且所有库的表结构完全一致的情况</span></span><br><span class="line"><span class="comment">  7）database-strategy-ref 默认数据库分片策略，对应&lt;sharding:xxx-strategy&gt;中的策略Id，缺省表示不分库</span></span><br><span class="line"><span class="comment">  8）table-strategy-ref 表分片策略，对应&lt;sharding:xxx-strategy&gt;中的策略Id，缺省表示使用&lt;sharding:sharding-rule /&gt;配置的默认表分片策略</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sharding:data-source</span> <span class="attr">id</span>=<span class="string">"shardingDataSource"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sharding:sharding-rule</span> <span class="attr">data-source-names</span>=<span class="string">"sharding_0,sharding_1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sharding:table-rules</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sharding:table-rule</span> <span class="attr">logic-table</span>=<span class="string">"t_user"</span>  <span class="attr">generate-key-column-name</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">actual-data-nodes</span>=<span class="string">"sharding_$-&gt;&#123;0..1&#125;.t_user_$-&gt;&#123;0..1&#125;"</span> <span class="attr">database-strategy-ref</span>=<span class="string">"databaseStrategy"</span> <span class="attr">table-strategy-ref</span>=<span class="string">"userTableStrategy"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sharding:table-rules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">sharding:sharding-rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sharding:data-source</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;目前公司业务高速发展，各种业务数据呈井喷的态势，单表数据量急剧膨胀，随之而来是单表读写性能和吞吐量呈下降趋势而且无法应对业务高速增长产生的数
      
    
    </summary>
    
      <category term="分库分表" scheme="http://v2.ppjys.cn/categories/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
    
      <category term="分库分表" scheme="http://v2.ppjys.cn/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
      <category term="mycat" scheme="http://v2.ppjys.cn/tags/mycat/"/>
    
      <category term="sharding-jdbc" scheme="http://v2.ppjys.cn/tags/sharding-jdbc/"/>
    
  </entry>
  
  <entry>
    <title>otter</title>
    <link href="http://v2.ppjys.cn/2018/04/24/otter%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/"/>
    <id>http://v2.ppjys.cn/2018/04/24/otter基础介绍/</id>
    <published>2018-04-24T02:07:35.000Z</published>
    <updated>2018-07-03T13:24:35.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote><p>***公司系统间的数据同步通过http接口通信，这种方式会导致数据同步高峰期间nginx的负载流量增加，从而影响业务流量。其二就是http方式的不稳定性，会导致一些数据不一致的问题。针对这个现象，目前提出2中解决方式，第一种可以通过高可用消息队列来进行解耦，第二种通过数据库底层binlog来监听数据变化。</p></blockquote><h2 id="otter介绍"><a href="#otter介绍" class="headerlink" title="otter介绍"></a>otter介绍</h2><blockquote><p>otter为阿里的一款增量数据同步工具，基于数据库增量日志解析，准实时同步到本机房或异地机房的mysql/oracle数据库.一个分布式数据库同步系统。</p></blockquote><h2 id="otter工作原理"><a href="#otter工作原理" class="headerlink" title="otter工作原理"></a>otter工作原理</h2><p><img width="848" src="https://camo.githubusercontent.com/2988fbbc7ddfe94ed027cd71720b1ffa5912a635/687474703a2f2f646c322e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038382f313138392f64343230636131342d326438302d336435352d383038312d6239303833363036613830312e6a7067" height="303" alt=""></p><p>原理描述：</p><ol><li>基于Canal开源产品，获取数据库增量日志数据。</li><li>典型管理系统架构，manager(web管理)+node(工作节点).manager运行时推送同步配置到node节点.node节点将同步状态反馈到manager上.</li><li>基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作.</li></ol><h2 id="Otter目前支持了什么"><a href="#Otter目前支持了什么" class="headerlink" title="Otter目前支持了什么"></a>Otter目前支持了什么</h2><ol><li>单向同步， mysql/oracle互相同步</li><li>双向同步，无冲突变更</li><li>文件同步，本地/aranda文件</li><li>双A同步，冲突检测&amp;冲突补救</li><li>数据迁移，中间表/行记录同步<blockquote><p>典型的场景是账户信息表和账户交易明细表，更新账户余额后需要登记一条账户明细，并且保证在一个事务里，用户可以通过交易明细表查看交易记录，但是交易明细表的数据量是逐步递增的，用户量多的系统，几个月下来的数据超过千万了，表数据量一多就导致查询和插入变慢，而一开始就对账户明细做分表处理就难于保证强一致性事务，通过otter可以将记录同步导历史表，并且进行分表处理，用户往年的交易记录就可以查询历史表了，而原交易明细表就可以删除一个月甚至几天前的数据；</p></blockquote></li></ol><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>otter manager依赖于mysql进行配置信息的存储，所以需要预先安装mysql，并初始化otter <a href="https://raw.github.com/alibaba/otter/master/manager/deployer/src/main/resources/sql/otter-manager-schema.sql" target="_blank" rel="noopener">manager的系统表结构</a>。</li><li>整个otter架构依赖了zookeeper进行多节点调度，所以需要预先安装zookeeper，不需要初始化节点，otter程序启动后会自检.</li><li>安装jdk1.6+<blockquote><p>官方文档：<a href="https://github.com/alibaba/otter/wiki/Manager_Quickstart" target="_blank" rel="noopener">https://github.com/alibaba/otter/wiki/Manager_Quickstart</a><br><a href="https://github.com/alibaba/otter/wiki/Node_Quickstart" target="_blank" rel="noopener">https://github.com/alibaba/otter/wiki/Node_Quickstart</a></p></blockquote></li></ol><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ol><li>Channel：同步通道，单向同步中一个Pipeline组成，在双向同步中有两个Pipeline组成；Pipeline：从源端到目标端的整个过程描述，主要由一些同步映射过程组成；</li><li>DataMediaPair：根据业务表定义映射关系，比如源表和目标表，字段映射，字段组等；</li><li>DataMedia:抽象的数据介质概念，可以理解为数据表/mq队列定义；</li><li>DataMediaSource: 抽象的数据介质源信息，补充描述DateMedia；</li><li>ColumnPair: 定义字段映射关系；</li><li>ColumnGroup: 定义字段映射组；</li><li>Node: 处理同步过程的工作节点，对应一个jvm；</li></ol><h2 id="采坑问题"><a href="#采坑问题" class="headerlink" title="采坑问题"></a>采坑问题</h2><ol><li>mysql需要开启binlog,并且binlog的模式一定要Row。</li><li>mysql5.6版本需要binlog_checksum设置为none，默认开始crc校验。</li><li>mysql mater节点需要设置server-id，server-id需要和manager上配置的node的id一致。错误内容如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pid:1 nid:1 exception:canal:源数据库cancal:java.io.IOException: Received error packet: errno = 1236, sqlstate = HY000 errmsg = Misconfigured master - server_id was not set</span><br><span class="line">    at com.alibaba.otter.canal.parse.inbound.mysql.dbsync.DirectLogFetcher.fetch(DirectLogFetcher.java:105)</span><br><span class="line">    at com.alibaba.otter.canal.parse.inbound.mysql.MysqlConnection.dump(MysqlConnection.java:146)</span><br><span class="line">    at com.alibaba.otter.canal.parse.inbound.AbstractEventParser$3.run(AbstractEventParser.java:227)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/alibaba/otter/wiki" target="_blank" rel="noopener">https://github.com/alibaba/otter/wiki</a></li><li><a href="https://github.com/alibaba/otter/wiki/Faq" target="_blank" rel="noopener">https://github.com/alibaba/otter/wiki/Faq</a></li><li><a href="https://blog.csdn.net/wudufeng/article/details/78688240" target="_blank" rel="noopener">https://blog.csdn.net/wudufeng/article/details/78688240</a></li><li><a href="https://yq.aliyun.com/articles/223077?utm_content=m_32233" target="_blank" rel="noopener">https://yq.aliyun.com/articles/223077?utm_content=m_32233</a></li><li><a href="https://my.oschina.net/u/860872/blog/1609715" target="_blank" rel="noopener">https://my.oschina.net/u/860872/blog/1609715</a></li><li><a href="https://www.cnblogs.com/findumars/p/6294542.html" target="_blank" rel="noopener">https://www.cnblogs.com/findumars/p/6294542.html</a></li><li>mysql binlog优化<br><a href="https://www.cnblogs.com/doseoer/p/6132454.html" target="_blank" rel="noopener">https://www.cnblogs.com/doseoer/p/6132454.html</a></li><li>binlog采坑 <a href="https://www.cnblogs.com/276815076/p/7993712.html" target="_blank" rel="noopener">https://www.cnblogs.com/276815076/p/7993712.html</a></li><li><a href="https://yq.aliyun.com/articles/223077?utm_content=m_32233" target="_blank" rel="noopener">https://yq.aliyun.com/articles/223077?utm_content=m_32233</a></li><li><a href="https://blog.csdn.net/wudufeng/article/details/78688240" target="_blank" rel="noopener">https://blog.csdn.net/wudufeng/article/details/78688240</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;***公司系统间的数据同步通过http接口通信，这种方式会导致数据同步高峰期间nginx的负载流量增加，从而影响业
      
    
    </summary>
    
      <category term="中间件" scheme="http://v2.ppjys.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="otter" scheme="http://v2.ppjys.cn/tags/otter/"/>
    
  </entry>
  
  <entry>
    <title>docker 基础命令</title>
    <link href="http://v2.ppjys.cn/2018/04/23/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>http://v2.ppjys.cn/2018/04/23/docker基础命令/</id>
    <published>2018-04-23T02:07:35.000Z</published>
    <updated>2018-07-03T13:24:35.600Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>拉取镜像</p><blockquote><p>docker pull daocloud.io/library/mysql:5.6</p></blockquote></li><li><p>创建容器</p><blockquote><p>docker run -p 3306:3306 –name mysql -v /Users/peijiepang/Documents/docker/mysql/conf:/etc/mysql -v /Users/peijiepang/Documents/docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d daocloud.io/library/mysql:5.6</p></blockquote></li><li><p>获取所有的容器id</p><blockquote><p>docker ps -a</p></blockquote></li><li><p>启动容器</p><blockquote><p>docker start 578fcc293e25</p></blockquote></li><li><p>查看当前启动的容器</p><blockquote><p>docker ps</p></blockquote></li><li><p>进去容器内部系统</p><blockquote><p>sudo docker exec -it 578fcc293e25 /bin/bash</p></blockquote></li><li><p>退出容器</p><blockquote><p>exit/ctrl+c</p></blockquote></li><li><p>容器重启</p><blockquote><p>docker restart 容器id</p></blockquote></li><li><p>查看容器启动日志</p><blockquote><p>docker logs 容器id</p></blockquote></li><li><p>docker容器安装vim</p><blockquote><p>apt-get update，这个命令的作用是：同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。等更新完毕以后再敲命令：apt-get install vim命令即可。</p></blockquote></li><li><p>容器拷贝文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下:</span><br><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www</span><br><span class="line">将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中</span><br></pre></td></tr></table></figure><ul><li>容器设置时区<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">进入到/usr/share/zoneinfo/Asia目录，查看目录信息</span><br><span class="line">/usr/share/zoneinfo/Asia# ls -hl</span><br><span class="line">lrwxrwxrwx 1 root root    6 Jul  6 02:15 Shanghai -&gt; ../PRC</span><br><span class="line">lrwxrwxrwx 1 root root   12 Jul  6 02:15 Singapore -&gt; ../Singapore</span><br><span class="line">从查询结果可以知道，上海的时区文件实际上是个软连接文件。连接到了目录 /usr/share/zoneinfo/ 下的PRC文件。 </span><br><span class="line">直接进行拷贝：</span><br><span class="line">cp /usr/share/zoneinfo/PRC /etc/localtime</span><br><span class="line">然后这样就可以了。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;拉取镜像&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docker pull daocloud.io/library/mysql:5.6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建容器&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docke
      
    
    </summary>
    
      <category term="docker" scheme="http://v2.ppjys.cn/categories/docker/"/>
    
    
      <category term="命令" scheme="http://v2.ppjys.cn/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>java应用CPU百分百解决方案</title>
    <link href="http://v2.ppjys.cn/2018/04/22/java%E5%BA%94%E7%94%A8CPU%E7%99%BE%E5%88%86%E7%99%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://v2.ppjys.cn/2018/04/22/java应用CPU百分百解决方案/</id>
    <published>2018-04-22T03:07:35.000Z</published>
    <updated>2018-07-03T13:24:35.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用top命令查找异常进程"><a href="#利用top命令查找异常进程" class="headerlink" title="利用top命令查找异常进程"></a>利用top命令查找异常进程</h2><blockquote><p>top</p></blockquote><p>输入top命令后，可以按P(shift+p)根据cpu占用排序、按M根据内存占用排序、按T根据运行时间排序。</p><p>这里先按P根据cpu排序查找异常的线程：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;利用top命令查找异常进程&quot;&gt;&lt;a href=&quot;#利用top命令查找异常进程&quot; class=&quot;headerlink&quot; title=&quot;利用top命令查找异常进程&quot;&gt;&lt;/a&gt;利用top命令查找异常进程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;top&lt;/p&gt;
&lt;/blo
      
    
    </summary>
    
      <category term="问题及解决" scheme="http://v2.ppjys.cn/categories/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="服务器问题" scheme="http://v2.ppjys.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java应用OOM快速定位与解决方法</title>
    <link href="http://v2.ppjys.cn/2018/04/21/OOM%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://v2.ppjys.cn/2018/04/21/OOM快速定位与解决方法/</id>
    <published>2018-04-21T03:07:35.000Z</published>
    <updated>2018-07-03T13:24:35.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近项目老是出现OOM问题，常见有以下错误：</p><pre><code>java.lang.OutOfMemoryError: PermGen spacejava.lang.OutOfMemoryError: Java heap space</code></pre><h2 id="OOM的常见原因"><a href="#OOM的常见原因" class="headerlink" title="OOM的常见原因"></a>OOM的常见原因</h2><ul><li>内存分配确实过小</li><li>频繁创建对象，没有及时释放</li><li>频繁申请系统资源，导致系统资源耗尽（例如：不断创建线程，不断发起网络连接）</li></ul><h2 id="Java代码导致OutOfMemoryError错误的解决"><a href="#Java代码导致OutOfMemoryError错误的解决" class="headerlink" title="Java代码导致OutOfMemoryError错误的解决"></a>Java代码导致OutOfMemoryError错误的解决</h2><ul><li>检查代码中是否有死循环或递归调用。</li><li>检查是否有大循环重复产生新对象实体。</li><li>检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</li><li>检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。</li></ul><h2 id="定位代码解决"><a href="#定位代码解决" class="headerlink" title="定位代码解决"></a>定位代码解决</h2><p>需要先找到出问题的进程，使用top命令定位：</p><blockquote><p>top</p></blockquote><p>输入top命令后，可以按P(shift+p)根据cpu占用排序、按M根据内存占用排序、按T根据运行时间排序。（可以先按c显示具体的command）</p><p>这里先按M根据内存排序查找异常的进程：这里假设出现异常的进程pid为10410</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>定位问题前请先尝试输入jps命令，确定是否能够显示出现问题的pid.如果jps没有相应的显示，可能是你当前用户的权限不够，请使用启用相应进程的用户或者拥有更高权限的用户排查问题！不然以下的一些命令（例如jmap）将无法使用.</p><h2 id="判断是否是由于“内存分配确实过小”"><a href="#判断是否是由于“内存分配确实过小”" class="headerlink" title="判断是否是由于“内存分配确实过小”"></a>判断是否是由于“内存分配确实过小”</h2><p>输入以下命令：</p><blockquote><p>jmap -heap 10410</p></blockquote><pre><code>Attaching to process ID 10410, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.91-b14using thread-local object allocation.Parallel GC with 4 thread(s)Heap Configuration:   MinHeapFreeRatio         = 0   MaxHeapFreeRatio         = 100   MaxHeapSize              = 2147483648 (2048.0MB)   NewSize                  = 44564480 (42.5MB)   MaxNewSize               = 715653120 (682.5MB)   OldSize                  = 89653248 (85.5MB)   NewRatio                 = 2   SurvivorRatio            = 8   MetaspaceSize            = 21807104 (20.796875MB)   CompressedClassSpaceSize = 1073741824 (1024.0MB)   MaxMetaspaceSize         = 17592186044415 MB   G1HeapRegionSize         = 0 (0.0MB)Heap Usage:PS Young GenerationEden Space:   capacity = 343408640 (327.5MB)   used     = 63192336 (60.26490783691406MB)   free     = 280216304 (267.23509216308594MB)   18.401498576156964% usedFrom Space:   capacity = 18350080 (17.5MB)   used     = 12886976 (12.28997802734375MB)   free     = 5463104 (5.21002197265625MB)   70.22844587053571% usedTo Space:   capacity = 18874368 (18.0MB)   used     = 0 (0.0MB)   free     = 18874368 (18.0MB)   0.0% usedPS Old Generation   capacity = 80216064 (76.5MB)   used     = 24040136 (22.92646026611328MB)   free     = 56175928 (53.57353973388672MB)   29.969229106030433% used23018 interned Strings occupying 2885744 bytes.</code></pre><h2 id="判断是否是由于“频繁创建对象，没有及时回收”"><a href="#判断是否是由于“频繁创建对象，没有及时回收”" class="headerlink" title="判断是否是由于“频繁创建对象，没有及时回收”"></a>判断是否是由于“频繁创建对象，没有及时回收”</h2><p>输入以下命令，找出最耗内存的对象：</p><blockquote><p>jmap -histo:live 10410 | more</p></blockquote><pre><code>      num     #instances         #bytes  class name----------------------------------------------   1:         59259        8998824  [C   2:         21537        1895256  java.lang.reflect.Method   3:         57709        1385016  java.lang.String   4:          2683        1063512  [B   5:          9175        1021368  java.lang.Class   6:         18681         747240  java.util.LinkedHashMap$Entry   7:         21370         683840  java.util.concurrent.ConcurrentHashMap$Node   8:          8166         574544  [Ljava.util.HashMap$Node;   9:          9977         558712  java.util.LinkedHashMap  10:          9548         518480  [Ljava.lang.Object;  11:         21735         472376  [Ljava.lang.Class;  12:         13345         427040  java.util.HashMap$Node  13:          5570         401040  java.lang.reflect.Field  14:           259         258400  [Ljava.util.concurrent.ConcurrentHashMap$Node;  15:         14774         236384  java.lang.Object  16:          2692         215360  java.lang.reflect.Constructor  17:          3413         198216  [Ljava.lang.reflect.Method;  18:          4133         160288  [Ljava.lang.String;  19:          3695         147800  java.lang.ref.SoftReference  20:          1537         147552  org.springframework.beans.GenericTypeAwarePropertyDescriptor  21:          2378         133168  java.lang.Class$ReflectionData  22:          2861         132256  [I  23:          4050         129600  java.util.LinkedList  24:          3749         119968  java.lang.ref.WeakReference  25:          2435         116880  java.util.HashMap  26:          4509         108216  java.util.ArrayList  27:          4080          97920  java.beans.MethodRef  28:          2154          86160  java.util.TreeMap$Entry  29:          1188          85536  org.springframework.core.annotation.AnnotationAttributes  30:          1126          72064  org.springframework.core.MethodParameter  31:          2858          68592  java.util.LinkedList$Node  32:          3928          62848  java.util.LinkedHashSet  33:           370          62160  org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader$ConfigurationClassBeanDefinition  34:          2185          52440  sun.reflect.generics.tree.SimpleClassTypeSignature  35:          2016          48384  sun.reflect.annotation.AnnotationInvocationHandler  36:           961          46128  org.springframework.core.ResolvableType  37:           901          43248  org.apache.tomcat.util.modeler.AttributeInfo  38:          2023          43200  [Ljava.lang.reflect.Type;  39:          2570          41120  java.util.LinkedHashMap$LinkedKeySet  40:          2185          41096  [Lsun.reflect.generics.tree.TypeArgument;  41:          1282          41024  java.util.concurrent.locks.ReentrantLock$NonfairSync  42:          2472          39552  java.util.LinkedHashMap$LinkedEntrySet  43:          2374          37984  org.springframework.core.annotation.AnnotationUtils$DefaultValueHolder  44:          1593          37008  [Ljava.lang.reflect.Constructor;</code></pre><p>输入命令后，会以表格的形式显示存活对象的信息，并按照所占内存大小排序。</p><ul><li>instances: 对象实例数量</li><li>bytes: 占用内存大小</li><li>class name: 类名</li></ul><p>可以看到目前最耗内存的对象也才占用内存8m，所以属于正常范畴</p><p>如果发现某个对象的占用大量内存（例如：1G以上），就需要review代码，审查下该对象是否没有及时回收</p><p>PS：其中输出的奇怪的class name请查看最后的附录。</p><h2 id="判断是否是由于“频繁申请系统资源”"><a href="#判断是否是由于“频繁申请系统资源”" class="headerlink" title="判断是否是由于“频繁申请系统资源”"></a>判断是否是由于“频繁申请系统资源”</h2><p>输入以下命令，查看进程的线程数</p><blockquote><p>ll /proc/{PID}/task | wc -l</p></blockquote><p>输入以下命令，查看进程的句柄数</p><blockquote><p>ll /proc/{PID}/fd | wc -l</p></blockquote><h2 id="jmap-附加说明"><a href="#jmap-附加说明" class="headerlink" title="jmap 附加说明"></a>jmap 附加说明</h2><table><thead><tr><th>BaseType Character</th><th>Type</th><th>Interpretation</th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>signed byte</td></tr><tr><td>C</td><td>char</td><td>Unicode character</td></tr><tr><td>D</td><td>double</td><td>double-precision floating-point value</td></tr><tr><td>F</td><td>float</td><td>single-precision floating-point value</td></tr><tr><td>I</td><td>int</td><td>integer</td></tr><tr><td>J</td><td>long</td><td>long integer</td></tr><tr><td>L</td><td>reference    an</td><td>instance of class</td></tr><tr><td>S</td><td>short</td><td>signed short</td></tr><tr><td>Z</td><td>boolean</td><td>true or false</td></tr><tr><td>[</td><td>reference</td><td>one array dimension</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近项目老是出现OOM问题，常见有以下错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java.lang.OutOfMemoryError: Perm
      
    
    </summary>
    
      <category term="问题及解决" scheme="http://v2.ppjys.cn/categories/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="OutOfMemoryError" scheme="http://v2.ppjys.cn/tags/OutOfMemoryError/"/>
    
  </entry>
  
  <entry>
    <title>druid数据源无可用连接问题</title>
    <link href="http://v2.ppjys.cn/2018/04/20/druid%E6%95%B0%E6%8D%AE%E6%BA%90%E6%97%A0%E5%8F%AF%E7%94%A8%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://v2.ppjys.cn/2018/04/20/druid数据源无可用连接问题/</id>
    <published>2018-04-20T07:07:35.000Z</published>
    <updated>2018-07-03T13:24:35.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在工程中使用了druid连接池，运行一段时间后系统出现异常,但是使用客户端能正常连接，连接数被未被占满,报错如下：</p><blockquote><p>Caused by: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 60009, active 50                  at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:80)                  at org.springframework.jdbc.support.JdbcUtils.extractDatabaseMetaData(JdbcUtils.java:280)                  … 64 more  </p></blockquote><h2 id="原因及解决方案"><a href="#原因及解决方案" class="headerlink" title="原因及解决方案"></a>原因及解决方案</h2><p>应该是程序中有地方连接未关闭造成的。那如何来定呢？使用druid连接池的超时回收机制，在配置中增加以下内容：</p><pre><code>&lt;!– 超过时间限制是否回收 –&gt;  &lt;property name=“removeAbandoned” value=“true” /&gt;  &lt;!– 超时时间；单位为秒。180秒=3分钟 –&gt;  &lt;property name=“removeAbandonedTimeout” value=“180” /&gt;  &lt;!– 关闭abanded连接时输出错误日志 –&gt;  &lt;property name=“logAbandoned” value=“true” /&gt;   </code></pre><p>但是加了logAbandoned配置之后，可能经常会强制释放连接报错，错误如下：</p><blockquote><p>[com.alibaba.druid.pool.DruidDataSource] – &lt;abandon connection, open stackTrace          at java.lang.Thread.getStackTrace(Thread.java:1567)          at com.alibaba.druid.pool.DruidDataSource.getConnectionDirect(DruidDataSource.java:995)          at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:4544) </p></blockquote><pre><code>备注：该堆栈是之前使用该连接是new出来的，故可以凭此确认此链接使用没有很好的回收。 但理论上使用了mybatis，mybatis会负责好连接池申请回放回</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在工程中使用了druid连接池，运行一段时间后系统出现异常,但是使用客户端能正常连接，连接数被未被占满,报错如下：&lt;/p&gt;
&lt;blockqu
      
    
    </summary>
    
      <category term="问题及解决" scheme="http://v2.ppjys.cn/categories/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="连接池" scheme="http://v2.ppjys.cn/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>解决OutOfMemoryError: unable to create new native thread问题</title>
    <link href="http://v2.ppjys.cn/2018/04/19/%E8%A7%A3%E5%86%B3OutOfMemoryError-unable-to-create-new-native-thread%E9%97%AE%E9%A2%98/"/>
    <id>http://v2.ppjys.cn/2018/04/19/解决OutOfMemoryError-unable-to-create-new-native-thread问题/</id>
    <published>2018-04-19T06:07:35.000Z</published>
    <updated>2018-07-03T13:24:35.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>java.lang.OutOfMemoryError共有8种类型，其中java.lang.OutOfMemoryError: unable to create new native thread是很常见的一种，这类错误通常发生在应用试图创建新线程时。最近测试环境经常出现错误如下：</p><blockquote><p>Caused by: java.lang.OutOfMemoryError: unable to create new native thread<br>    at java.lang.Thread.start0(Native Method)<br>    at java.lang.Thread.start(Thread.java:714)<br>    at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:950)<br>    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1368)<br>    at com.alibaba.dubbo.remoting.transport.dispatcher.all.AllChannelHandler.caught(AllChannelHandler.java:65)</p></blockquote><h2 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因"></a>可能原因</h2><ol><li>系统内存耗尽，无法为新线程分配内存</li><li>创建线程数超过了操作系统的限制</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li><p>排查应用是否创建了过多的线程</p><blockquote><p>通过jstack确定应用创建了多少线程？超量创建的线程的堆栈信息是怎样的？谁创建了这些线程？一旦明确了这些问题，便很容易解决。步骤如下：</p><blockquote><p>该进程内最耗费CPU的线程pid top -Hp pid</p><p>将pid装换成十六进制 printf “%x\n” 21742</p><p>最后用jstack查找线程堆栈信息 jstack 21711 | grep 54ee</p></blockquote></blockquote></li><li><p>调整操作系统线程数阈值</p><blockquote><p>操作系统会限制进程允许创建的线程数，使用ulimit -u命令查看限制。某些服务器上此阈值设置的过小，比如1024。一旦应用创建超过1024个线程，就会遇到java.lang.OutOfMemoryError: unable to create new native thread问题。如果是这种情况，可以调大操作系统线程数阈值。</p><blockquote><p>用当前用户登录，然后用ulimit -a查看配置项，将max user processes项调整大一点，可以参考top -H 信息中的 Threads: 853 total线程数</p></blockquote></blockquote></li><li><p>增加机器内存</p><blockquote><p>如果上述两项未能排除问题，可能是正常增长的业务确实需要更多内存来创建更多线程。如果是这种情况，增加机器内存。</p></blockquote></li><li><p>减小堆内存</p><blockquote><p>一个老司机也经常忽略的非常重要的知识点：线程不在堆内存上创建，线程在堆内存之外的内存上创建。所以如果分配了堆内存之后只剩下很少的可用内存，依然可能遇到java.lang.OutOfMemoryError: unable to create new native thread。考虑如下场景：系统总内存6G，堆内存分配了5G，永久代512M。在这种情况下，JVM占用了5.5G内存，系统进程、其他用户进程和线程将共用剩下的0.5G内存，很有可能没有足够的可用内存创建新的线程。如果是这种情况，考虑减小堆内存。</p></blockquote></li><li><p>减少进程数</p><blockquote><p>这和减小堆内存原理相似。考虑如下场景：系统总内存32G，java进程数5个，每个进程的堆内存6G。在这种情况下，java进程总共占用30G内存，仅剩下2G内存用于系统进程、其他用户进程和线程，很有可能没有足够的可用内存创建新的线程。如果是这种情况，考虑减少每台机器上的进程数。</p></blockquote></li><li><p>减小线程栈大小</p><blockquote><p>线程会占用内存，如果每个线程都占用更多内存，整体上将消耗更多的内存。每个线程默认占用内存大小取决于JVM实现。可以利用-Xss参数限制线程内存大小，降低总内存消耗。例如，JVM默认每个线程占用1M内存，应用有500个线程，那么将消耗500M内存空间。如果实际上256K内存足够线程正常运行，配置-Xss256k，那么500个线程将只需要消耗125M内存。（注意，如果-Xss设置的过低，将会产生java.lang.StackOverflowError错误）</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;java.lang.OutOfMemoryError共有8种类型，其中java.lang.OutOfMemoryError: unable 
      
    
    </summary>
    
      <category term="问题及解决" scheme="http://v2.ppjys.cn/categories/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="OutOfMemoryError" scheme="http://v2.ppjys.cn/tags/OutOfMemoryError/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="http://v2.ppjys.cn/2018/04/12/hello-hexo/"/>
    <id>http://v2.ppjys.cn/2018/04/12/hello-hexo/</id>
    <published>2018-04-11T16:00:00.000Z</published>
    <updated>2018-07-03T13:24:35.602Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以前一直用wordpress维护博客，最近看到hexo博客的样例，觉得挺炫的，今天就准备将<a href="http://ppjys.cn" target="_blank" rel="noopener">wordpress版本</a>的博客迁移到hexo，然后重新梳理以前的博文。</p></blockquote><h2 id="Hexo-Quick-Start"><a href="#Hexo-Quick-Start" class="headerlink" title="Hexo Quick Start"></a>Hexo Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以前一直用wordpress维护博客，最近看到hexo博客的样例，觉得挺炫的，今天就准备将&lt;a href=&quot;http://ppjys.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wordpress版本&lt;/a&gt;的博客迁移到h
      
    
    </summary>
    
      <category term="感悟" scheme="http://v2.ppjys.cn/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="感悟" scheme="http://v2.ppjys.cn/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
</feed>
