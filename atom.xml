<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J~杰&#39;s Blog</title>
  
  <subtitle>人生就一条路，走一步有一步的景观</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ppjys.cn/"/>
  <updated>2018-07-13T13:15:27.413Z</updated>
  <id>http://ppjys.cn/</id>
  
  <author>
    <name>J~杰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ideaVim使用记录</title>
    <link href="http://ppjys.cn/2018/05/02/ideaVim%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://ppjys.cn/2018/05/02/ideaVim使用记录/</id>
    <published>2018-05-02T04:07:35.000Z</published>
    <updated>2018-07-13T13:15:27.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>开发写代码一直想脱离鼠标操作，看起来高大上一点，最近开始idea用vim操作。以下是vim的简单快捷键。</p><h2 id="keymap-记录"><a href="#keymap-记录" class="headerlink" title="keymap 记录"></a>keymap 记录</h2><ul><li>跳转到指定行：{行数}g</li><li>标签特切换：gt或者gT,前者顺序切换，后者逆向切换</li><li>单词移动：w/W，移动到下个单词开头；b/B,倒退到上个单词开头。大写的会忽略标点。命令前加数字表示执行次数，如2W</li><li>删除当前单词并进入插入模式：cw</li><li>撤销：u;恢复被撤销的操作：ctrl+r</li><li>v进入选择字符，V进入行选择模式</li><li>用y命令将文本存入寄存器,普通模式下小写p把寄存器内容复制到当前位置之后,大写P把寄存器内容复制到当前位置之前</li><li>剪切操作，先v选择多行，然后d删除，最后到需要粘贴的地方p</li><li>跳转到特定行,按:n 如 :23  跳转到23行</li><li>x(小写) -&gt; 正向按字符单位进行删除 向右删除</li><li>X(大写) -&gt; 反向按字符单位进行删除 向左删除</li><li>$ -&gt; 当前行的最后一个字符</li><li>G -&gt; 跳转到最后一行</li></ul><h2 id="组合技巧"><a href="#组合技巧" class="headerlink" title="组合技巧"></a>组合技巧</h2><ul><li>全选： ggvG </li><li>调换两个字符位置： xp</li><li>复制一行： yyp </li><li>调换两行位置： ddp </li><li>复制后，在命令模式下 np n代表数字你想要粘贴的数目,如 10p</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;开发写代码一直想脱离鼠标操作，看起来高大上一点，最近开始idea用vim操作。以下是vim的简单快捷键。&lt;/p&gt;
&lt;h2 id=&quot;keyma
      
    
    </summary>
    
      <category term="vim" scheme="http://ppjys.cn/categories/vim/"/>
    
    
      <category term="vim" scheme="http://ppjys.cn/tags/vim/"/>
    
      <category term="idea" scheme="http://ppjys.cn/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>Mycat分片规则使用指南</title>
    <link href="http://ppjys.cn/2018/05/01/Mycat%E5%88%86%E7%89%87%E8%A7%84%E5%88%99%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://ppjys.cn/2018/05/01/Mycat分片规则使用指南/</id>
    <published>2018-05-01T04:07:35.000Z</published>
    <updated>2018-07-13T13:12:25.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="枚举法"><a href="#枚举法" class="headerlink" title="枚举法"></a>枚举法</h2><p>通过在配置文件中配置可能的枚举id，自己配置分片，本规则适用于特定的场景，比如有些业务需要按照省 份或区县来做保存，而全国省份区县固定的，这类业务使用本条规则，配置如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;tableRule name=&quot;sharding-by-intfile&quot;&gt;</span><br><span class="line">    &lt;rule&gt;</span><br><span class="line">      &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">      &lt;columns&gt;user_id&lt;/columns&gt;</span><br><span class="line">      &lt;!--分片函数--&gt;</span><br><span class="line">      &lt;algorithm&gt;hash-int&lt;/algorithm&gt;</span><br><span class="line">    &lt;/rule&gt;</span><br><span class="line">&lt;/tableRule&gt;</span><br><span class="line">&lt;function name=&quot;hash-int&quot; class=&quot;com.dxy.mycat.route.function.PartitionByFileMap&quot;&gt;</span><br><span class="line">&lt;!--标识配置文件名称--&gt;</span><br><span class="line">    &lt;property name=&quot;mapFile&quot;&gt;partition-hash-int.txt&lt;/property&gt;</span><br><span class="line">    &lt;!--type默认值为0，0表示Integer，非零表示String--&gt;</span><br><span class="line">    &lt;property name=&quot;type&quot;&gt;0&lt;/property&gt;</span><br><span class="line">    &lt;!--所有的节点配置都是从0开始，及0代表节点1--&gt;</span><br><span class="line">    &lt;property name=&quot;defaultNode&quot;&gt;0&lt;/property&gt;</span><br><span class="line">&lt;/function&gt;</span><br></pre></td></tr></table></figure></p><p>partition-hash-int.txt 配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10000=0</span><br><span class="line">10010=1</span><br><span class="line">DEFAULT_NODE=1</span><br></pre></td></tr></table></figure></p><p>配置说明:</p><blockquote><p>上面 columns 标识将要分片的表字段，algorithm 分片函数，其中分片函数配置中，mapFile 标识配置文件名称，type为分片字段的类型，默认值为 0，0 表示 Integer，非零表示 String， 所有的节点配置都是从 0 开始，及 0 代表节点 1；defaultNode 默认节点:小于 0 表示不设置默认节点，大于等于 0 表示设置默认节点，默认节点的作用:枚举分片时，如果碰到不识别的枚举值，就让它路由到默认节点；如果不配置默认节点(defaultNode 值小于 0 表示不配置默认节点)，碰到不识别的枚举值就会报错</p></blockquote><a id="more"></a><h2 id="固定分片hash算法"><a href="#固定分片hash算法" class="headerlink" title="固定分片hash算法"></a>固定分片hash算法</h2><p>本条规则类似于十进制的求模运算，区别在于是二进制的操作,是取 id 的二进制低 10 位，即 id 二进制 &amp;1111111111。<br>此算法的优点在于如果按照 10 进制取模运算，在连续插入 1-10 时候 1-10 会被分到 1-10 个分片，增 大了插入的事务控制难度，而此算法根据二进制则可能会分到连续的分片，减少插入事务事务控制难度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;tableRule name=&quot;rule1&quot;&gt;</span><br><span class="line">  &lt;rule&gt;</span><br><span class="line">    &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">    &lt;columns&gt;user_id&lt;/columns&gt;</span><br><span class="line">    &lt;!--分片函数--&gt;</span><br><span class="line">    &lt;algorithm&gt;func1&lt;/algorithm&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line">&lt;/tableRule&gt;</span><br><span class="line">&lt;function name=&quot;func1&quot; class=&quot;com.dxy.mycat.route.function.PartitionByLong&quot;&gt;</span><br><span class="line">  &lt;!--分片个数列表--&gt;</span><br><span class="line">  &lt;property name=&quot;partitionCount&quot;&gt;2,1&lt;/property&gt;</span><br><span class="line">  &lt;!--分片范围列表--&gt;</span><br><span class="line">  &lt;property name=&quot;partitionLength&quot;&gt;256,512&lt;/property&gt;</span><br><span class="line">  &lt;!--分区长度:默认为最大2^n=1024 ,即最大支持1024分区--&gt;</span><br><span class="line">&lt;/function&gt;</span><br></pre></td></tr></table></figure></p><p>配置说明:</p><blockquote><p>上面 columns 标识将要分片的表字段，algorithm 分片函数，<br>partitionCount 分片个数列表，partitionLength 分片范围列表 分区长度:默认为最大 2^n=1024 ,即最大支持 1024 分区,</p></blockquote><p>约束:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count,length两个数组的长度必须是一致的。</span><br><span class="line">1024 = sum((count[i]*length[i])). count和length两个向量的点积恒等于1024</span><br></pre></td></tr></table></figure></p><p>用法例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">本例的分区策略：希望将数据水平分成3份，前两份各占25%，第三份占50%。（故本例非均匀分区）</span><br><span class="line">// |&lt;---------------------1024------------------------&gt;|</span><br><span class="line">// |&lt;----256---&gt;|&lt;----256---&gt;|&lt;----------512----------&gt;|</span><br><span class="line">// | partition0 | partition1 | partition2 |</span><br><span class="line">// | 共2份,故count[0]=2 | 共1份，故count[1]=1 |</span><br><span class="line">int[] count = new int[] &#123; 2, 1 &#125;;</span><br><span class="line">int[] length = new int[] &#123; 256, 512 &#125;;</span><br><span class="line">PartitionUtil pu = new PartitionUtil(count, length);</span><br><span class="line">// 下面代码演示分别以offerId字段或memberId字段根据上述分区策略拆分的分配结果</span><br><span class="line">int DEFAULT_STR_HEAD_LEN = 8; // cobar默认会配置为此值</span><br><span class="line">long offerId = 12345;</span><br><span class="line">String memberId = &quot;qiushuo&quot;;</span><br><span class="line">// 若根据offerId分配，partNo1将等于0，即按照上述分区策略，offerId为12345时将会被分配到partition0中</span><br><span class="line">int partNo1 = pu.partition(offerId);</span><br><span class="line">// 若根据memberId分配，partNo2将等于2，即按照上述分区策略，memberId为qiushuo时将会被分到partition2中</span><br><span class="line">int partNo2 = pu.partition(memberId, 0, DEFAULT_STR_HEAD_LEN);</span><br></pre></td></tr></table></figure></p><p>如果需要平均分配设置：平均分为4分片，partitionCount*partitionLength=1024<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;function name=&quot;func1&quot; class=&quot;com.dxy.mycat.route.function.PartitionByLong&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;partitionCount&quot;&gt;4&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;partitionLength&quot;&gt;256&lt;/property&gt;</span><br><span class="line">&lt;/function&gt;</span><br></pre></td></tr></table></figure></p><h2 id="范围约定"><a href="#范围约定" class="headerlink" title="范围约定"></a>范围约定</h2><p>此分片适用于，提前规划好分片字段某个范围属于哪个分片,start &lt;= range &lt;= end.K=1000,M=10000.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;tableRule name=&quot;auto-sharding-long&quot;&gt;</span><br><span class="line">    &lt;rule&gt;</span><br><span class="line">      &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">      &lt;columns&gt;user_id&lt;/columns&gt;</span><br><span class="line">      &lt;!--分片函数--&gt;</span><br><span class="line">      &lt;algorithm&gt;rang-long&lt;/algorithm&gt;</span><br><span class="line">    &lt;/rule&gt;</span><br><span class="line">&lt;/tableRule&gt;</span><br><span class="line">&lt;function name=&quot;rang-long&quot; class=&quot;com.dxy.mycat.route.function.AutoPartitionByLong&quot;&gt;</span><br><span class="line">&lt;!--配置文件路径--&gt;</span><br><span class="line">    &lt;property name=&quot;mapFile&quot;&gt;autopartition-long.txt&lt;/property&gt;</span><br><span class="line">&lt;/function&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># range start-end ,data node index</span><br><span class="line"># 所有的节点配置都是从0开始，及0代表节点1，此配置非常简单，即预先制定可能的id范围到某个分片</span><br><span class="line"># K=1000,M=10000.</span><br><span class="line">0-500M=0</span><br><span class="line">500M-1000M=1</span><br><span class="line">1000M-1500M=2</span><br><span class="line">或</span><br><span class="line">0-10000000=0</span><br><span class="line">10000001-20000000=1</span><br></pre></td></tr></table></figure><p>配置说明:</p><blockquote><p>上面 columns 标识将要分片的表字段，algorithm 分片函数，rang-long 函数中 mapFile 代表配置文件路径<br>defaultNode 超过范围后的默认节点。</p><p>所有的节点配置都是从 0 开始，及 0 代表节点 1，此配置非常简单，即预先制定可能的 id 范围到某个分片<br>0-500M=0 500M-1000M=1<br>1000M-1500M=2 或<br>0-10000000=0 10000001-20000000=1</p></blockquote><h2 id="求模法"><a href="#求模法" class="headerlink" title="求模法"></a>求模法</h2><p>此种配置非常明确即根据 id进行十进制求模预算，相比固定分片 hash，此种在批量插入时可能存在批量插入单 事务插入多数据分片，增大事务一致性难度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;tableRule name=&quot;mod-long&quot;&gt;</span><br><span class="line">   &lt;rule&gt;</span><br><span class="line">     &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">     &lt;columns&gt;user_id&lt;/columns&gt;</span><br><span class="line">     &lt;!--分片函数--&gt;</span><br><span class="line">     &lt;algorithm&gt;mod-long&lt;/algorithm&gt;</span><br><span class="line">   &lt;/rule&gt;</span><br><span class="line">&lt;/tableRule&gt;</span><br><span class="line">&lt;function name=&quot;mod-long&quot; class=&quot;com.dxy.mycat.route.function.PartitionByMod&quot;&gt;</span><br><span class="line">   &lt;!--注意！这里填写数据库节点数，否则无法分片--&gt;</span><br><span class="line">   &lt;property name=&quot;count&quot;&gt;3&lt;/property&gt;</span><br><span class="line">&lt;/function&gt;</span><br></pre></td></tr></table></figure></p><h2 id="日期列分区法"><a href="#日期列分区法" class="headerlink" title="日期列分区法"></a>日期列分区法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;tableRule name=&quot;sharding-by-date&quot;&gt;</span><br><span class="line">      &lt;rule&gt;</span><br><span class="line">        &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">        &lt;columns&gt;create_time&lt;/columns&gt;</span><br><span class="line">        &lt;!--分片函数--&gt;</span><br><span class="line">        &lt;algorithm&gt;sharding-by-date&lt;/algorithm&gt;</span><br><span class="line">      &lt;/rule&gt;</span><br><span class="line">&lt;/tableRule&gt;  </span><br><span class="line">&lt;function name=&quot;sharding-by-date&quot; class=&quot;com.dxy.mycat.route.function.PartitionByDate&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dateFormat&quot;&gt;yyyy-MM-dd&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;sBeginDate&quot;&gt;2015-01-01&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;sPartionDay&quot;&gt;10&lt;/property&gt;</span><br><span class="line">&lt;/function&gt;</span><br></pre></td></tr></table></figure><p>配置中配置了开始日期，分区天数，即默认从开始日期算起，分隔10天一个分区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertEquals(true, 0 == partition.calculate(&quot;2015-01-01&quot;));</span><br><span class="line">Assert.assertEquals(true, 0 == partition.calculate(&quot;2015-01-10&quot;));</span><br><span class="line">Assert.assertEquals(true, 1 == partition.calculate(&quot;2015-01-11&quot;));</span><br><span class="line">Assert.assertEquals(true, 12 == partition.calculate(&quot;2015-05-01&quot;));</span><br></pre></td></tr></table></figure></p><p>配置说明:</p><blockquote><p>columns :标识将要分片的表字段;<br>algorithm :分片函数;<br>dateFormat :日期格式;<br>sBeginDate :开始日期;<br>sEndDate:结束日期;<br>sPartionDay :分区天数，即默认从开始日期算起，分隔 10 天一个分区;</p></blockquote><h2 id="通配取模"><a href="#通配取模" class="headerlink" title="通配取模"></a>通配取模</h2><p>此种规则是取模运算与范围约束的结合，主要为了后续数据迁移做准备，即可以自主决定取模后数据的节点分布。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;tableRule name=&quot;sharding-by-pattern&quot;&gt;</span><br><span class="line">      &lt;rule&gt;</span><br><span class="line">        &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">        &lt;columns&gt;user_id&lt;/columns&gt;</span><br><span class="line">        &lt;!--分片函数--&gt;</span><br><span class="line">        &lt;algorithm&gt;sharding-by-pattern&lt;/algorithm&gt;</span><br><span class="line">      &lt;/rule&gt;</span><br><span class="line">&lt;/tableRule&gt;</span><br><span class="line">&lt;function name=&quot;sharding-by-pattern&quot; class=&quot;com.dxy.mycat.route.function.PartitionByPattern&quot;&gt;</span><br><span class="line">&lt;!--求模基数--&gt;</span><br><span class="line">    &lt;property name=&quot;patternValue&quot;&gt;256&lt;/property&gt;</span><br><span class="line">    &lt;!--默认节点--&gt;</span><br><span class="line">    &lt;!--如果配置了默认，则不会按照求模运算--&gt;</span><br><span class="line">    &lt;property name=&quot;defaultNode&quot;&gt;2&lt;/property&gt;</span><br><span class="line">    &lt;!-- 配置文件路径--&gt;</span><br><span class="line">    &lt;property name=&quot;mapFile&quot;&gt;partition-pattern.txt&lt;/property&gt;</span><br><span class="line">&lt;/function&gt;</span><br></pre></td></tr></table></figure></p><p>partition-pattern.txt ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># id partition range start-end ,data node index</span><br><span class="line">###### first host configuration</span><br><span class="line">1-32=0</span><br><span class="line">33-64=1</span><br><span class="line">65-96=2</span><br><span class="line">97-128=3</span><br><span class="line">######## second host configuration</span><br><span class="line">129-160=4</span><br><span class="line">161-192=5</span><br><span class="line">193-224=6</span><br><span class="line">225-256=7</span><br><span class="line">0-0=7</span><br><span class="line">#1-32 即代表id%256后分布的范围，如果在1-32则在分区1，其他类推，如果id非数据，则会分配在defaoultNode 默认节点</span><br></pre></td></tr></table></figure></p><h2 id="ASCII码求模通配"><a href="#ASCII码求模通配" class="headerlink" title="ASCII码求模通配"></a>ASCII码求模通配</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;tableRule name=&quot;sharding-by-prefixpattern&quot;&gt;</span><br><span class="line">      &lt;rule&gt;</span><br><span class="line">        &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">        &lt;columns&gt;user_id&lt;/columns&gt;</span><br><span class="line">        &lt;!--分片函数--&gt;</span><br><span class="line">        &lt;algorithm&gt;sharding-by-prefixpattern&lt;/algorithm&gt;</span><br><span class="line">      &lt;/rule&gt;</span><br><span class="line">&lt;/tableRule&gt;</span><br><span class="line">&lt;function name=&quot;sharding-by-pattern&quot; class=&quot;com.dxy.mycat.route.function.PartitionByPattern&quot;&gt;</span><br><span class="line">    &lt;!--求模基数--&gt;</span><br><span class="line">    &lt;property name=&quot;patternValue&quot;&gt;256&lt;/property&gt;</span><br><span class="line">    &lt;!--ASCII 截取的位数--&gt;</span><br><span class="line">    &lt;property name=&quot;prefixLength&quot;&gt;5&lt;/property&gt;</span><br><span class="line">    &lt;!-- 配置文件路径--&gt;</span><br><span class="line">    &lt;property name=&quot;mapFile&quot;&gt;partition-pattern.txt&lt;/property&gt;</span><br><span class="line">&lt;/function&gt;</span><br></pre></td></tr></table></figure><p>partition-pattern.txt：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># range start-end ,data node index</span><br><span class="line"># ASCII</span><br><span class="line"># 48-57=0-9</span><br><span class="line"># 64、65-90=@、A-Z</span><br><span class="line"># 97-122=a-z</span><br><span class="line">###### first host configuration</span><br><span class="line">1-4=0</span><br><span class="line">5-8=1</span><br><span class="line">9-12=2</span><br><span class="line">13-16=3</span><br><span class="line">###### second host configuration</span><br><span class="line">17-20=4</span><br><span class="line">21-24=5</span><br><span class="line">25-28=6</span><br><span class="line">29-32=7</span><br><span class="line">0-0=7</span><br><span class="line">#1-32 即代表id%256后分布的范围，如果在1-32则在分区1，其他类推</span><br></pre></td></tr></table></figure></p><p>此种方式类似方式6只不过采取的是将列种获取前prefixLength位列所有ASCII码的和进行求模sum%patternValue ,获取的值，在通配范围内的即 分片数，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ASCII编码：</span><br><span class="line">48-57=0-9阿拉伯数字</span><br><span class="line">64、65-90=@、A-Z</span><br><span class="line">97-122=a-z</span><br></pre></td></tr></table></figure></p><p>配置说明:</p><blockquote><p>上面 columns 标识将要分片的表字段，algorithm 分片函数，patternValue 即求模基数，prefixLength ASCII 截取的位数<br>mapFile 配置文件路径<br>配置文件中，1-32 即代表 id%256 后分布的范围，如果在 1-32 则在分区 1，其他类推</p></blockquote><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String idVal=&quot;gf89f9a&quot;;</span><br><span class="line">Assert.assertEquals(true, 0==autoPartition.calculate(idVal));</span><br><span class="line">idVal=&quot;8df99a&quot;;</span><br><span class="line">Assert.assertEquals(true, 4==autoPartition.calculate(idVal));</span><br><span class="line">idVal=&quot;8dhdf99a&quot;;</span><br><span class="line">Assert.assertEquals(true, 3==autoPartition.calculate(idVal));</span><br></pre></td></tr></table></figure></p><h2 id="编程指定"><a href="#编程指定" class="headerlink" title="编程指定"></a>编程指定</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;tableRule name=&quot;sharding-by-substring&quot;&gt;</span><br><span class="line">      &lt;rule&gt;</span><br><span class="line">    &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">        &lt;columns&gt;user_id&lt;/columns&gt;</span><br><span class="line">&lt;!--分片函数--&gt;</span><br><span class="line">        &lt;algorithm&gt;sharding-by-substring&lt;/algorithm&gt;</span><br><span class="line">      &lt;/rule&gt;</span><br><span class="line">   &lt;/tableRule&gt;</span><br><span class="line">&lt;function name=&quot;sharding-by-substring&quot; class=&quot;com.dxy.mycat.route.function.PartitionDirectBySubString&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;startIndex&quot;&gt;0&lt;/property&gt; &lt;!-- zero-based --&gt;</span><br><span class="line">    &lt;property name=&quot;size&quot;&gt;2&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;partitionCount&quot;&gt;8&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;defaultPartition&quot;&gt;0&lt;/property&gt;</span><br><span class="line">&lt;/function&gt;</span><br></pre></td></tr></table></figure><p>此方法为直接根据字符子串（必须是数字）计算分区号（由应用传递参数，显式指定分区号）。<br>例如id=05-100000002<br>在此配置中代表根据id中从startIndex=0，开始，截取siz=2位数字即05，05就是获取的分区，如果没传默认分配到defaultPartition</p><ul><li>字符串拆分hash解析<strong>不推荐使用</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;tableRule name=&quot;sharding-by-stringhash&quot;&gt;</span><br><span class="line">      &lt;rule&gt;</span><br><span class="line">        &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">        &lt;columns&gt;user_id&lt;/columns&gt;</span><br><span class="line">        &lt;!--分片函数--&gt;</span><br><span class="line">        &lt;algorithm&gt;sharding-by-stringhash&lt;/algorithm&gt;</span><br><span class="line">      &lt;/rule&gt;</span><br><span class="line">&lt;/tableRule&gt;</span><br><span class="line">&lt;function name=&quot;sharding-by-substring&quot; class=&quot;com.dxy.mycat.route.function.PartitionDirectBySubString&quot;&gt;</span><br><span class="line">&lt;!--字符串hash求模基数--&gt;</span><br><span class="line">    &lt;property name=length&gt;512&lt;/property&gt; &lt;!-- zero-based --&gt;</span><br><span class="line">    &lt;!--分区数--&gt;</span><br><span class="line">    &lt;property name=&quot;count&quot;&gt;2&lt;/property&gt;</span><br><span class="line">    &lt;!--预算位--&gt;</span><br><span class="line">    &lt;property name=&quot;hashSlice&quot;&gt;0:2&lt;/property&gt;</span><br><span class="line">&lt;/function&gt;</span><br></pre></td></tr></table></figure></li></ul><p>配置说明：</p><blockquote><p>上面 columns 标识将要分片的表字段，algorithm 分片函数 函数中 partitionLength 代表字符串 hash 求模基数，<br>partitionCount 分区数，<br>hashSlice hash 预算位，即根据子字符串中 int 值 hash 运算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; &quot;2&quot; -&amp;gt; (0,2)&lt;br/&gt;</span><br><span class="line">&gt; &quot;1:2&quot; -&amp;gt; (1,2)&lt;br/&gt;</span><br><span class="line">&gt; &quot;1:&quot; -&amp;gt; (1,0)&lt;br/&gt;</span><br><span class="line">&gt; &quot;-1:&quot; -&amp;gt; (-1,0)&lt;br/&gt;</span><br><span class="line">&gt; &quot;:-1&quot; -&amp;gt; (0,-1)&lt;br/&gt;</span><br><span class="line">&gt; &quot;:&quot; -&amp;gt; (0,0)&lt;br/&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">String idVal=null;</span><br><span class="line"> rule.setPartitionLength(&quot;512&quot;);</span><br><span class="line"> rule.setPartitionCount(&quot;2&quot;);</span><br><span class="line"> rule.init();</span><br><span class="line"> rule.setHashSlice(&quot;0:2&quot;);</span><br><span class="line">//idVal = &quot;0&quot;;</span><br><span class="line">//Assert.assertEquals(true, 0 == rule.calculate(idVal));</span><br><span class="line">//idVal = &quot;45a&quot;;</span><br><span class="line">//Assert.assertEquals(true, 1 == rule.calculate(idVal));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//last 4</span><br><span class="line">rule = new PartitionByString();</span><br><span class="line">rule.setPartitionLength(&quot;512&quot;);</span><br><span class="line">rule.setPartitionCount(&quot;2&quot;);</span><br><span class="line">rule.init();</span><br><span class="line">//last 4 characters</span><br><span class="line">rule.setHashSlice(&quot;-4:0&quot;);</span><br><span class="line">idVal = &quot;aaaabbb0000&quot;;</span><br><span class="line">Assert.assertEquals(true, 0 == rule.calculate(idVal));</span><br><span class="line">idVal = &quot;aaaabbb2359&quot;;</span><br><span class="line">Assert.assertEquals(true, 0 == rule.calculate(idVal));</span><br></pre></td></tr></table></figure></p><h2 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;tableRule name=&quot;sharding-by-murmur&quot;&gt;</span><br><span class="line">      &lt;rule&gt;</span><br><span class="line">        &lt;columns&gt;user_id&lt;/columns&gt;</span><br><span class="line">        &lt;algorithm&gt;murmur&lt;/algorithm&gt;</span><br><span class="line">      &lt;/rule&gt;</span><br><span class="line">&lt;/tableRule&gt;</span><br><span class="line">&lt;function name=&quot;murmur&quot; class=&quot;com.dxy.mycat.route.function.PartitionByMurmurHash&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;seed&quot;&gt;0&lt;/property&gt;&lt;!-- 默认是0--&gt;</span><br><span class="line">      &lt;property name=&quot;count&quot;&gt;2&lt;/property&gt;&lt;!-- 要分片的数据库节点数量，必须指定，否则没法分片--&gt;</span><br><span class="line">      &lt;property name=&quot;virtualBucketTimes&quot;&gt;160&lt;/property&gt;&lt;!-- 一个实际的数据库节点被映射为这么多虚拟节点，默认是160倍，也就是虚拟节点数是物理节点数的160倍--&gt;</span><br><span class="line">      &lt;!--</span><br><span class="line">      &lt;property name=&quot;weightMapFile&quot;&gt;weightMapFile&lt;/property&gt;</span><br><span class="line">                     节点的权重，没有指定权重的节点默认是1。以properties文件的格式填写，以从0开始到count-1的整数值也就是节点索引为key，以节点权重值为值。所有权重值必须是正整数，否则以1代替 --&gt;</span><br><span class="line">      &lt;!--</span><br><span class="line">      &lt;property name=&quot;bucketMapPath&quot;&gt;/etc/mycat/bucketMapPath&lt;/property&gt;</span><br><span class="line">                      用于测试时观察各物理节点与虚拟节点的分布情况，如果指定了这个属性，会把虚拟节点的murmur hash值与物理节点的映射按行输出到这个文件，没有默认值，如果不指定，就不会输出任何东西 --&gt;</span><br><span class="line">&lt;/function&gt;</span><br></pre></td></tr></table></figure><p>一致性hash预算有效解决了分布式数据的扩容问题，前1-9中id规则都多少存在数据扩容难题，而10规则解决了数据扩容难点</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;枚举法&quot;&gt;&lt;a href=&quot;#枚举法&quot; class=&quot;headerlink&quot; title=&quot;枚举法&quot;&gt;&lt;/a&gt;枚举法&lt;/h2&gt;&lt;p&gt;通过在配置文件中配置可能的枚举id，自己配置分片，本规则适用于特定的场景，比如有些业务需要按照省 份或区县来做保存，而全国省份区县固定的，这类业务使用本条规则，配置如下&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;tableRule name=&amp;quot;sharding-by-intfile&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;rule&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;!--标识将要分片的表字段--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;columns&amp;gt;user_id&amp;lt;/columns&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;!--分片函数--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;algorithm&amp;gt;hash-int&amp;lt;/algorithm&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/rule&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/tableRule&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;function name=&amp;quot;hash-int&amp;quot; class=&amp;quot;com.dxy.mycat.route.function.PartitionByFileMap&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;!--标识配置文件名称--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;property name=&amp;quot;mapFile&amp;quot;&amp;gt;partition-hash-int.txt&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;!--type默认值为0，0表示Integer，非零表示String--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;property name=&amp;quot;type&amp;quot;&amp;gt;0&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;!--所有的节点配置都是从0开始，及0代表节点1--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;property name=&amp;quot;defaultNode&amp;quot;&amp;gt;0&amp;lt;/property&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/function&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;partition-hash-int.txt 配置：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;10000=0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10010=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DEFAULT_NODE=1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;配置说明:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上面 columns 标识将要分片的表字段，algorithm 分片函数，其中分片函数配置中，mapFile 标识配置文件名称，type为分片字段的类型，默认值为 0，0 表示 Integer，非零表示 String， 所有的节点配置都是从 0 开始，及 0 代表节点 1；defaultNode 默认节点:小于 0 表示不设置默认节点，大于等于 0 表示设置默认节点，默认节点的作用:枚举分片时，如果碰到不识别的枚举值，就让它路由到默认节点；如果不配置默认节点(defaultNode 值小于 0 表示不配置默认节点)，碰到不识别的枚举值就会报错&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="分库分表" scheme="http://ppjys.cn/categories/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
    
      <category term="mycat" scheme="http://ppjys.cn/tags/mycat/"/>
    
  </entry>
  
  <entry>
    <title>Mycat部署文档之Haproxy</title>
    <link href="http://ppjys.cn/2018/05/01/Mycat%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3%E4%B9%8BHaproxy/"/>
    <id>http://ppjys.cn/2018/05/01/Mycat部署文档之Haproxy/</id>
    <published>2018-05-01T04:07:35.000Z</published>
    <updated>2018-07-13T13:12:12.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Haproxy"><a href="#Haproxy" class="headerlink" title="Haproxy　　"></a>Haproxy　　</h2><p>HAProxy是一个使用C语言编写的自由及开放源代码软件，其提供高可用性、负载均衡，以及基于TCP和HTTP的应用程序代理。</p><p>HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中， 同时可以保护你的web服务器不被暴露到网络上。 </p><h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><p>依赖gcc和make安装包</p><blockquote><p>sudo apt-get build-dep  gcc</p></blockquote><p>安装完了可以执行如下的命令来查看版本，</p><blockquote><p>gcc –version</p></blockquote><p>安装make安装包</p><blockquote><p>sudo apt install ubuntu-make</p></blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@haproxy-server-master ~]# cd /home/dxy/temp/</span><br><span class="line">[root@haproxy-server-master src]# wget http://pkgs.fedoraproject.org/repo/pkgs/haproxy/haproxy-1.7.9.tar.gz/sha512/d1ed791bc9607dbeabcfc6a1853cf258e28b3a079923b63d3bf97504dd59e64a5f5f44f9da968c23c12b4279e8d45ff3bd39418942ca6f00d9d548c9a0ccfd73/haproxy-1.7.9.tar.gz</span><br><span class="line">[root@haproxy-server-master src]# tar -xvf haproxy-1.7.9.tar.gz</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haproxy-server-master src]# cd haproxy-1.7.9</span><br><span class="line">[root@haproxy-server-master haproxy-1.7.9]# uname -r</span><br><span class="line">3.10.0-514.el7.x86_64</span><br><span class="line">[root@haproxy-server-master haproxy-1.7.9]# make TARGET=linux2628 ARCH=x86_64 PREFIX=/home/dxy/haproxy</span><br><span class="line">[root@haproxy-server-master haproxy-1.7.9]# make install PREFIX=/home/dxy/haproxy</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>TARGET=linux310，内核版本，使用uname -r查看内核，如：3.10.0-514.el7，此时该参数就为linux310；kernel 大于2.6.28的可以用：TARGET=linux2628；</li><li>ARCH=x86_64，系统位数；</li><li>PREFIX=/home/dxy/haproxy #/home/dxy/haproxy，为haprpxy安装路径。</li></ul><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>1.79及以后的版本解压后文件内就没有haproxy.cfg文件，所以需要我们自己找个模板写一下。</p><p>由于没有配置其他的服务器，这里就简单的添加一个可以让Haproxy启动的配置。</p><p>haproxy 配置中分成五部分内容，分别如下：</p><ul><li>global：参数是进程级的，通常是和操作系统相关。这些参数一般只设置一次，如果配置无误，就不需要再次进行修改；</li><li>defaults：配置默认参数，这些参数可以被用到frontend，backend，Listen组件；</li><li>frontend：接收请求的前端虚拟节点，Frontend可以更加规则直接指定具体使用后端的backend；</li><li>backend：后端服务集群的配置，是真实服务器，一个Backend对应一个或者多个实体服务器；</li><li>Listen Fronted和backend的组合体。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">[root@haproxy-server-master haproxy]# mkdir conf</span><br><span class="line">[root@haproxy-server-master haproxy]# ls</span><br><span class="line">conf  doc  sbin  share</span><br><span class="line">[root@haproxy-server-master haproxy]# cd conf/</span><br><span class="line">[root@haproxy-server-master conf]# vim haproxy.cfg</span><br><span class="line"></span><br><span class="line">global   # 全局参数的设置</span><br><span class="line">    log 127.0.0.1 local0 info</span><br><span class="line">    # log语法：log &lt;address_1&gt;[max_level_1] # 全局的日志配置，使用log关键字，指定使用127.0.0.1上的syslog服务中的local0日志设备，记录日志等级为info的日志</span><br><span class="line">    user haproxy</span><br><span class="line">    group haproxy</span><br><span class="line">    # 设置运行haproxy的用户和组，也可使用uid，gid关键字替代之</span><br><span class="line">    daemon</span><br><span class="line">    # 以守护进程的方式运行</span><br><span class="line">    nbproc 16</span><br><span class="line">    # 设置haproxy启动时的进程数，根据官方文档的解释，我将其理解为：该值的设置应该和服务器的CPU核心数一致，即常见的2颗8核心CPU的服务器，即共有16核心，则可以将其值设置为：&lt;=16 ，创建多个进程数，可以减少每个进程的任务队列，但是过多的进程数也可能会导致进程的崩溃。这里我设置为16</span><br><span class="line">    maxconn 4096</span><br><span class="line">    # 定义每个haproxy进程的最大连接数 ，由于每个连接包括一个客户端和一个服务器端，所以单个进程的TCP会话最大数目将是该值的两倍。</span><br><span class="line">    #ulimit -n 65536</span><br><span class="line">    # 设置最大打开的文件描述符数，在1.4的官方文档中提示，该值会自动计算，所以不建议进行设置</span><br><span class="line">    pidfile /var/run/haproxy.pid</span><br><span class="line">    # 定义haproxy的pid </span><br><span class="line">defaults # 默认部分的定义</span><br><span class="line">    mode http</span><br><span class="line">    # mode语法：mode &#123;http|tcp|health&#125; 。http是七层模式，tcp是四层模式，health是健康检测，返回OK</span><br><span class="line">    log 127.0.0.1 local3 err</span><br><span class="line">    # 使用127.0.0.1上的syslog服务的local3设备记录错误信息</span><br><span class="line">    retries 3</span><br><span class="line">    # 定义连接后端服务器的失败重连次数，连接失败次数超过此值后将会将对应后端服务器标记为不可用</span><br><span class="line">    option httplog</span><br><span class="line">    # 启用日志记录HTTP请求，默认haproxy日志记录是不记录HTTP请求的，只记录“时间[Jan 5 13:23:46] 日志服务器[127.0.0.1] 实例名已经pid[haproxy[25218]] 信息[Proxy http_80_in stopped.]”，日志格式很简单。</span><br><span class="line">    option redispatch</span><br><span class="line">    # 当使用了cookie时，haproxy将会将其请求的后端服务器的serverID插入到cookie中，以保证会话的SESSION持久性；而此时，如果后端的服务器宕掉了，但是客户端的cookie是不会刷新的，如果设置此参数，将会将客户的请求强制定向到另外一个后端server上，以保证服务的正常。</span><br><span class="line">    option abortonclose</span><br><span class="line">    # 当服务器负载很高的时候，自动结束掉当前队列处理比较久的链接</span><br><span class="line">    option dontlognull</span><br><span class="line">    # 启用该项，日志中将不会记录空连接。所谓空连接就是在上游的负载均衡器或者监控系统为了探测该服务是否存活可用时，需要定期的连接或者获取某一固定的组件或页面，或者探测扫描端口是否在监听或开放等动作被称为空连接；官方文档中标注，如果该服务上游没有其他的负载均衡器的话，建议不要使用该参数，因为互联网上的恶意扫描或其他动作就不会被记录下来</span><br><span class="line">    option httpclose</span><br><span class="line">    # 这个参数我是这样理解的：使用该参数，每处理完一个request时，haproxy都会去检查http头中的Connection的值，如果该值不是close，haproxy将会将其删除，如果该值为空将会添加为：Connection: close。使每个客户端和服务器端在完成一次传输后都会主动关闭TCP连接。与该参数类似的另外一个参数是“option forceclose”，该参数的作用是强制关闭对外的服务通道，因为有的服务器端收到Connection: close时，也不会自动关闭TCP连接，如果客户端也不关闭，连接就会一直处于打开，直到超时。</span><br><span class="line">    contimeout 5000</span><br><span class="line">    # 设置成功连接到一台服务器的最长等待时间，默认单位是毫秒，新版本的haproxy使用timeout connect替代，该参数向后兼容</span><br><span class="line">    clitimeout 3000</span><br><span class="line">    # 设置连接客户端发送数据时的成功连接最长等待时间，默认单位是毫秒，新版本haproxy使用timeout client替代。该参数向后兼容</span><br><span class="line">    srvtimeout 3000</span><br><span class="line">    # 设置服务器端回应客户度数据发送的最长等待时间，默认单位是毫秒，新版本haproxy使用timeout server替代。该参数向后兼容</span><br><span class="line"></span><br><span class="line">listen status # 定义一个名为status的部分</span><br><span class="line">    bind 0.0.0.0:1080</span><br><span class="line">    # 定义监听的套接字</span><br><span class="line">    mode http</span><br><span class="line">    # 定义为HTTP模式</span><br><span class="line">    log global</span><br><span class="line">    # 继承global中log的定义</span><br><span class="line">    stats refresh 30s</span><br><span class="line">    # stats是haproxy的一个统计页面的套接字，该参数设置统计页面的刷新间隔为30s</span><br><span class="line">    stats uri /admin?stats</span><br><span class="line">    # 设置统计页面的uri为/admin?stats</span><br><span class="line">    stats realm Private lands</span><br><span class="line">    # 设置统计页面认证时的提示内容</span><br><span class="line">    stats auth admin:password</span><br><span class="line">    # 设置统计页面认证的用户和密码，如果要设置多个，另起一行写入即可</span><br><span class="line">    stats hide-version</span><br><span class="line">    # 隐藏统计页面上的haproxy版本信息</span><br><span class="line">## listen: 用于定义通过关联“前端”和“后端”一个完整的代理，通常只对TCP流量有用</span><br><span class="line"></span><br><span class="line">listen mycat_servers</span><br><span class="line">    bind  :3306 ## 绑定端口</span><br><span class="line">    mode  tcp</span><br><span class="line">    option     tcplog     ## 记录TCP请求日志</span><br><span class="line">    option     tcpka ##是否允许向server和client发送keepalive</span><br><span class="line">    option     httpchk OPTIONS * HTTP/1.1\r\nHost:\ www ## 后端服务状态检测</span><br><span class="line">    ### 向后端服务器的48700端口（端口值在后端服务器上通过xinetd配置）发送 OPTIONS 请求</span><br><span class="line">    ### (原理请参考HTTP协议) ，HAProxy会根据返回内容来判断后端服务是否可用.</span><br><span class="line">    ### 2xx 和 3xx 的响应码表示健康状态，其他响应码或无响应表示服务器故障。</span><br><span class="line">    balance    roundrobin ## 定义负载均衡算法，可用于&quot;defaults&quot;、&quot;listen&quot;和&quot;backend&quot;中,默认为轮询方式</span><br><span class="line">    server     mycat_01 192.168.1.203:8066 check port 48700 inter 2000ms rise 2 fall 3 weight 10</span><br><span class="line">    server     mycat_02 192.168.1.204:8066 check port 48700 inter 2000ms rise 2 fall 3 weight 10</span><br><span class="line">    ## 格式：server</span><br><span class="line">    ### serser 在后端声明一个server，只能用于listen和backend区段</span><br><span class="line">    ###为此服务器指定的内部名称，其将会出现在日志及警告信息中</span><br><span class="line">    ###此服务器的IPv4地址，也支持使用可解析的主机名，但要在启动时需要解析主机名至响应的IPV4地址</span><br><span class="line">    ### [:[port]]指定将客户端连接请求发往此服务器时的目标端口，此为可选项</span><br><span class="line">    ### [param*]为此server设定的一系列参数，均为可选项，参数比较多，下面仅说明几个常用的参数：</span><br><span class="line">    #### weight:权重，默认为1，最大值为256，0表示不参与负载均衡</span><br><span class="line">    #### backup:设定为备用服务器，仅在负载均衡场景中的其他server均不可以启用此server</span><br><span class="line">    #### check:启动对此server执行监控状态检查，其可以借助于额外的其他参数完成更精细的设定</span><br><span class="line">    #### inter:设定监控状态检查的时间间隔，单位为毫秒，默认为2000，</span><br><span class="line">    ##### 也可以使用fastinter和downinter来根据服务器端专题优化此事件延迟</span><br><span class="line">    #### rise:设置server从离线状态转换至正常状态需要检查的次数（不设置的情况下，默认值为2）</span><br><span class="line">    #### fall:设置server从正常状态转换至离线状态需要检查的次数（不设置的情况下，默认值为3）</span><br><span class="line">    #### cookie:为指定server设定cookie值，此处指定的值将会在请求入站时被检查，</span><br><span class="line">    ##### 第一次为此值挑选的server将会被后续的请求所选中，其目的在于实现持久连接的功能</span><br><span class="line">    #### maxconn:指定此服务器接受的最大并发连接数，如果发往此服务器的连接数目高于此处指定的值，</span><br><span class="line">    #####其将被放置于请求队列，以等待其他连接被释放</span><br></pre></td></tr></table></figure><h2 id="Mycat状态监测"><a href="#Mycat状态监测" class="headerlink" title="Mycat状态监测"></a>Mycat状态监测</h2><p>安装xinetd组件，用于开放监听端口</p><blockquote><p>sudo apt-get install xinetd</p></blockquote><p>在Mycat server1 Mycat server2上都需要添加检测端口48700的脚本，为此需要用到xinetd<br>首先在xinetd目录下面增加脚本与端口的映射配置文件</p><blockquote><p>vim /etc/xinetd.d/mycat_status<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">service mycat_status</span><br><span class="line">&#123;</span><br><span class="line">        flags           = REUSE</span><br><span class="line">        socket_type     = stream</span><br><span class="line">        port            = 48700</span><br><span class="line">        wait            = no</span><br><span class="line">        user            = nobody</span><br><span class="line">        server          = /home/dxy/mycat/bin/mycat_status.sh</span><br><span class="line">        log_on_failure  += USERID</span><br><span class="line">        disable         = no</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>注意：mycat_status检测脚本已经平台已经打包在安装包里面了的，由于里面用到了source，ubuntu请参考<a href="http://www.linuxdiyf.com/linux/22530.html解决。" target="_blank" rel="noopener">http://www.linuxdiyf.com/linux/22530.html解决。</a></p><p>增加service端口映射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/services</span><br><span class="line"># Local services</span><br><span class="line">mycat_status    48700/tcp</span><br></pre></td></tr></table></figure><p>重启xinetd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service xinetd restart</span><br></pre></td></tr></table></figure></p><h2 id="启动haproxy"><a href="#启动haproxy" class="headerlink" title="启动haproxy"></a>启动haproxy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haproxy-server-master conf]# /home/dxy/haproxy/sbin/haproxy -f /home/dxy/haproxy/conf/haproxy.cfg</span><br></pre></td></tr></table></figure><p>验证一下是否启动成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@haproxy-server-master conf]# lsof -i :1080</span><br><span class="line">COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">haproxy 2221 root    3u  IPv4  20285      0t0  TCP *:socks (LISTEN)</span><br></pre></td></tr></table></figure></p><h2 id="haproxy管理平台"><a href="#haproxy管理平台" class="headerlink" title="haproxy管理平台"></a>haproxy管理平台</h2><p>地址：<a href="http://127.0.0.1:1080/admin?stats" target="_blank" rel="noopener">http://127.0.0.1:1080/admin?stats</a></p><ul><li><h2 id="haproxy记录日志（可选）"><a href="#haproxy记录日志（可选）" class="headerlink" title="haproxy记录日志（可选）"></a>haproxy记录日志（可选）</h2>默认 haproxy 是不记录日志的，为了记录日志需要配置 syslog 模块，在 linux 下是 rsyslogd 服务。</li></ul><ol><li><p>先安装 rsyslog（系统应该都安装了，先查看一下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install rsyslog</span><br></pre></td></tr></table></figure></li><li><p>添加haproxy的日志配置</p><blockquote><p>vim /etc/rsyslog.d/haproxy.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ModLoad imudp</span><br><span class="line">$UDPServerRun 514</span><br><span class="line">local0.* /home/dxy/haproxy/logs/haproxy.log</span><br></pre></td></tr></table></figure></blockquote></li></ol><p>日志的level: local0～local7 16～23保留为本地使用</p><ul><li>0 debug   有调式信息的，日志信息最多</li><li>1 info    一般信息的日志，最常用</li><li>2 notice  最具有重要性的普通条件的信息</li><li>3 warning 警告级别</li><li>4 err 错误级别，阻止某个功能或者模块不能正常工作的信息</li><li>5 crit 严重级别，阻止整个系统或者整个软件不能正常工作的信息</li><li>6 alert  需要立刻修改的信息</li><li>7 emerg  内核崩溃等严重信息</li></ul><ol start="3"><li><p>修改 /etc/rsyslog.conf 文件</p><blockquote><p>在#### RULES ####上面一行的地方加入以下内容（文件里应该默认有这个配置，可以看一下）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haproxy-server-master /]# vim /etc/rsyslog.conf</span><br><span class="line"></span><br><span class="line"># Include all config files in /etc/rsyslog.d/</span><br><span class="line">$IncludeConfig /etc/rsyslog.d/*.conf</span><br></pre></td></tr></table></figure></blockquote></li><li><p>修改 /etc/sysconfig/rsyslog 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@haproxy-server-master /]# vim /etc/default/rsyslog</span><br><span class="line"></span><br><span class="line">SYSLOGD_OPTIONS=&quot;-r -m 0 -c 2&quot;</span><br></pre></td></tr></table></figure></li></ol><p>相关解释说明:</p><ul><li>-r:打开接受外来日志消息的功能,其监控514 UDP端口;</li><li>-x:关闭自动解析对方日志服务器的FQDN信息,这能避免DNS不完整所带来的麻烦;</li><li>-m:修改syslog的内部mark消息写入间隔时间(0为关闭),例如240为每隔240分钟写入一次”–MARK–”信息;</li><li>-h:默认情况下,syslog不会发送从远端接受过来的消息到其他主机,而使用该选项,则把该开关打开,所有 接受到的信息都可根据syslog.conf中定义的@主机转发过去。</li></ul><h5 id="保存，重启-rsyslog-服务"><a href="#保存，重启-rsyslog-服务" class="headerlink" title="保存，重启 rsyslog 服务"></a>保存，重启 rsyslog 服务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@haproxy-server-master /]# systemctl restart rsyslog.service</span><br><span class="line">[root@haproxy-server-master /]# systemctl status rsyslog.service</span><br><span class="line">● rsyslog.service - System Logging Service</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/rsyslog.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since 一 2017-11-27 10:51:26 CST; 11s ago</span><br><span class="line">     Docs: man:rsyslogd(8)</span><br><span class="line">           http://www.rsyslog.com/doc/</span><br><span class="line"> Main PID: 3855 (rsyslogd)</span><br><span class="line">   CGroup: /system.slice/rsyslog.service</span><br><span class="line">           └─3855 /usr/sbin/rsyslogd -n</span><br><span class="line"></span><br><span class="line">11月 27 10:51:26 haproxy-server-master systemd[1]: Starting System Logging Service...</span><br><span class="line">11月 27 10:51:26 haproxy-server-master rsyslogd[3855]:  [origin software=&quot;rsyslogd&quot; swVersion=&quot;8.24.0&quot; x-pid=&quot;38...tart</span><br><span class="line">11月 27 10:51:26 haproxy-server-master systemd[1]: Started System Logging Service.</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show in full.</span><br></pre></td></tr></table></figure><p>现在你就可以看到日志（/home/dxy/haproxy/logs/haproxy.log）了（如果没有，重启一下Haproxy）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Haproxy&quot;&gt;&lt;a href=&quot;#Haproxy&quot; class=&quot;headerlink&quot; title=&quot;Haproxy　　&quot;&gt;&lt;/a&gt;Haproxy　　&lt;/h2&gt;&lt;p&gt;HAProxy是一个使用C语言编写的自由及开放源代码软件，其提供高可用性、负载均衡，以及基于TCP和HTTP的应用程序代理。&lt;/p&gt;
&lt;p&gt;HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中， 同时可以保护你的web服务器不被暴露到网络上。 &lt;/p&gt;
&lt;h2 id=&quot;安装依赖包&quot;&gt;&lt;a href=&quot;#安装依赖包&quot; class=&quot;headerlink&quot; title=&quot;安装依赖包&quot;&gt;&lt;/a&gt;安装依赖包&lt;/h2&gt;&lt;p&gt;依赖gcc和make安装包&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo apt-get build-dep  gcc&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装完了可以执行如下的命令来查看版本，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gcc –version&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;安装make安装包&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo apt install ubuntu-make&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@haproxy-server-master ~]# cd /home/dxy/temp/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@haproxy-server-master src]# wget http://pkgs.fedoraproject.org/repo/pkgs/haproxy/haproxy-1.7.9.tar.gz/sha512/d1ed791bc9607dbeabcfc6a1853cf258e28b3a079923b63d3bf97504dd59e64a5f5f44f9da968c23c12b4279e8d45ff3bd39418942ca6f00d9d548c9a0ccfd73/haproxy-1.7.9.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@haproxy-server-master src]# tar -xvf haproxy-1.7.9.tar.gz&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="分库分表" scheme="http://ppjys.cn/categories/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
    
      <category term="mycat" scheme="http://ppjys.cn/tags/mycat/"/>
    
  </entry>
  
  <entry>
    <title>Mycat部署文档之Keepalived</title>
    <link href="http://ppjys.cn/2018/05/01/Mycat%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3%E4%B9%8BKeepalived/"/>
    <id>http://ppjys.cn/2018/05/01/Mycat部署文档之Keepalived/</id>
    <published>2018-05-01T03:07:35.000Z</published>
    <updated>2018-07-13T13:11:57.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="keepalived-安装"><a href="#keepalived-安装" class="headerlink" title="keepalived 安装"></a>keepalived 安装</h2><p>直接通过apt-get方式安装最简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon /]# apt-get install libssl-dev openssl libpopt-dev</span><br><span class="line">[root@bogon /]# apt-get install -y keepalived</span><br><span class="line">[root@bogon /]# keepalived -v</span><br><span class="line">[root@bogon /]# Keepalived v1.2.13 (08/03,2017)</span><br></pre></td></tr></table></figure></p><h3 id="编写-Haproxy-状态监测"><a href="#编写-Haproxy-状态监测" class="headerlink" title="编写 Haproxy 状态监测"></a>编写 Haproxy 状态监测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon /]# vim /etc/keepalived/check_haproxy.sh</span><br><span class="line">#!/bin/sh</span><br><span class="line">if [ $(ps -C haproxy --no-header | wc -l) -eq 0 ]; then</span><br><span class="line">    /home/dxy/haproxy/sbin/haproxy -f /home/dxy/haproxy/conf/haproxy.cfg</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">sleep 2</span><br><span class="line">if [ $(ps -C haproxy --no-header | wc -l) -eq 0 ]; then</span><br><span class="line">    killall keepalived</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="设置keepalived-master的最简配置"><a href="#设置keepalived-master的最简配置" class="headerlink" title="设置keepalived master的最简配置"></a>设置keepalived master的最简配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"># global setting , notify email setting</span><br><span class="line">global_defs &#123;</span><br><span class="line">    #存在于同一个网段中，一组keepalived的各个节点都有不同的名字</span><br><span class="line">    #在全局设置中，我们还可以设置管理员的email信息等。</span><br><span class="line">    router_id LVS_V1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#这个是我们在上一小结讲到的haproxy检查脚本，我们保存在这个文件中（注意文件权限）</span><br><span class="line">vrrp_script chkhaproxy &#123;</span><br><span class="line">    script &quot;/etc/keepalived/check_haproxy.sh&quot;</span><br><span class="line">    #每10秒钟，检查一次</span><br><span class="line">    interval 10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#keepalived实例设置，是最重要的设置信息</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    #state状态MASTER表示是主要工作节点。</span><br><span class="line">    #一个keepalived组中，最多只有一个MASTER节点，当然也可以没有</span><br><span class="line">    state MASTER</span><br><span class="line">    #实例所绑定的网卡设备，我的网卡设备是ens33。您按照您自己的来</span><br><span class="line">    interface ens33</span><br><span class="line">    #同一个keepalived组，节点的设置必须一样，这样才会被识别</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    #节点优先级，BACKUP的优先级一定要比MASTER的优先级低</span><br><span class="line">    priority 100</span><br><span class="line">    #组播信息发送间隔，两个节点设置必须一样</span><br><span class="line">    advert_int 1</span><br><span class="line">    #实际的ens33上的固定ip地址</span><br><span class="line">    mcast_src_ip 192.168.1.11</span><br><span class="line">    #验证信息，只有验证信息相同，才能被加入到一个组中。</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    #虚拟地址和绑定的端口，如果有多个，就绑定多个</span><br><span class="line">    #dev 是指定浮动IP要绑定的网卡设备号</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.1.10 dev ens33</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #设置的检查脚本</span><br><span class="line">    #关联上方的“vrrp_script chkhaproxy”</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chkhaproxy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置keepalived-slave的最简配置"><a href="#设置keepalived-slave的最简配置" class="headerlink" title="设置keepalived slave的最简配置"></a>设置keepalived slave的最简配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"># global setting , notify email setting</span><br><span class="line">global_defs &#123;</span><br><span class="line">    #这里和master节点不同</span><br><span class="line">    router_id LVS_V2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#check haproxy</span><br><span class="line">vrrp_script chkhaproxy &#123;</span><br><span class="line">    script &quot;/etc/keepalived/check_haproxy.sh&quot;</span><br><span class="line">    interval 10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># instance setting</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    # 这里和Master节点不一样</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    # 这里一定是一样的</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    # 这里的优先级比Master节点低</span><br><span class="line">    priority 99</span><br><span class="line">    advert_int 1</span><br><span class="line">    # 这里和Master节点不一样</span><br><span class="line">    mcast_src_ip=192.168.1.12</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.1.10 dev ens33</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        chkhaproxy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上配置中请注意几个关键点：</p><ul><li>注意 haproxy 状态检查的脚本的位置，根据自己创建文件的位置不一样，脚本检查的指定位置也不一样；</li><li>注意优先级，MASTER节点的优先级一定要高于所有的BACKUP节点；</li><li>注意局域网的组播地址，一定要可用。局域网内所有keepalived节点都是利用组播方式寻找对方；</li><li>谁说BACKUP节点只能有一个！？</li><li>最后，keepalived一定要注册成服务形式，您可以想象上面所有脚本、配置、命令如果重启后再来一次，会是什么情况。</li></ul><p>接下来，我们要开始启动 Master 节点和 Backup 节点了，为了准确的查看日志状态，您需要观察系统日志。系统日志所在的位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/log/messages</span><br></pre></td></tr></table></figure></p><h3 id="启动keepalived"><a href="#启动keepalived" class="headerlink" title="启动keepalived"></a>启动keepalived</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# service keepalived start</span><br></pre></td></tr></table></figure><p>如果设置和启动都是成功的，您不会在日志信息中收到任何的keepalived报错信息。接下来您就可以使用192.168.1.10这个IP访问 haproxy了.</p><h3 id="验证Keepalived是否正常启动"><a href="#验证Keepalived是否正常启动" class="headerlink" title="验证Keepalived是否正常启动"></a>验证Keepalived是否正常启动</h3><p>在主备机环境中输入以下命令，查看当前系统网络配置信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether 08:00:27:07:f5:db brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.1.11/24 brd 192.168.16.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 192.168.1.10/24 scope global secondary eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::a00:27ff:fe07:f5db/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure></p><p>可以发现eth0下多了inet 192.168.1.10/24，表明keepalived已正常工作。</p><h5 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h5><ol><li><a href="http://valleylord.github.io/post/201603-mycat-haproxy/" target="_blank" rel="noopener">http://valleylord.github.io/post/201603-mycat-haproxy/</a></li><li><a href="http://www.itpux.com/thread-4668-1-1.html" target="_blank" rel="noopener">http://www.itpux.com/thread-4668-1-1.html</a></li><li><a href="https://blog.csdn.net/u012758088/article/details/78651964" target="_blank" rel="noopener">https://blog.csdn.net/u012758088/article/details/78651964</a></li><li><a href="http://kingleema.com/2015/11/14/setup-keepalived-on-ubuntu-server/" target="_blank" rel="noopener">http://kingleema.com/2015/11/14/setup-keepalived-on-ubuntu-server/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;keepalived-安装&quot;&gt;&lt;a href=&quot;#keepalived-安装&quot; class=&quot;headerlink&quot; title=&quot;keepalived 安装&quot;&gt;&lt;/a&gt;keepalived 安装&lt;/h2&gt;&lt;p&gt;直接通过apt-get方式安装最简单&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@bogon /]# apt-get install libssl-dev openssl libpopt-dev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@bogon /]# apt-get install -y keepalived&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@bogon /]# keepalived -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@bogon /]# Keepalived v1.2.13 (08/03,2017)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;编写-Haproxy-状态监测&quot;&gt;&lt;a href=&quot;#编写-Haproxy-状态监测&quot; class=&quot;headerlink&quot; title=&quot;编写 Haproxy 状态监测&quot;&gt;&lt;/a&gt;编写 Haproxy 状态监测&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@bogon /]# vim /etc/keepalived/check_haproxy.sh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#!/bin/sh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if [ $(ps -C haproxy --no-header | wc -l) -eq 0 ]; then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /home/dxy/haproxy/sbin/haproxy -f /home/dxy/haproxy/conf/haproxy.cfg&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sleep 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if [ $(ps -C haproxy --no-header | wc -l) -eq 0 ]; then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    killall keepalived&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fi&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="分库分表" scheme="http://ppjys.cn/categories/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
    
      <category term="mycat" scheme="http://ppjys.cn/tags/mycat/"/>
    
  </entry>
  
  <entry>
    <title>Mycat运维部署文档</title>
    <link href="http://ppjys.cn/2018/05/01/Mycat%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/"/>
    <id>http://ppjys.cn/2018/05/01/Mycat运维部署文档/</id>
    <published>2018-05-01T02:07:35.000Z</published>
    <updated>2018-07-13T13:11:41.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul><li>JDK 下载，至少JDK1.7版本及以上<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html</a></li><li>MySQL 下载<br><a href="http://dev.mysql.com/downloads/mysql/5.5.html#downloads" target="_blank" rel="noopener">http://dev.mysql.com/downloads/mysql/5.5.html#downloads</a><blockquote><p>注:MyCAT 支持多种数据库接入，如:MySQL、SQLServer、Oracle、MongoDB 等，推荐使用MySQL 做集群。</p></blockquote></li></ul><h2 id="安装与部署"><a href="#安装与部署" class="headerlink" title="安装与部署"></a>安装与部署</h2><p>平台组有提供编译好的安装包，支持 windows、Linux、Mac、Solaris 等系统上安装与运行。<br>解压安装包建议放在 /usr/local/Mycat 目录下，创建mycat用户，改变目录权限为mycat<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar zxf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz</span><br><span class="line">$ useradd mycat</span><br><span class="line">$ chown -R mycat.mycat /usr/local/mycat</span><br></pre></td></tr></table></figure></p><h3 id="mysql设置"><a href="#mysql设置" class="headerlink" title="mysql设置"></a>mysql设置</h3><p>通过部署发现在Mycat中部署逻辑表表名大小写混合时，在Mycat连接后出现全变小，所以需要修改mysql不忽略表名大小写，需要手动到/etc/my.cnf 下配置 </p><blockquote><p>lower_case_table_names=1</p></blockquote><h3 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/profile</span><br><span class="line">MYCAT_HOME=/usr/local/mycat</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="jdk设置"><a href="#jdk设置" class="headerlink" title="jdk设置"></a>jdk设置</h3><p>启动前，需修改java的命令配置，打开conf/wrapper.conf文件，修改wrapper.java.command项，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Java Application</span><br><span class="line">wrapper.java.command=/opt/java8/bin/java</span><br><span class="line">wrapper.working.dir=..</span><br></pre></td></tr></table></figure></p><h3 id="内存设置"><a href="#内存设置" class="headerlink" title="内存设置"></a>内存设置</h3><p>启动前，一般需要修改JVM配置参数，打开conf/wrapper.conf文件，如下行的内容为2G和2048，可根据本机配置情况修改为512M或其它值。 以下配置跟jvm参数完全一致，可以根据自己的jvm参数调整<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Java Additional Parameters</span><br><span class="line">wrapper.java.additional.1=</span><br><span class="line">wrapper.java.additional.1=-DMYCAT_HOME=.</span><br><span class="line">wrapper.java.additional.2=-server</span><br><span class="line">wrapper.java.additional.3=-XX:MaxPermSize=512M #JVM最大允许分配的非堆内存</span><br><span class="line">wrapper.java.additional.4=-XX:+AggressiveOpts</span><br><span class="line">wrapper.java.additional.5=-XX:MaxDirectMemorySize=100m</span><br><span class="line">wrapper.java.additional.6=-Dcom.sun.management.jmxremote</span><br><span class="line">wrapper.java.additional.7=-Dcom.sun.management.jmxremote.port=1984</span><br><span class="line">wrapper.java.additional.8=-Dcom.sun.management.jmxremote.authenticate=false</span><br><span class="line">wrapper.java.additional.9=-Dcom.sun.management.jmxremote.ssl=false</span><br><span class="line">wrapper.java.additional.10=-Xmx2048m #VM最大允许分配的堆内存</span><br><span class="line">wrapper.java.additional.11=-Xms2048m #JVM初始分配的堆内存</span><br><span class="line">wrapper.java.additional.12=-XX:+UseParNewGC #设置新生代使用并发收集器</span><br><span class="line">wrapper.java.additional.13=-XX:+UseConcMarkSweepGC #设置JVM堆的老年代使用CMS并发收集器</span><br><span class="line">wrapper.java.additional.14=-XX:+UseCMSCompactAtFullCollection #打开对老年代的压缩</span><br><span class="line">wrapper.java.additional.15=-XX:CMSFullGCsBeforeCompaction=5 #设置5才CMSGC后对堆空间进行压缩、整理</span><br></pre></td></tr></table></figure></p><h3 id="Zookeeper配置"><a href="#Zookeeper配置" class="headerlink" title="Zookeeper配置"></a>Zookeeper配置</h3><p>由于mycat多实例运行，需要统一的配置中心，官方建议将配置文件基于zk部署。</p><ol><li><p>修改conf下的myid.properities</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim myid.properties</span><br><span class="line"></span><br><span class="line">loadZk=true</span><br><span class="line"># zk集群地址，多个用&quot;,&quot;隔开</span><br><span class="line">zkURL=127.0.0.1:2181</span><br><span class="line"># zk集群内Mycat集群ID</span><br><span class="line">clusterId=dxy-ucloud-mycat-cluster</span><br><span class="line"># Mycat集群内本实例ID，禁止重复</span><br><span class="line">myid=ucloud_mycat_01</span><br><span class="line"># Mycat集群内节点个数</span><br><span class="line">clusterSize=2</span><br><span class="line">clusterNodes=ucloud_mycat_01,ucloud_mycat_02</span><br><span class="line">#server  booster  ;   booster install on db same server,will reset all minCon to 1</span><br><span class="line">type=server</span><br><span class="line">boosterDataHosts=dataHost1</span><br></pre></td></tr></table></figure></li><li><p>初始化zk数据。<strong>注意：zk配置文件统一需要在zkconf目录下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh $mycat_home/bin/init_zk_data.sh</span><br></pre></td></tr></table></figure></li></ol><h3 id="启动MycatServer"><a href="#启动MycatServer" class="headerlink" title="启动MycatServer"></a>启动MycatServer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/mycat/bin/mycat start</span><br></pre></td></tr></table></figure><p>注:mycat 支持的命令{ console | start | stop | restart | status | dump }</p><h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><h3 id="mysql配置调整，编辑-etc-my-cnf添加"><a href="#mysql配置调整，编辑-etc-my-cnf添加" class="headerlink" title="mysql配置调整，编辑/etc/my.cnf添加"></a>mysql配置调整，编辑/etc/my.cnf添加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqldump]</span><br><span class="line">max_allowed_packet      = 16M</span><br><span class="line">#default-character-set   = utf8mb4</span><br></pre></td></tr></table></figure><p>mysqldump导入报ERROR 1153 (08S01) at line 1133809: Got a packet bigger than ‘max_allowed_packet’ bytes错误，因为MySQL允许的默认大小为1MB。</p><h3 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h3><p>注意，Mycat在执行INSERT语句时需要完整INSERT语句(用列名)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p -c --skip-add-locks --skip-extended-insert --no-autocommit databaseName &gt; databaseName.sql</span><br><span class="line"># -c                     参数不可少，-c, 全称为–complete-insert 表示使用完整的 insert 语句(用列名字)。</span><br><span class="line"># --skip-add-locks       表示导数据时不加锁，如果加锁涉及多分片时容易导致死锁。</span><br><span class="line"># --skip-extended-insert 将每行数据输出为一个单独的insert语句</span><br><span class="line"># --no-autocommit        参数在每个表格所有的插入语句的前后分别增加SET autocommit = 0和COMMIT语句。相比没有这个参数，插入速度能差出至少200倍，分别是10000QPS和50QPS</span><br></pre></td></tr></table></figure></p><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -ptest -h192.168.99.216 -P8006 TESTDB #连接Mycat</span><br><span class="line">source /databaseName.sql #导入数据</span><br></pre></td></tr></table></figure><p>成功后可以在分片已经存入数据。错误日志在 logs/mycat.log文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接Mycat select * from table 时，Mycat默认limit 100此配置可从schema.xml文件中修改sqlMaxLimit=&quot;100&quot;定义</span><br></pre></td></tr></table></figure></p><h3 id="验证迁移数据完整性"><a href="#验证迁移数据完整性" class="headerlink" title="验证迁移数据完整性"></a>验证迁移数据完整性</h3><p>查询所有表的主键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT k.column_name,k.table_name FROM information_schema.table_constraints t JOIN information_schema.key_column_usage k USING (constraint_name,table_schema,table_name) WHERE t.constraint_type=&apos;PRIMARY KEY&apos;   AND t.table_schema=&apos;数据库&apos;;</span><br></pre></td></tr></table></figure></p><p>查询所有表的记录数(行数)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select table_name,table_rows from information_schema.tables  where TABLE_SCHEMA = &apos;数据库&apos;  order by table_rows desc;</span><br><span class="line">#对于InnoDB表，table_rows行计数仅是大概估计值。</span><br></pre></td></tr></table></figure></p><h2 id="Mycat-web监控"><a href="#Mycat-web监控" class="headerlink" title="Mycat-web监控"></a>Mycat-web监控</h2><p>Mycat-web 是对mycat-server提供监控服务。功能不局限于对mycat-server使用。他基于jmx对所有JVM监控。通过JDBC连接对Mycat、Mysql 监控。基于snmp协议，监控远程服务器(目前仅限于linux系统)的cpu、内存、网络、磁盘。Mycat-web 最近改名 Mycat-eye。</p><p>Mycat-eye 运行过程中需要依赖 zookeeper，因此需要先安装 zookeeper。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf Mycat-web-1.0-SNAPSHOT-20160331220346-linux.tar.gz -C /usr/local/ </span><br><span class="line">修改zookeeper地址： </span><br><span class="line">cd /usr/local/mycat-web/mycat-web/WEB-INF/classes </span><br><span class="line">vim mycat.properties </span><br><span class="line">zookeeper=127.0.0.1:2181</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>先启动zookeeper,在启动mycat-web<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@oracle_standby mycat-web]# netstat -ntpl |grep 8082 </span><br><span class="line">tcp 0 0 :::8082 :::* LISTEN 18288/java </span><br><span class="line">[root@oracle_standby mycat-web]# </span><br><span class="line">[root@oracle_standby mycat-web]# netstat -ntpl |grep 2181 </span><br><span class="line">tcp 0 0 :::2181 :::* LISTEN 18251/java</span><br></pre></td></tr></table></figure></p><h3 id="监控平台"><a href="#监控平台" class="headerlink" title="监控平台"></a>监控平台</h3><p><a href="http://127.0.0.1:8082/mycat/" target="_blank" rel="noopener">http://127.0.0.1:8082/mycat/</a></p><p><img width="500px" src="http://valleylord.github.io/images/201604-mycat-web-install/mycat-web1.png"></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>部署完成，web监控中始终没有数据。是没有开启mycat server.xml中的useSqlStat属性。开启之后，可以监控sql.</li><li>监控sql 反应很慢，一般执行sql2分钟之后，监控页面才有反应。</li></ul><h2 id="Keepalive-Haproxy高可用配置"><a href="#Keepalive-Haproxy高可用配置" class="headerlink" title="Keepalive+Haproxy高可用配置"></a>Keepalive+Haproxy高可用配置</h2><p>Mycat 作为一个代理层中间件，Mycat 系统的高可用涉及到 Mycat 本身的高可用以及后端 MySQL 的高可用，在 大多数情况下，建议采用标准的 MySQL 主从复制高可用性配置并交付给 Mycat 来完成后端 MySQL 节点的主从 自动切换。<br>一种常见的做法是使用 MyCAT + Haproxy + Keepalived，这中做法在 mysql 集群中已经很常见了。对于 MyCAT 集群,其大致架构图如下</p><p><img width="500px;" src="http://valleylord.github.io/images/201603-mycat-haproxy/mycat-haproxy-architect.png"></p><p>配置详情请参考 <a href="https://note.youdao.com/" target="_blank" rel="noopener">Mycat部署文档之Keepalived</a> 、 <a href="https://note.youdao.com/" target="_blank" rel="noopener">Mycat部署文档之Haproxy</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>由于公司生产环境存在多个机房，是否存在跨机房调用？<strong><em>答：确实存在多个机房，但是不存在跨机房调用。</em></strong></li><li>目前mycat官方版本提供的schema.xml和rule.xml配置文件不能import多个文件，是否存在业务团队由于配置出错导致整体服务不可用问题？<strong><em>答：中间件团队将会对配置文件进行改造，支持include语法。</em></strong></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JDK 下载，至少JDK1.7版本及以上&lt;br&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MySQL 下载&lt;br&gt;&lt;a href=&quot;http://dev.mysql.com/downloads/mysql/5.5.html#downloads&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dev.mysql.com/downloads/mysql/5.5.html#downloads&lt;/a&gt;&lt;blockquote&gt;
&lt;p&gt;注:MyCAT 支持多种数据库接入，如:MySQL、SQLServer、Oracle、MongoDB 等，推荐使用MySQL 做集群。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;安装与部署&quot;&gt;&lt;a href=&quot;#安装与部署&quot; class=&quot;headerlink&quot; title=&quot;安装与部署&quot;&gt;&lt;/a&gt;安装与部署&lt;/h2&gt;&lt;p&gt;平台组有提供编译好的安装包，支持 windows、Linux、Mac、Solaris 等系统上安装与运行。&lt;br&gt;解压安装包建议放在 /usr/local/Mycat 目录下，创建mycat用户，改变目录权限为mycat&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ tar zxf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ useradd mycat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ chown -R mycat.mycat /usr/local/mycat&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;mysql设置&quot;&gt;&lt;a href=&quot;#mysql设置&quot; class=&quot;headerlink&quot; title=&quot;mysql设置&quot;&gt;&lt;/a&gt;mysql设置&lt;/h3&gt;&lt;p&gt;通过部署发现在Mycat中部署逻辑表表名大小写混合时，在Mycat连接后出现全变小，所以需要修改mysql不忽略表名大小写，需要手动到/etc/my.cnf 下配置 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;lower_case_table_names=1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;环境变量设置&quot;&gt;&lt;a href=&quot;#环境变量设置&quot; class=&quot;headerlink&quot; title=&quot;环境变量设置&quot;&gt;&lt;/a&gt;环境变量设置&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ vim /etc/profile&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MYCAT_HOME=/usr/local/mycat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;source /etc/profile&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="分库分表" scheme="http://ppjys.cn/categories/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
    
      <category term="mycat" scheme="http://ppjys.cn/tags/mycat/"/>
    
  </entry>
  
  <entry>
    <title>分库分表方案对比</title>
    <link href="http://ppjys.cn/2018/04/26/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94/"/>
    <id>http://ppjys.cn/2018/04/26/分库分表方案对比/</id>
    <published>2018-04-26T02:07:35.000Z</published>
    <updated>2018-07-03T15:18:23.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>目前公司业务高速发展，各种业务数据呈井喷的态势，单表数据量急剧膨胀，随之而来是单表读写性能和吞吐量呈下降趋势而且无法应对业务高速增长产生的数据。因此需要使用分库分表机制保证高性能同时支撑和驱动业务发展，选择一款功能强大支持分库分表的中间件就成为当务之急。开源的数据库中间件众多，需要从中挑选一个适合的，并能作为映客长期演进的中间件，因此需要从多个维度对中间件进行相关测试</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>针对数据量过大出现的性能问题，通过分库分表将数据量保持在阀值以下，可以有效分散高并发量和缓解大数据量。分库分表一般分垂直拆分和水平拆分，根据业务将单库（表）拆分为多库（表），常用的字段和不常用的字段拆分至不同的库（表）中，可适当缓解并发量和数据量，但不能根治；垂直拆分之后依然超过单节点所能承载的阈值，则需要水平拆分来进一步处理。 水平拆分则是根据分片算法将一个库（表）拆分为多个库（表）。</p><p>分表虽然可以解决海量数据导致的性能问题，但无法解决过多请求访问同一数据库，导致其响应变慢的问题。所以水平拆分通常要采取分库的方式(合理的配合使用分库+分表)，一并解决数据量和访问量巨大的问题。</p><h1 id="产品调研"><a href="#产品调研" class="headerlink" title="产品调研"></a>产品调研</h1><p>调研分析后Mycat和Sharding-jdbc功能上比较稳定成熟，支持分库分表、读写分离、分布式主键、柔性事务等。</p><p>Sharding-jdbc：类似TDDL，基于JDBC协议的数据库中间件产品，使用客户端直连数据库，以jar包形式提供服务，兼容JDBC和各种ORM框架，使系统在数据访问层直接具有分片化和分布式治理的能力。</p><ul><li>轻量级框架， 直接封装的jdbc协议，jar包形式提供服务，旧代码迁移、新代码开发成本低</li><li>无需额外部署和依赖，客户端直连数据库，无需二次转发，性能高</li><li>运维层面不改动，无需关注中间件本身的 HA</li></ul><h2 id="mycat"><a href="#mycat" class="headerlink" title="mycat"></a>mycat</h2><p>基于阿里开源的Cobar研发，对代码进行了彻底重构，使用NIO重构了网络模块，并优化了Buffer内核，增强了聚合，Join等基本特性.主要原理是拦截用户发送过来的SQL语句，对SQL语句做了特定的分析：如分<br>片分析、路由分析、读写分离分析、缓存分析等，然后将此SQL发往后端的真实数据库，并将返回的结果做适当的处理，最后返回给用户。</p><ul><li>可以负责更多的内容，将数据迁移，分布式事务等纳入 Proxy 的范畴</li><li>针对mycat和mysql有较全性能监控项统计支持</li><li>可结合Storm等分布式实时流引擎，实现数据分析和数据聚合</li></ul><a id="more"></a><h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>本次对比不是对MySQL数据库进行极限或压力性能测试，而是在同等软硬件环境下对选取的数据库中间件在软件/物理架构、功能特性、扩展性、SQL支持程度、容灾/容错、可用性、可维护性、接入成本等进行综合衡量。</p><table><thead><tr><th>对比点</th><th>mycat</th><th>sharding-jdbc</th><th>Tidb-分布式数据库</th></tr></thead><tbody><tr><td>分库分表</td><td>支持</td><td>支持</td><td>支持</td><td></td></tr><tr><td>分布式事物</td><td>弱XA</td><td>弱XA</td><td>完全ACID</td><td></td></tr><tr><td>复杂聚合查询</td><td>较弱（支持单库内部任意join，支持跨库2表join）</td><td>支持（聚合，分组，排序，分页，OR，关联查询）</td><td>支持</td><td></td></tr><tr><td>主键</td><td>时间戳、数据库、zk</td><td>雪花算法</td><td>区间分段（可能出现重复主键）</td><td></td></tr><tr><td>分片规则</td><td>已支持较多分片，可自定义</td><td>已支持较多分片，可自定义</td><td>内部实现机制，无需业务制定</td><td></td></tr><tr><td>支持数据库</td><td>mysql、nosql(monogdb)</td><td>mysql</td><td>本身就是数据库</td><td></td></tr><tr><td>HA</td><td>haproxy+keeplive</td><td>无</td><td>水平扩展+高可用</td><td></td></tr><tr><td>语言</td><td>java</td><td>java</td><td>go</td><td></td></tr><tr><td>可维护性</td><td>较高（提供管控台）</td><td>较高</td><td>低（虽然提供管控台，但是由于开发语言限制与团队技术栈不一致）</td><td></td></tr><tr><td>接入成本</td><td>低</td><td>较高(业务方需配合)</td><td>高(业务数据需要全部迁移tidb)</td><td></td></tr><tr><td>优点</td><td>有效解决了数据库链接数多的问题，因为各工程应用只连接中间件，中间件代理了真实的物理链接，并且与后端mysql物理链接是复用型的所有的分库分表等规则集中配置在中间件上，更可控</td><td>性能高</td><td>产品较新</td><td></td></tr><tr><td>缺点</td><td>计算过程只能单节点计算，单机扩展只能调优，但是集群可以做负载均衡；相对sharding-jdbc来说，由于增加一层中间代理，性能稍微降低；需要保证中间件的可用性，会增加运维成本及复杂度；</td><td>业务工程里各自配置多数据源（主、从），不能做到统一数据库连接管理，分片规则需要hard code到业务代码中</td><td>业务数据需要全部迁移，并且生产环境配置要求较高，不建议使用</td><td></td></tr></tbody></table><h1 id="分库分表后不支持的sql语法"><a href="#分库分表后不支持的sql语法" class="headerlink" title="分库分表后不支持的sql语法"></a>分库分表后不支持的sql语法</h1><ul><li>SELECT不支持的语法</li></ul><ol><li>不支持跨分片的交叉查询</li><li>跨节点的联合查询，不支持union all，union</li><li>sharding-jdbc不支持DISTINCT聚合,但是mycat支持</li><li>mycat支持跨库2张表的join（可通过Catlet实现多表join），sharding-jdbc支持多表join，由于内部实现复杂度和性能，不推荐使用join，最好由业务改造简单查询</li><li>mycat join支持</li></ol><ul><li>INSERT不支持的语法</li></ul><ol><li>插入的字段不包含分片字段 </li><li>插入的分片字段找不到对应分片</li><li>复制插入 insert into…select… </li><li>多行插入 insert into tab_a(c1,c2) values(v1,v2),(v11,v21)… </li></ol><ul><li>UPDATE不支持的语法</li></ul><ol><li>更新的列包含分片列</li><li>多表更新 update a, b set a.nation=’China’, b.pwd=’123456’ where a.id=b.id </li><li>复杂多表关联更新 update a, b set a.nation=’China’ where a.id=b.id; 但支持子查询方式 update a set a.nation=’China’ where id in (select id from b);</li></ol><ul><li>DELETE不支持语法</li></ul><ol><li>复杂删除sql delete a from a join b on a.id=b.id;  支持子查询方式 delete from a where a.id in (select id from b), 但表不能起别名</li></ol><ul><li>其他</li></ul><ol><li>Call procedure()   MyCat未支持存储过程定义, 因而不允许调用存储过程，但可通过注解来调用各个分片上的存储过程</li><li>Select func(); 不支持这种方式直接调用自定义函数， 但支持 select id, func() from employee 只需employee所在的所有分片上存在这个函数。MySql自带函数可随意使用。</li></ol><h1 id="mycat-使用教程"><a href="#mycat-使用教程" class="headerlink" title="mycat 使用教程"></a>mycat 使用教程</h1><p>mycat分库分表规则主要是修改server.xml、schema.xml和rule.xml。</p><ul><li>server.xml：是Mycat服务器参数调整和用户授权的配置文件。</li><li>schema.xml：是逻辑库定义和表以及分片定义的配置文件。</li><li>rule.xml：是分片规则的配置文件，分片规则的具体一些参数信息单独存放为文件，也在这个目录下，配置文件修改需要重启MyCAT。</li></ul><ol><li><p>mycat服务端server.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:server</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">system</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"nonePasswordLogin"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1为开启实时统计、0为关闭 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useSqlStat"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1为开启全加班一致性检测、0为关闭 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useGlobleTableCheck"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用来指定Mycat全局序列类型，0为本地文件，1为数据库方式，2为时间戳列方式，默认使用本地文件方式，文件方式主要用于测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sequnceHandlerType"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--默认为type 0: DirectByteBufferPool | type 1 ByteBufferArena--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"processorBufferPoolType"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--分布式事务开关，0为不过滤分布式事务，1为过滤分布式事务（如果分布式事务内只涉及全局表，则不过滤），2为不过滤分布式事务,但是记录分布式事务日志--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"handleDistributedTransactions"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置是否启用非堆内存跨分片结果集，1为开启，0为关闭，mycat1.6开始支持该属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useOffHeapForMerge"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单位为m--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"memoryPageSize"</span>&gt;</span>64k<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单位为k--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"spillsFileBufferSize"</span>&gt;</span>1k<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useStreamOutput"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单位为m--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"systemReserveMemorySize"</span>&gt;</span>384m<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--是否采用zookeeper协调切换  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useZKSwitch"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义mycat使用的端口，默认值为8066 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"serverPort"</span>&gt;</span>3307<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义mycat管理的端口，默认值为9066 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"managerPort"</span>&gt;</span>9066<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义登录mycat对的用户权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"root"</span> <span class="attr">defaultAccount</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 若要访问TESTDB 必须现在server.xml 中定义，否则无法访问TESTDB--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>dbtest<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置是否允许只读 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"readOnly"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义限制前端整体的连接数，如果其值为0，或者不设置，则表示不限制连接数量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"benchmark"</span>&gt;</span>11111<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置是否开启密码加密功能，默认为0不开启加密，为1则表示开启加密 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usingDecrypt"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:server</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>分库分表schema.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- schema 定义mycat中的逻辑库，可以有多个逻辑库,</span></span><br><span class="line"><span class="comment">1）dataNode属性：绑定逻辑库到具体的Database上面，</span></span><br><span class="line"><span class="comment">2）checkSQLschema：如果为true，则会替换掉schema，如果为false则不会；</span></span><br><span class="line"><span class="comment">3）sqlMaxLimit：如果带了该属性，则每次执行sql的时候如果sql没有limit则会带上这个limit，如果schema为非拆分库，则该属性不会生效。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"dbtest"</span> <span class="attr">checkSQLschema</span>=<span class="string">"true"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- table标签定义了MyCat中的逻辑表，所有拆分的表都需要在table标签中定义。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1）name属性：定义逻辑表的名称--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2）dataNode属性：定义逻辑表所属的dataNode，如果需要引用多个dataNode,则可以用dataNode="dn$0-99" 来代表dn0到dn99的数据库--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3）rule属性：用来指定逻辑表使用的规则名字，规则名字在rule.xml中定义。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4）ruleRequired属性：该属性用于指定表是否绑定分片规则，如果配置为true,但是没有具体的分片规则，则会报错。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 5）type属性：定义逻辑表的类型，分为"全局表（global）"和"普通表"两种类型,不设置该值的时候未global的所有表。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 6）autoIncrement属性：使用该值的时候需要定义auto_increment，使用的时候最好配合数据库模式的全局序列。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 7）subTables属性：dataNode在分表的条件下只能配置一个，不支持各种条件的Join关联查询。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 8）primaryKey属性:逻辑表对应真实表的主键。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 9）needAddLimit属性：指定表是否需要字段再每个语句的后面加上limit限制。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"travelrecord"</span> <span class="attr">dataNode</span>=<span class="string">"dn1,dn2"</span> <span class="attr">primaryKey</span>=<span class="string">"id"</span> <span class="attr">rule</span>=<span class="string">"rule1"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--childTable标签用于定义E-R分片的子表，通过标签上的属性与浮表进行关联--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1)name属性：定义子表的名称--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2）joinKey属性：插入子表时，回使用这个值查找浮表存贮的数据节点--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3）parentKey属性：与父表建立关联关系的列名，程序首先获取joinKey的值，然后通过parentKey属性指定的列名产生查询语句，通过执行语句得知父表存储在哪个分片上，从而确定子表存贮的位置。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4）primaryKey：和table标签一样--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 5）needAddLimit：和table标签一样--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- dataNode标签定义了mycat中的数据节点，这也就是我们通常所说的数据分片，一个单独的dataNode就是一个独立的数据分片--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1）name属性：定义数据节点的唯一名字--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--2）dataHost属性：定义该分片所属的数据库实例，属性引用自dataHost标签上定义的name属性--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3）database属性：定义该分片所属的数据库实例上的具体数据库。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn1"</span> <span class="attr">dataHost</span>=<span class="string">"localhost1"</span> <span class="attr">database</span>=<span class="string">"db01"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn2"</span> <span class="attr">dataHost</span>=<span class="string">"localhost1"</span> <span class="attr">database</span>=<span class="string">"db02"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义数据库实例，读写分离和心跳语句--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1)那么属性：标识唯一的dataHost,--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2)maxCon属性：指定每个读写实例连接池的最大连接数。内嵌writeHost、readHost标签会使用这个属性的值来实例化连接池的最大连接数--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3)minCon属性：指定每个读写实例连接池的最小连接数。初始化连接池的大小的属性。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--4）balance属性：负债均衡类型，有四种--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   balance="0" : 不开启读写分离机制，所有的读操作都发送到当前可以用的writeHost上--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   balance="1" : 全部的readHost与stand by writeHost（双主从模式下的master） 都参与select语句的负债均衡--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   balance="2" : 所有的读操作都随机的往writeHost和readHost上分发--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   balance="3" : 所有的读分发到readHost上，writeHost负责写--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--5）writeType属性：负载均衡目前的取值有两种：--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   writeType="0"：所有的写操作都发送到第一个writeHost,writeHost1挂了，则切换到writeHost2上，重新恢复writeHost1后，还是以writeHost2为准--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   writeType="1"：所有的写操作都随机的发送到配置的writeHost上，1.5版本以后不推荐使用该值。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--6）dbType属性：制定后端后端数据的类型：mysql，oracle、mongoDB--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--7）dbDriver属性：制定后端数据库使用的Driver.目前可选的值为native和JDBC。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--8）switchType属性：默认值为1，自动切换。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                  -1表示不自动切换--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                   2表示基于mysql主从同步的状态决定是否切换。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                  3表示基于mysql galaxy cluster 的切换机制--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--9）tempReadHostAvailable属性：如果配置了writeHost属性，下面的readHost依旧可以使用，默认为0--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"localhost1"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span> <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"127.0.0.1:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"123456"</span>&gt;</span> <span class="comment">&lt;!-- url、user、password 设置成你的数据库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>分库分表规则rule.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:rule</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name 属性指定唯一的名字，用于标识不同的表规则</span></span><br><span class="line"><span class="comment">     1）内嵌的 rule 标签则指定对物理表中的哪一列进行拆分和使用什么路由算法。</span></span><br><span class="line"><span class="comment">     2）columns 内指定要拆分的列名字。</span></span><br><span class="line"><span class="comment"> 3)algorithm 使用 function 标签中的 name 属性。连接表规则和具体路由算法。当然，多个表规则可以连接到同一个路由算法上。 table 标签内使用。让逻辑表使用这个规则进行分片。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"rule1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>func1<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--name 指定算法的名字。</span></span><br><span class="line"><span class="comment">1)class 制定路由算法具体的类名字。</span></span><br><span class="line"><span class="comment">2)property 为具体算法需要用到的一些属性。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"func1"</span> <span class="attr">class</span>=<span class="string">"io.mycat.route.function.PartitionByLong"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionCount"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionLength"</span>&gt;</span>512<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:rule</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="sharding-jdbc-使用教程"><a href="#sharding-jdbc-使用教程" class="headerlink" title="sharding-jdbc 使用教程"></a>sharding-jdbc 使用教程</h1><ol><li><p>maven依赖包</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.shardingsphere&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sharding-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;sharding-sphere.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.shardingsphere&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sharding-jdbc-spring-namespace&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;sharding-sphere.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>分库分表设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  按照 2库+2表分片 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 分库规则-按照user_id取模 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- inline-strategy 行表达式分片策略</span></span><br><span class="line"><span class="comment">  对应InlineShardingStrategy。使用Groovy的表达式，提供对SQL语句中的=和IN的分片操作支持，只支持单分片键。</span></span><br><span class="line"><span class="comment">  对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，</span></span><br><span class="line"><span class="comment">  如: t_user$&#123;u_id % 8&#125; 表示t_user表按照u_id按8取模分成8个表，表名称为t_user0到t_user7。</span></span><br><span class="line"><span class="comment">  1) sharding-column 分片列名称</span></span><br><span class="line"><span class="comment">  2) algorithm-expression 分片算法行表达式，需符合groovy语法</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sharding:inline-strategy</span> <span class="attr">id</span>=<span class="string">"databaseStrategy"</span> <span class="attr">sharding-column</span>=<span class="string">"user_id"</span> <span class="attr">algorithm-expression</span>=<span class="string">"sharding_$-&gt;&#123;user_id % 2&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sharding:inline-strategy</span> <span class="attr">id</span>=<span class="string">"userTableStrategy"</span> <span class="attr">sharding-column</span>=<span class="string">"age"</span> <span class="attr">algorithm-expression</span>=<span class="string">"t_user_$-&gt;&#123;age % 2&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- data-source 分片数据源</span></span><br><span class="line"><span class="comment">  1）sharding-rule data-source-names 原始数据源</span></span><br><span class="line"><span class="comment">  2）table-rules 数据表分片规则列表</span></span><br><span class="line"><span class="comment">  3）table-rule 数据表分片规则</span></span><br><span class="line"><span class="comment">  4）logic-table 逻辑表</span></span><br><span class="line"><span class="comment">  5）generate-key-column-name 分布式主键指定，默认使用雪花算法计算id</span></span><br><span class="line"><span class="comment">  6）actual-data-nodes 由数据源名 + 表名组成，以小数点分隔。多个表以逗号分隔，支持inline表达式。缺省表示使用已知数据源与逻辑表名称生成数据节点。用于广播表（即每个库中都需要一个同样的表用于关联查询，多为字典表）或只分库不分表且所有库的表结构完全一致的情况</span></span><br><span class="line"><span class="comment">  7）database-strategy-ref 默认数据库分片策略，对应&lt;sharding:xxx-strategy&gt;中的策略Id，缺省表示不分库</span></span><br><span class="line"><span class="comment">  8）table-strategy-ref 表分片策略，对应&lt;sharding:xxx-strategy&gt;中的策略Id，缺省表示使用&lt;sharding:sharding-rule /&gt;配置的默认表分片策略</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sharding:data-source</span> <span class="attr">id</span>=<span class="string">"shardingDataSource"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sharding:sharding-rule</span> <span class="attr">data-source-names</span>=<span class="string">"sharding_0,sharding_1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sharding:table-rules</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sharding:table-rule</span> <span class="attr">logic-table</span>=<span class="string">"t_user"</span>  <span class="attr">generate-key-column-name</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">                           <span class="attr">actual-data-nodes</span>=<span class="string">"sharding_$-&gt;&#123;0..1&#125;.t_user_$-&gt;&#123;0..1&#125;"</span> <span class="attr">database-strategy-ref</span>=<span class="string">"databaseStrategy"</span> <span class="attr">table-strategy-ref</span>=<span class="string">"userTableStrategy"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sharding:table-rules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">sharding:sharding-rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sharding:data-source</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;目前公司业务高速发展，各种业务数据呈井喷的态势，单表数据量急剧膨胀，随之而来是单表读写性能和吞吐量呈下降趋势而且无法应对业务高速增长产生的数据。因此需要使用分库分表机制保证高性能同时支撑和驱动业务发展，选择一款功能强大支持分库分表的中间件就成为当务之急。开源的数据库中间件众多，需要从中挑选一个适合的，并能作为映客长期演进的中间件，因此需要从多个维度对中间件进行相关测试&lt;/p&gt;
&lt;h1 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h1&gt;&lt;p&gt;针对数据量过大出现的性能问题，通过分库分表将数据量保持在阀值以下，可以有效分散高并发量和缓解大数据量。分库分表一般分垂直拆分和水平拆分，根据业务将单库（表）拆分为多库（表），常用的字段和不常用的字段拆分至不同的库（表）中，可适当缓解并发量和数据量，但不能根治；垂直拆分之后依然超过单节点所能承载的阈值，则需要水平拆分来进一步处理。 水平拆分则是根据分片算法将一个库（表）拆分为多个库（表）。&lt;/p&gt;
&lt;p&gt;分表虽然可以解决海量数据导致的性能问题，但无法解决过多请求访问同一数据库，导致其响应变慢的问题。所以水平拆分通常要采取分库的方式(合理的配合使用分库+分表)，一并解决数据量和访问量巨大的问题。&lt;/p&gt;
&lt;h1 id=&quot;产品调研&quot;&gt;&lt;a href=&quot;#产品调研&quot; class=&quot;headerlink&quot; title=&quot;产品调研&quot;&gt;&lt;/a&gt;产品调研&lt;/h1&gt;&lt;p&gt;调研分析后Mycat和Sharding-jdbc功能上比较稳定成熟，支持分库分表、读写分离、分布式主键、柔性事务等。&lt;/p&gt;
&lt;p&gt;Sharding-jdbc：类似TDDL，基于JDBC协议的数据库中间件产品，使用客户端直连数据库，以jar包形式提供服务，兼容JDBC和各种ORM框架，使系统在数据访问层直接具有分片化和分布式治理的能力。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轻量级框架， 直接封装的jdbc协议，jar包形式提供服务，旧代码迁移、新代码开发成本低&lt;/li&gt;
&lt;li&gt;无需额外部署和依赖，客户端直连数据库，无需二次转发，性能高&lt;/li&gt;
&lt;li&gt;运维层面不改动，无需关注中间件本身的 HA&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;mycat&quot;&gt;&lt;a href=&quot;#mycat&quot; class=&quot;headerlink&quot; title=&quot;mycat&quot;&gt;&lt;/a&gt;mycat&lt;/h2&gt;&lt;p&gt;基于阿里开源的Cobar研发，对代码进行了彻底重构，使用NIO重构了网络模块，并优化了Buffer内核，增强了聚合，Join等基本特性.主要原理是拦截用户发送过来的SQL语句，对SQL语句做了特定的分析：如分&lt;br&gt;片分析、路由分析、读写分离分析、缓存分析等，然后将此SQL发往后端的真实数据库，并将返回的结果做适当的处理，最后返回给用户。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以负责更多的内容，将数据迁移，分布式事务等纳入 Proxy 的范畴&lt;/li&gt;
&lt;li&gt;针对mycat和mysql有较全性能监控项统计支持&lt;/li&gt;
&lt;li&gt;可结合Storm等分布式实时流引擎，实现数据分析和数据聚合&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="分库分表" scheme="http://ppjys.cn/categories/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
    
      <category term="mycat" scheme="http://ppjys.cn/tags/mycat/"/>
    
      <category term="分库分表" scheme="http://ppjys.cn/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
      <category term="sharding-jdbc" scheme="http://ppjys.cn/tags/sharding-jdbc/"/>
    
  </entry>
  
  <entry>
    <title>otter</title>
    <link href="http://ppjys.cn/2018/04/24/otter%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/"/>
    <id>http://ppjys.cn/2018/04/24/otter基础介绍/</id>
    <published>2018-04-24T02:07:35.000Z</published>
    <updated>2018-07-03T15:19:39.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote><p>***公司系统间的数据同步通过http接口通信，这种方式会导致数据同步高峰期间nginx的负载流量增加，从而影响业务流量。其二就是http方式的不稳定性，会导致一些数据不一致的问题。针对这个现象，目前提出2中解决方式，第一种可以通过高可用消息队列来进行解耦，第二种通过数据库底层binlog来监听数据变化。</p></blockquote><h2 id="otter介绍"><a href="#otter介绍" class="headerlink" title="otter介绍"></a>otter介绍</h2><blockquote><p>otter为阿里的一款增量数据同步工具，基于数据库增量日志解析，准实时同步到本机房或异地机房的mysql/oracle数据库.一个分布式数据库同步系统。</p></blockquote><h2 id="otter工作原理"><a href="#otter工作原理" class="headerlink" title="otter工作原理"></a>otter工作原理</h2><p><img width="848" src="https://camo.githubusercontent.com/2988fbbc7ddfe94ed027cd71720b1ffa5912a635/687474703a2f2f646c322e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038382f313138392f64343230636131342d326438302d336435352d383038312d6239303833363036613830312e6a7067" height="303" alt=""></p><p>原理描述：</p><ol><li>基于Canal开源产品，获取数据库增量日志数据。</li><li>典型管理系统架构，manager(web管理)+node(工作节点).manager运行时推送同步配置到node节点.node节点将同步状态反馈到manager上.</li><li>基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作.</li></ol><h2 id="Otter目前支持了什么"><a href="#Otter目前支持了什么" class="headerlink" title="Otter目前支持了什么"></a>Otter目前支持了什么</h2><ol><li>单向同步， mysql/oracle互相同步</li><li>双向同步，无冲突变更</li><li>文件同步，本地/aranda文件</li><li>双A同步，冲突检测&amp;冲突补救</li><li>数据迁移，中间表/行记录同步<blockquote><p>典型的场景是账户信息表和账户交易明细表，更新账户余额后需要登记一条账户明细，并且保证在一个事务里，用户可以通过交易明细表查看交易记录，但是交易明细表的数据量是逐步递增的，用户量多的系统，几个月下来的数据超过千万了，表数据量一多就导致查询和插入变慢，而一开始就对账户明细做分表处理就难于保证强一致性事务，通过otter可以将记录同步导历史表，并且进行分表处理，用户往年的交易记录就可以查询历史表了，而原交易明细表就可以删除一个月甚至几天前的数据；</p></blockquote></li></ol><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>otter manager依赖于mysql进行配置信息的存储，所以需要预先安装mysql，并初始化otter <a href="https://raw.github.com/alibaba/otter/master/manager/deployer/src/main/resources/sql/otter-manager-schema.sql" target="_blank" rel="noopener">manager的系统表结构</a>。</li><li>整个otter架构依赖了zookeeper进行多节点调度，所以需要预先安装zookeeper，不需要初始化节点，otter程序启动后会自检.</li><li>安装jdk1.6+<blockquote><p>官方文档：<a href="https://github.com/alibaba/otter/wiki/Manager_Quickstart" target="_blank" rel="noopener">https://github.com/alibaba/otter/wiki/Manager_Quickstart</a><br><a href="https://github.com/alibaba/otter/wiki/Node_Quickstart" target="_blank" rel="noopener">https://github.com/alibaba/otter/wiki/Node_Quickstart</a></p></blockquote></li></ol><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ol><li>Channel：同步通道，单向同步中一个Pipeline组成，在双向同步中有两个Pipeline组成；Pipeline：从源端到目标端的整个过程描述，主要由一些同步映射过程组成；</li><li>DataMediaPair：根据业务表定义映射关系，比如源表和目标表，字段映射，字段组等；</li><li>DataMedia:抽象的数据介质概念，可以理解为数据表/mq队列定义；</li><li>DataMediaSource: 抽象的数据介质源信息，补充描述DateMedia；</li><li>ColumnPair: 定义字段映射关系；</li><li>ColumnGroup: 定义字段映射组；</li><li>Node: 处理同步过程的工作节点，对应一个jvm；</li></ol><h2 id="采坑问题"><a href="#采坑问题" class="headerlink" title="采坑问题"></a>采坑问题</h2><ol><li>mysql需要开启binlog,并且binlog的模式一定要Row。</li><li>mysql5.6版本需要binlog_checksum设置为none，默认开始crc校验。</li><li>mysql mater节点需要设置server-id，server-id需要和manager上配置的node的id一致。错误内容如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pid:1 nid:1 exception:canal:源数据库cancal:java.io.IOException: Received error packet: errno = 1236, sqlstate = HY000 errmsg = Misconfigured master - server_id was not set</span><br><span class="line">    at com.alibaba.otter.canal.parse.inbound.mysql.dbsync.DirectLogFetcher.fetch(DirectLogFetcher.java:105)</span><br><span class="line">    at com.alibaba.otter.canal.parse.inbound.mysql.MysqlConnection.dump(MysqlConnection.java:146)</span><br><span class="line">    at com.alibaba.otter.canal.parse.inbound.AbstractEventParser$3.run(AbstractEventParser.java:227)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/alibaba/otter/wiki" target="_blank" rel="noopener">https://github.com/alibaba/otter/wiki</a></li><li><a href="https://github.com/alibaba/otter/wiki/Faq" target="_blank" rel="noopener">https://github.com/alibaba/otter/wiki/Faq</a></li><li><a href="https://blog.csdn.net/wudufeng/article/details/78688240" target="_blank" rel="noopener">https://blog.csdn.net/wudufeng/article/details/78688240</a></li><li><a href="https://yq.aliyun.com/articles/223077?utm_content=m_32233" target="_blank" rel="noopener">https://yq.aliyun.com/articles/223077?utm_content=m_32233</a></li><li><a href="https://my.oschina.net/u/860872/blog/1609715" target="_blank" rel="noopener">https://my.oschina.net/u/860872/blog/1609715</a></li><li><a href="https://www.cnblogs.com/findumars/p/6294542.html" target="_blank" rel="noopener">https://www.cnblogs.com/findumars/p/6294542.html</a></li><li>mysql binlog优化<br><a href="https://www.cnblogs.com/doseoer/p/6132454.html" target="_blank" rel="noopener">https://www.cnblogs.com/doseoer/p/6132454.html</a></li><li>binlog采坑 <a href="https://www.cnblogs.com/276815076/p/7993712.html" target="_blank" rel="noopener">https://www.cnblogs.com/276815076/p/7993712.html</a></li><li><a href="https://yq.aliyun.com/articles/223077?utm_content=m_32233" target="_blank" rel="noopener">https://yq.aliyun.com/articles/223077?utm_content=m_32233</a></li><li><a href="https://blog.csdn.net/wudufeng/article/details/78688240" target="_blank" rel="noopener">https://blog.csdn.net/wudufeng/article/details/78688240</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;***公司系统间的数据同步通过http接口通信，这种方式会导致数据同步高峰期间nginx的负载流量增加，从而影响业务流量。其二就是http方式的不稳定性，会导致一些数据不一致的问题。针对这个现象，目前提出2中解决方式，第一种可以通过高可用消息队列来进行解耦，第二种通过数据库底层binlog来监听数据变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;otter介绍&quot;&gt;&lt;a href=&quot;#otter介绍&quot; class=&quot;headerlink&quot; title=&quot;otter介绍&quot;&gt;&lt;/a&gt;otter介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;otter为阿里的一款增量数据同步工具，基于数据库增量日志解析，准实时同步到本机房或异地机房的mysql/oracle数据库.一个分布式数据库同步系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;otter工作原理&quot;&gt;&lt;a href=&quot;#otter工作原理&quot; class=&quot;headerlink&quot; title=&quot;otter工作原理&quot;&gt;&lt;/a&gt;otter工作原理&lt;/h2&gt;&lt;p&gt;&lt;img width=&quot;848&quot; src=&quot;https://camo.githubusercontent.com/2988fbbc7ddfe94ed027cd71720b1ffa5912a635/687474703a2f2f646c322e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038382f313138392f64343230636131342d326438302d336435352d383038312d6239303833363036613830312e6a7067&quot; height=&quot;303&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;原理描述：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于Canal开源产品，获取数据库增量日志数据。&lt;/li&gt;
&lt;li&gt;典型管理系统架构，manager(web管理)+node(工作节点).manager运行时推送同步配置到node节点.node节点将同步状态反馈到manager上.&lt;/li&gt;
&lt;li&gt;基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Otter目前支持了什么&quot;&gt;&lt;a href=&quot;#Otter目前支持了什么&quot; class=&quot;headerlink&quot; title=&quot;Otter目前支持了什么&quot;&gt;&lt;/a&gt;Otter目前支持了什么&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;单向同步， mysql/oracle互相同步&lt;/li&gt;
&lt;li&gt;双向同步，无冲突变更&lt;/li&gt;
&lt;li&gt;文件同步，本地/aranda文件&lt;/li&gt;
&lt;li&gt;双A同步，冲突检测&amp;amp;冲突补救&lt;/li&gt;
&lt;li&gt;数据迁移，中间表/行记录同步&lt;blockquote&gt;
&lt;p&gt;典型的场景是账户信息表和账户交易明细表，更新账户余额后需要登记一条账户明细，并且保证在一个事务里，用户可以通过交易明细表查看交易记录，但是交易明细表的数据量是逐步递增的，用户量多的系统，几个月下来的数据超过千万了，表数据量一多就导致查询和插入变慢，而一开始就对账户明细做分表处理就难于保证强一致性事务，通过otter可以将记录同步导历史表，并且进行分表处理，用户往年的交易记录就可以查询历史表了，而原交易明细表就可以删除一个月甚至几天前的数据；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="中间件" scheme="http://ppjys.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="otter" scheme="http://ppjys.cn/tags/otter/"/>
    
  </entry>
  
  <entry>
    <title>docker 基础命令</title>
    <link href="http://ppjys.cn/2018/04/23/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <id>http://ppjys.cn/2018/04/23/docker基础命令/</id>
    <published>2018-04-23T02:07:35.000Z</published>
    <updated>2018-07-03T15:20:07.570Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>拉取镜像</p><blockquote><p>docker pull daocloud.io/library/mysql:5.6</p></blockquote></li><li><p>创建容器</p><blockquote><p>docker run -p 3306:3306 –name mysql -v /Users/peijiepang/Documents/docker/mysql/conf:/etc/mysql -v /Users/peijiepang/Documents/docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d daocloud.io/library/mysql:5.6</p></blockquote></li><li><p>获取所有的容器id</p><blockquote><p>docker ps -a</p></blockquote></li><li><p>启动容器</p><blockquote><p>docker start 578fcc293e25</p></blockquote></li><li><p>查看当前启动的容器</p><blockquote><p>docker ps</p></blockquote></li><li><p>进去容器内部系统</p><blockquote><p>sudo docker exec -it 578fcc293e25 /bin/bash</p></blockquote></li><li><p>退出容器</p><blockquote><p>exit/ctrl+c</p></blockquote></li><li><p>容器重启</p><blockquote><p>docker restart 容器id</p></blockquote></li></ul><a id="more"></a><ul><li><p>查看容器启动日志</p><blockquote><p>docker logs 容器id</p></blockquote></li><li><p>docker容器安装vim</p><blockquote><p>apt-get update，这个命令的作用是：同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。等更新完毕以后再敲命令：apt-get install vim命令即可。</p></blockquote></li><li><p>容器拷贝文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下:</span><br><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www</span><br><span class="line">将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中</span><br></pre></td></tr></table></figure><ul><li>容器设置时区<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">进入到/usr/share/zoneinfo/Asia目录，查看目录信息</span><br><span class="line">/usr/share/zoneinfo/Asia# ls -hl</span><br><span class="line">lrwxrwxrwx 1 root root    6 Jul  6 02:15 Shanghai -&gt; ../PRC</span><br><span class="line">lrwxrwxrwx 1 root root   12 Jul  6 02:15 Singapore -&gt; ../Singapore</span><br><span class="line">从查询结果可以知道，上海的时区文件实际上是个软连接文件。连接到了目录 /usr/share/zoneinfo/ 下的PRC文件。 </span><br><span class="line">直接进行拷贝：</span><br><span class="line">cp /usr/share/zoneinfo/PRC /etc/localtime</span><br><span class="line">然后这样就可以了。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;拉取镜像&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docker pull daocloud.io/library/mysql:5.6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建容器&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docker run -p 3306:3306 –name mysql -v /Users/peijiepang/Documents/docker/mysql/conf:/etc/mysql -v /Users/peijiepang/Documents/docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d daocloud.io/library/mysql:5.6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获取所有的容器id&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docker ps -a&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动容器&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docker start 578fcc293e25&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看当前启动的容器&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docker ps&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进去容器内部系统&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo docker exec -it 578fcc293e25 /bin/bash&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;退出容器&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;exit/ctrl+c&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;容器重启&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docker restart 容器id&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="docker" scheme="http://ppjys.cn/categories/docker/"/>
    
    
      <category term="命令" scheme="http://ppjys.cn/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>java应用CPU百分百解决方案</title>
    <link href="http://ppjys.cn/2018/04/22/java%E5%BA%94%E7%94%A8CPU%E7%99%BE%E5%88%86%E7%99%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://ppjys.cn/2018/04/22/java应用CPU百分百解决方案/</id>
    <published>2018-04-22T03:07:35.000Z</published>
    <updated>2018-07-03T13:24:35.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用top命令查找异常进程"><a href="#利用top命令查找异常进程" class="headerlink" title="利用top命令查找异常进程"></a>利用top命令查找异常进程</h2><blockquote><p>top</p></blockquote><p>输入top命令后，可以按P(shift+p)根据cpu占用排序、按M根据内存占用排序、按T根据运行时间排序。</p><p>这里先按P根据cpu排序查找异常的线程：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;利用top命令查找异常进程&quot;&gt;&lt;a href=&quot;#利用top命令查找异常进程&quot; class=&quot;headerlink&quot; title=&quot;利用top命令查找异常进程&quot;&gt;&lt;/a&gt;利用top命令查找异常进程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;top&lt;/p&gt;
&lt;/blo
      
    
    </summary>
    
      <category term="问题及解决" scheme="http://ppjys.cn/categories/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="服务器问题" scheme="http://ppjys.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>java应用OOM快速定位与解决方法</title>
    <link href="http://ppjys.cn/2018/04/21/OOM%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://ppjys.cn/2018/04/21/OOM快速定位与解决方法/</id>
    <published>2018-04-21T03:07:35.000Z</published>
    <updated>2018-07-03T15:20:28.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近项目老是出现OOM问题，常见有以下错误：</p><pre><code>java.lang.OutOfMemoryError: PermGen spacejava.lang.OutOfMemoryError: Java heap space</code></pre><h2 id="OOM的常见原因"><a href="#OOM的常见原因" class="headerlink" title="OOM的常见原因"></a>OOM的常见原因</h2><ul><li>内存分配确实过小</li><li>频繁创建对象，没有及时释放</li><li>频繁申请系统资源，导致系统资源耗尽（例如：不断创建线程，不断发起网络连接）</li></ul><h2 id="Java代码导致OutOfMemoryError错误的解决"><a href="#Java代码导致OutOfMemoryError错误的解决" class="headerlink" title="Java代码导致OutOfMemoryError错误的解决"></a>Java代码导致OutOfMemoryError错误的解决</h2><ul><li>检查代码中是否有死循环或递归调用。</li><li>检查是否有大循环重复产生新对象实体。</li><li>检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</li><li>检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。</li></ul><a id="more"></a><h2 id="定位代码解决"><a href="#定位代码解决" class="headerlink" title="定位代码解决"></a>定位代码解决</h2><p>需要先找到出问题的进程，使用top命令定位：</p><blockquote><p>top</p></blockquote><p>输入top命令后，可以按P(shift+p)根据cpu占用排序、按M根据内存占用排序、按T根据运行时间排序。（可以先按c显示具体的command）</p><p>这里先按M根据内存排序查找异常的进程：这里假设出现异常的进程pid为10410</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>定位问题前请先尝试输入jps命令，确定是否能够显示出现问题的pid.如果jps没有相应的显示，可能是你当前用户的权限不够，请使用启用相应进程的用户或者拥有更高权限的用户排查问题！不然以下的一些命令（例如jmap）将无法使用.</p><h2 id="判断是否是由于“内存分配确实过小”"><a href="#判断是否是由于“内存分配确实过小”" class="headerlink" title="判断是否是由于“内存分配确实过小”"></a>判断是否是由于“内存分配确实过小”</h2><p>输入以下命令：</p><blockquote><p>jmap -heap 10410</p></blockquote><pre><code>Attaching to process ID 10410, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.91-b14using thread-local object allocation.Parallel GC with 4 thread(s)Heap Configuration:   MinHeapFreeRatio         = 0   MaxHeapFreeRatio         = 100   MaxHeapSize              = 2147483648 (2048.0MB)   NewSize                  = 44564480 (42.5MB)   MaxNewSize               = 715653120 (682.5MB)   OldSize                  = 89653248 (85.5MB)   NewRatio                 = 2   SurvivorRatio            = 8   MetaspaceSize            = 21807104 (20.796875MB)   CompressedClassSpaceSize = 1073741824 (1024.0MB)   MaxMetaspaceSize         = 17592186044415 MB   G1HeapRegionSize         = 0 (0.0MB)Heap Usage:PS Young GenerationEden Space:   capacity = 343408640 (327.5MB)   used     = 63192336 (60.26490783691406MB)   free     = 280216304 (267.23509216308594MB)   18.401498576156964% usedFrom Space:   capacity = 18350080 (17.5MB)   used     = 12886976 (12.28997802734375MB)   free     = 5463104 (5.21002197265625MB)   70.22844587053571% usedTo Space:   capacity = 18874368 (18.0MB)   used     = 0 (0.0MB)   free     = 18874368 (18.0MB)   0.0% usedPS Old Generation   capacity = 80216064 (76.5MB)   used     = 24040136 (22.92646026611328MB)   free     = 56175928 (53.57353973388672MB)   29.969229106030433% used23018 interned Strings occupying 2885744 bytes.</code></pre><h2 id="判断是否是由于“频繁创建对象，没有及时回收”"><a href="#判断是否是由于“频繁创建对象，没有及时回收”" class="headerlink" title="判断是否是由于“频繁创建对象，没有及时回收”"></a>判断是否是由于“频繁创建对象，没有及时回收”</h2><p>输入以下命令，找出最耗内存的对象：</p><blockquote><p>jmap -histo:live 10410 | more</p></blockquote><pre><code>      num     #instances         #bytes  class name----------------------------------------------   1:         59259        8998824  [C   2:         21537        1895256  java.lang.reflect.Method   3:         57709        1385016  java.lang.String   4:          2683        1063512  [B   5:          9175        1021368  java.lang.Class   6:         18681         747240  java.util.LinkedHashMap$Entry   7:         21370         683840  java.util.concurrent.ConcurrentHashMap$Node   8:          8166         574544  [Ljava.util.HashMap$Node;   9:          9977         558712  java.util.LinkedHashMap  10:          9548         518480  [Ljava.lang.Object;  11:         21735         472376  [Ljava.lang.Class;  12:         13345         427040  java.util.HashMap$Node  13:          5570         401040  java.lang.reflect.Field  14:           259         258400  [Ljava.util.concurrent.ConcurrentHashMap$Node;  15:         14774         236384  java.lang.Object  16:          2692         215360  java.lang.reflect.Constructor  17:          3413         198216  [Ljava.lang.reflect.Method;  18:          4133         160288  [Ljava.lang.String;  19:          3695         147800  java.lang.ref.SoftReference  20:          1537         147552  org.springframework.beans.GenericTypeAwarePropertyDescriptor  21:          2378         133168  java.lang.Class$ReflectionData  22:          2861         132256  [I  23:          4050         129600  java.util.LinkedList  24:          3749         119968  java.lang.ref.WeakReference  25:          2435         116880  java.util.HashMap  26:          4509         108216  java.util.ArrayList  27:          4080          97920  java.beans.MethodRef  28:          2154          86160  java.util.TreeMap$Entry  29:          1188          85536  org.springframework.core.annotation.AnnotationAttributes  30:          1126          72064  org.springframework.core.MethodParameter  31:          2858          68592  java.util.LinkedList$Node  32:          3928          62848  java.util.LinkedHashSet  33:           370          62160  org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader$ConfigurationClassBeanDefinition  34:          2185          52440  sun.reflect.generics.tree.SimpleClassTypeSignature  35:          2016          48384  sun.reflect.annotation.AnnotationInvocationHandler  36:           961          46128  org.springframework.core.ResolvableType  37:           901          43248  org.apache.tomcat.util.modeler.AttributeInfo  38:          2023          43200  [Ljava.lang.reflect.Type;  39:          2570          41120  java.util.LinkedHashMap$LinkedKeySet  40:          2185          41096  [Lsun.reflect.generics.tree.TypeArgument;  41:          1282          41024  java.util.concurrent.locks.ReentrantLock$NonfairSync  42:          2472          39552  java.util.LinkedHashMap$LinkedEntrySet  43:          2374          37984  org.springframework.core.annotation.AnnotationUtils$DefaultValueHolder  44:          1593          37008  [Ljava.lang.reflect.Constructor;</code></pre><p>输入命令后，会以表格的形式显示存活对象的信息，并按照所占内存大小排序。</p><ul><li>instances: 对象实例数量</li><li>bytes: 占用内存大小</li><li>class name: 类名</li></ul><p>可以看到目前最耗内存的对象也才占用内存8m，所以属于正常范畴</p><p>如果发现某个对象的占用大量内存（例如：1G以上），就需要review代码，审查下该对象是否没有及时回收</p><p>PS：其中输出的奇怪的class name请查看最后的附录。</p><h2 id="判断是否是由于“频繁申请系统资源”"><a href="#判断是否是由于“频繁申请系统资源”" class="headerlink" title="判断是否是由于“频繁申请系统资源”"></a>判断是否是由于“频繁申请系统资源”</h2><p>输入以下命令，查看进程的线程数</p><blockquote><p>ll /proc/{PID}/task | wc -l</p></blockquote><p>输入以下命令，查看进程的句柄数</p><blockquote><p>ll /proc/{PID}/fd | wc -l</p></blockquote><h2 id="jmap-附加说明"><a href="#jmap-附加说明" class="headerlink" title="jmap 附加说明"></a>jmap 附加说明</h2><table><thead><tr><th>BaseType Character</th><th>Type</th><th>Interpretation</th></tr></thead><tbody><tr><td>B</td><td>byte</td><td>signed byte</td></tr><tr><td>C</td><td>char</td><td>Unicode character</td></tr><tr><td>D</td><td>double</td><td>double-precision floating-point value</td></tr><tr><td>F</td><td>float</td><td>single-precision floating-point value</td></tr><tr><td>I</td><td>int</td><td>integer</td></tr><tr><td>J</td><td>long</td><td>long integer</td></tr><tr><td>L</td><td>reference    an</td><td>instance of class</td></tr><tr><td>S</td><td>short</td><td>signed short</td></tr><tr><td>Z</td><td>boolean</td><td>true or false</td></tr><tr><td>[</td><td>reference</td><td>one array dimension</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近项目老是出现OOM问题，常见有以下错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;java.lang.OutOfMemoryError: PermGen space
java.lang.OutOfMemoryError: Java heap space
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;OOM的常见原因&quot;&gt;&lt;a href=&quot;#OOM的常见原因&quot; class=&quot;headerlink&quot; title=&quot;OOM的常见原因&quot;&gt;&lt;/a&gt;OOM的常见原因&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;内存分配确实过小&lt;/li&gt;
&lt;li&gt;频繁创建对象，没有及时释放&lt;/li&gt;
&lt;li&gt;频繁申请系统资源，导致系统资源耗尽（例如：不断创建线程，不断发起网络连接）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Java代码导致OutOfMemoryError错误的解决&quot;&gt;&lt;a href=&quot;#Java代码导致OutOfMemoryError错误的解决&quot; class=&quot;headerlink&quot; title=&quot;Java代码导致OutOfMemoryError错误的解决&quot;&gt;&lt;/a&gt;Java代码导致OutOfMemoryError错误的解决&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;检查代码中是否有死循环或递归调用。&lt;/li&gt;
&lt;li&gt;检查是否有大循环重复产生新对象实体。&lt;/li&gt;
&lt;li&gt;检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。&lt;/li&gt;
&lt;li&gt;检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="问题及解决" scheme="http://ppjys.cn/categories/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="OutOfMemoryError" scheme="http://ppjys.cn/tags/OutOfMemoryError/"/>
    
  </entry>
  
  <entry>
    <title>druid数据源无可用连接问题</title>
    <link href="http://ppjys.cn/2018/04/20/druid%E6%95%B0%E6%8D%AE%E6%BA%90%E6%97%A0%E5%8F%AF%E7%94%A8%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://ppjys.cn/2018/04/20/druid数据源无可用连接问题/</id>
    <published>2018-04-20T07:07:35.000Z</published>
    <updated>2018-07-03T13:24:35.601Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在工程中使用了druid连接池，运行一段时间后系统出现异常,但是使用客户端能正常连接，连接数被未被占满,报错如下：</p><blockquote><p>Caused by: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 60009, active 50                  at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:80)                  at org.springframework.jdbc.support.JdbcUtils.extractDatabaseMetaData(JdbcUtils.java:280)                  … 64 more  </p></blockquote><h2 id="原因及解决方案"><a href="#原因及解决方案" class="headerlink" title="原因及解决方案"></a>原因及解决方案</h2><p>应该是程序中有地方连接未关闭造成的。那如何来定呢？使用druid连接池的超时回收机制，在配置中增加以下内容：</p><pre><code>&lt;!– 超过时间限制是否回收 –&gt;  &lt;property name=“removeAbandoned” value=“true” /&gt;  &lt;!– 超时时间；单位为秒。180秒=3分钟 –&gt;  &lt;property name=“removeAbandonedTimeout” value=“180” /&gt;  &lt;!– 关闭abanded连接时输出错误日志 –&gt;  &lt;property name=“logAbandoned” value=“true” /&gt;   </code></pre><p>但是加了logAbandoned配置之后，可能经常会强制释放连接报错，错误如下：</p><blockquote><p>[com.alibaba.druid.pool.DruidDataSource] – &lt;abandon connection, open stackTrace          at java.lang.Thread.getStackTrace(Thread.java:1567)          at com.alibaba.druid.pool.DruidDataSource.getConnectionDirect(DruidDataSource.java:995)          at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:4544) </p></blockquote><pre><code>备注：该堆栈是之前使用该连接是new出来的，故可以凭此确认此链接使用没有很好的回收。 但理论上使用了mybatis，mybatis会负责好连接池申请回放回</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在工程中使用了druid连接池，运行一段时间后系统出现异常,但是使用客户端能正常连接，连接数被未被占满,报错如下：&lt;/p&gt;
&lt;blockqu
      
    
    </summary>
    
      <category term="问题及解决" scheme="http://ppjys.cn/categories/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="连接池" scheme="http://ppjys.cn/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>解决OutOfMemoryError: unable to create new native thread问题</title>
    <link href="http://ppjys.cn/2018/04/19/%E8%A7%A3%E5%86%B3OutOfMemoryError-unable-to-create-new-native-thread%E9%97%AE%E9%A2%98/"/>
    <id>http://ppjys.cn/2018/04/19/解决OutOfMemoryError-unable-to-create-new-native-thread问题/</id>
    <published>2018-04-19T06:07:35.000Z</published>
    <updated>2018-07-03T15:21:00.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>java.lang.OutOfMemoryError共有8种类型，其中java.lang.OutOfMemoryError: unable to create new native thread是很常见的一种，这类错误通常发生在应用试图创建新线程时。最近测试环境经常出现错误如下：</p><blockquote><p>Caused by: java.lang.OutOfMemoryError: unable to create new native thread<br>    at java.lang.Thread.start0(Native Method)<br>    at java.lang.Thread.start(Thread.java:714)<br>    at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:950)<br>    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1368)<br>    at com.alibaba.dubbo.remoting.transport.dispatcher.all.AllChannelHandler.caught(AllChannelHandler.java:65)</p></blockquote><h2 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因"></a>可能原因</h2><ol><li>系统内存耗尽，无法为新线程分配内存</li><li>创建线程数超过了操作系统的限制</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>排查应用是否创建了过多的线程<blockquote><p>通过jstack确定应用创建了多少线程？超量创建的线程的堆栈信息是怎样的？谁创建了这些线程？一旦明确了这些问题，便很容易解决。步骤如下：</p><blockquote><p>该进程内最耗费CPU的线程pid top -Hp pid</p><p>将pid装换成十六进制 printf “%x\n” 21742</p><p>最后用jstack查找线程堆栈信息 jstack 21711 | grep 54ee</p></blockquote></blockquote></li></ol><a id="more"></a><ol start="2"><li><p>调整操作系统线程数阈值</p><blockquote><p>操作系统会限制进程允许创建的线程数，使用ulimit -u命令查看限制。某些服务器上此阈值设置的过小，比如1024。一旦应用创建超过1024个线程，就会遇到java.lang.OutOfMemoryError: unable to create new native thread问题。如果是这种情况，可以调大操作系统线程数阈值。</p><blockquote><p>用当前用户登录，然后用ulimit -a查看配置项，将max user processes项调整大一点，可以参考top -H 信息中的 Threads: 853 total线程数</p></blockquote></blockquote></li><li><p>增加机器内存</p><blockquote><p>如果上述两项未能排除问题，可能是正常增长的业务确实需要更多内存来创建更多线程。如果是这种情况，增加机器内存。</p></blockquote></li><li><p>减小堆内存</p><blockquote><p>一个老司机也经常忽略的非常重要的知识点：线程不在堆内存上创建，线程在堆内存之外的内存上创建。所以如果分配了堆内存之后只剩下很少的可用内存，依然可能遇到java.lang.OutOfMemoryError: unable to create new native thread。考虑如下场景：系统总内存6G，堆内存分配了5G，永久代512M。在这种情况下，JVM占用了5.5G内存，系统进程、其他用户进程和线程将共用剩下的0.5G内存，很有可能没有足够的可用内存创建新的线程。如果是这种情况，考虑减小堆内存。</p></blockquote></li><li><p>减少进程数</p><blockquote><p>这和减小堆内存原理相似。考虑如下场景：系统总内存32G，java进程数5个，每个进程的堆内存6G。在这种情况下，java进程总共占用30G内存，仅剩下2G内存用于系统进程、其他用户进程和线程，很有可能没有足够的可用内存创建新的线程。如果是这种情况，考虑减少每台机器上的进程数。</p></blockquote></li><li><p>减小线程栈大小</p><blockquote><p>线程会占用内存，如果每个线程都占用更多内存，整体上将消耗更多的内存。每个线程默认占用内存大小取决于JVM实现。可以利用-Xss参数限制线程内存大小，降低总内存消耗。例如，JVM默认每个线程占用1M内存，应用有500个线程，那么将消耗500M内存空间。如果实际上256K内存足够线程正常运行，配置-Xss256k，那么500个线程将只需要消耗125M内存。（注意，如果-Xss设置的过低，将会产生java.lang.StackOverflowError错误）</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;java.lang.OutOfMemoryError共有8种类型，其中java.lang.OutOfMemoryError: unable to create new native thread是很常见的一种，这类错误通常发生在应用试图创建新线程时。最近测试环境经常出现错误如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Caused by: java.lang.OutOfMemoryError: unable to create new native thread&lt;br&gt;    at java.lang.Thread.start0(Native Method)&lt;br&gt;    at java.lang.Thread.start(Thread.java:714)&lt;br&gt;    at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:950)&lt;br&gt;    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1368)&lt;br&gt;    at com.alibaba.dubbo.remoting.transport.dispatcher.all.AllChannelHandler.caught(AllChannelHandler.java:65)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;可能原因&quot;&gt;&lt;a href=&quot;#可能原因&quot; class=&quot;headerlink&quot; title=&quot;可能原因&quot;&gt;&lt;/a&gt;可能原因&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;系统内存耗尽，无法为新线程分配内存&lt;/li&gt;
&lt;li&gt;创建线程数超过了操作系统的限制&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;排查应用是否创建了过多的线程&lt;blockquote&gt;
&lt;p&gt;通过jstack确定应用创建了多少线程？超量创建的线程的堆栈信息是怎样的？谁创建了这些线程？一旦明确了这些问题，便很容易解决。步骤如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该进程内最耗费CPU的线程pid top -Hp pid&lt;/p&gt;
&lt;p&gt;将pid装换成十六进制 printf “%x\n” 21742&lt;/p&gt;
&lt;p&gt;最后用jstack查找线程堆栈信息 jstack 21711 | grep 54ee&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="问题及解决" scheme="http://ppjys.cn/categories/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    
    
      <category term="OutOfMemoryError" scheme="http://ppjys.cn/tags/OutOfMemoryError/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="http://ppjys.cn/2018/04/12/hello-hexo/"/>
    <id>http://ppjys.cn/2018/04/12/hello-hexo/</id>
    <published>2018-04-11T16:00:00.000Z</published>
    <updated>2018-07-03T13:24:35.602Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以前一直用wordpress维护博客，最近看到hexo博客的样例，觉得挺炫的，今天就准备将<a href="http://ppjys.cn">wordpress版本</a>的博客迁移到hexo，然后重新梳理以前的博文。</p></blockquote><h2 id="Hexo-Quick-Start"><a href="#Hexo-Quick-Start" class="headerlink" title="Hexo Quick Start"></a>Hexo Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以前一直用wordpress维护博客，最近看到hexo博客的样例，觉得挺炫的，今天就准备将&lt;a href=&quot;http://ppjys.cn&quot;&gt;wordpress版本&lt;/a&gt;的博客迁移到hexo，然后重新梳理以前的博文。&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
      <category term="感悟" scheme="http://ppjys.cn/categories/%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="感悟" scheme="http://ppjys.cn/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
</feed>
