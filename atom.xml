<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J~杰&#39;s Blog</title>
  
  <subtitle>人生就一条路，走一步有一步的景观</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.ppjys.cn/"/>
  <updated>2020-08-30T09:38:37.143Z</updated>
  <id>blog.ppjys.cn/</id>
  
  <author>
    <name>J~杰</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络知识</title>
    <link href="blog.ppjys.cn/2020/08/30/20200830%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/"/>
    <id>blog.ppjys.cn/2020/08/30/20200830计算机网络知识/</id>
    <published>2020-08-30T09:24:43.000Z</published>
    <updated>2020-08-30T09:38:37.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h2><p><img src="/images/network1.png" alt=""></p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol><li><a href="https://github.com/ppj19891020/daily-interviews/issues/2" target="_blank" rel="noopener">网络模型是什么？</a></li><li><a href="https://github.com/ppj19891020/daily-interviews/issues/3" target="_blank" rel="noopener">说说TCP协议的三次握手？</a></li><li><a href="https://github.com/ppj19891020/daily-interviews/issues/4" target="_blank" rel="noopener">说说TCP协议的四次挥手？</a></li><li><a href="https://github.com/ppj19891020/daily-interviews/issues/5" target="_blank" rel="noopener">为什么需要三次握手才能建立连接？</a></li><li><a href="https://github.com/ppj19891020/daily-interviews/issues/6" target="_blank" rel="noopener">SYN洪水攻击防护？</a></li><li><a href="https://github.com/ppj19891020/daily-interviews/issues/7" target="_blank" rel="noopener">建立连接后，Client出现故障怎么办？</a></li><li><a href="https://github.com/ppj19891020/daily-interviews/issues/8" target="_blank" rel="noopener">为什么会有TIME_WAIT状态？</a></li><li><a href="https://github.com/ppj19891020/daily-interviews/issues/9" target="_blank" rel="noopener">为什么需要四次挥手才能断开连接？</a></li><li><a href="https://github.com/ppj19891020/daily-interviews/issues/10" target="_blank" rel="noopener">服务器出现大量CLOST_WAIT状态的原因？</a></li><li><a href="https://github.com/ppj19891020/daily-interviews/issues/11" target="_blank" rel="noopener">UDP和TCP的区别？</a></li><li><a href="https://github.com/ppj19891020/daily-interviews/issues/12" target="_blank" rel="noopener">说说TCP协议的滑动窗口？</a></li><li><a href="https://github.com/ppj19891020/daily-interviews/issues/14" target="_blank" rel="noopener">浏览器中输入url，按下回车经过的过程？</a></li><li><a href="https://github.com/ppj19891020/daily-interviews/issues/15" target="_blank" rel="noopener">Get和Post的区别？</a></li><li><a href="https://github.com/ppj19891020/daily-interviews/issues/16" target="_blank" rel="noopener">Cookies和Session的区别？</a></li><li><a href="https://github.com/ppj19891020/daily-interviews/issues/17" target="_blank" rel="noopener">http和http的区别？</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;知识图谱&quot;&gt;&lt;a href=&quot;#知识图谱&quot; class=&quot;headerlink&quot; title=&quot;知识图谱&quot;&gt;&lt;/a&gt;知识图谱&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/network1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;面试题&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="面试总结" scheme="blog.ppjys.cn/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JVM学习笔记</title>
    <link href="blog.ppjys.cn/2020/06/20/20200620_JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>blog.ppjys.cn/2020/06/20/20200620_JVM学习笔记/</id>
    <published>2020-06-20T14:30:00.000Z</published>
    <updated>2020-08-26T00:07:15.720Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><p>根据《Java虚拟机规范(Java SE 7版)》规定，Java虚拟机内存结构可划分为以下区域：</p><p><img src="/images/jvm1.png" alt=""></p><ul><li><p><strong>程序计数器</strong>：</p><ul><li>程序计数器是一块较小的内存空间，可看作是当前线程所执行的字节码的行号指示器。在虚拟机概念模型里，字节码解释器工作时就是通过改变该计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖该计数器来完成。</li><li>JVM中多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。即在任何时刻，CPU只会执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，该内存为线程私有。</li><li>如果线程正在执行一个Java方法，则PC记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法，则PC值为Undefined，该内存区域是唯一一个没用OOM的区域。</li></ul></li><li><p><strong>虚拟机栈</strong>：</p><ul><li>Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的时候会创建一个栈帧，用来存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用至执行完成的过程对应着一个栈帧在虚拟机栈中入栈到出栈的过程.</li><li>局部变量表：存放编译期可知的各种基本数据类型(如Boolean、byte、char、short、int、float、long、double)、对象引用类型（如：引用指针、句柄等）。局部变量表所需内存空间在编译期间完成分配，即进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是确定的，在方法运行期间不会改变局部变量表的大小。</li><li>异常情况：<ul><li>StackOverflowError异常：线程请求的栈深度大于虚拟机所允许的深度时，会抛出栈上溢异常</li><li>OutOfMemoryError异常：虚拟机栈动态扩展时无法申请到足够的内存，会抛出内存溢出异常</li></ul></li></ul></li><li><p><strong>本地方法栈</strong>：</p><ul><li>发挥的作用与虚拟机栈类似，区别在于虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务，如Java访问C语言的方法、汇编程序等。</li><li>异常情况：与虚拟机栈一样。</li></ul></li><li><p><strong>堆</strong>：</p><ul><li>堆是Java所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建，用于存放对象实例，也是垃圾收集器管理的主要区域。</li><li>根据GC分代收集算法，堆可细分为：新生代和老年代；新生代又分为Eden区、Survivor区（from,to）从内存分配的角度看，线程共享的Java堆可划分出多个线程私有的分配缓冲区（TLAB：Thread Local Allocation Buffer)</li><li>堆内存仅要逻辑上连续即可，物理上不连续也可以，如果在堆中没有内存完成实例分配。并且堆也无法再扩展时，则会抛出OOM异常</li></ul></li><li><p><strong>方法区</strong>：</p><ul><li>与堆一样，方法区是各线程共享的，用于存储已被虚拟机 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li><li>对于开发者来说，该区又称为“永久代”Permanent Generation，当方法区无法满足内存分配时，将抛出OOM异常</li></ul><a id="more"></a></li></ul><h3 id="堆内存结构"><a href="#堆内存结构" class="headerlink" title="堆内存结构"></a>堆内存结构</h3><p><img src="/images/jvm2.png" alt=""></p><p><strong>堆内存分配策略：</strong></p><ul><li>new一个对象时，大对象（如长字符串与大数组）直接存放在老年代，其他普通对象存放在新生代的eden区</li><li>eden区中的对象，在经历第一次GC后，如果没有被回收，虚拟机则把存活的对象存放在survivor中的from区</li><li>eden区中的对象，在经历第二次GC后，如果没有被回收，虚拟机则把存活的对象存放在survivor中的to区，同时把存活在from区的对象从from区复制到to区，from区与to区指向交换</li><li>以此类推，继续进行GC，存活对象存放在survivor区，from与to角色不断互换。</li><li>经历了多次GC后，如果survivor区中对象仍然存活（达到GC年龄），则会晋升到老年代</li></ul><h3 id="Java对象内存分配与逃逸分析"><a href="#Java对象内存分配与逃逸分析" class="headerlink" title="Java对象内存分配与逃逸分析"></a>Java对象内存分配与逃逸分析</h3><h4 id="1、Java对象的分配："><a href="#1、Java对象的分配：" class="headerlink" title="1、Java对象的分配："></a>1、Java对象的分配：</h4><ul><li>栈上分配<ul><li>线程私有小对象</li><li>无逃逸</li><li>支持标量替换</li><li>无需调整（虚拟机自动优化，无需调优）</li></ul></li><li>线程本地分配TLAB（Thread Local Allocation Buffer）<ul><li>占用eden，默认1%，仍在堆上申请，用作线程专用</li><li>多线程的时候不用竞争（加锁）eden就可以申请空间（同步消除），提高效率</li><li>小对象</li><li>无需调整</li></ul></li><li>老年代<ul><li>大对象（大数组、长字符串）</li></ul></li><li>eden<ul><li>new普通对象</li></ul></li></ul><p><strong>分配策略：</strong> 如果JVM启动了逃逸分析，那么new一个对象时，首先会尝试在栈上分配，如果分配不了，则会尝试在线程本地分配，如果栈上分配与线程本地分配均分配失败的话，则会先判断该对象是否为大对象，如果是大对象，则在老年代分配内存，否则到新生代的eden区分配。</p><h4 id="2、逃逸分析"><a href="#2、逃逸分析" class="headerlink" title="2、逃逸分析"></a>2、逃逸分析</h4><p>逃逸分析是一种为其他优化手段提供依据的分析技术，其基本行为是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸；也有可能被其外部线程访问到，如复制给类变量或者可以在其他线程中访问的实例变量，称为线程逃逸。 如果一个对象不会逃逸到方法或者线程之外，则可以对这个对象进行一些高效的优化：</p><ul><li><p>栈上分配Stack Allocation：如果一个对象不会逃逸到方法之外，那么可以让这个对象在栈上分配内存，以提高执行效率，对象所占内存会随着栈帧出栈而销毁。在一般应用中，无逃逸的局部变量对象所占的比例较大，如果能使用栈上分配，那么大量的对象就会随着方法的结束而自动销毁，GC压力减小很多。</p></li><li><p>同步消除SynchronizationElimination：线程同步是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么该变量的读写不存在竞争关系，即可以消除掉对这个变量的同步措施</p></li><li><p>标量替换：</p><ul><li><p>标量：指的是一个数据已经无法再分解成更小的数据来表示了，Java虚拟机的原始数据类型（int,float等数值类型以及reference类型）都不能再进行进一步的分解</p></li><li><p>聚合量：相对于标量，如果一个数据可继续分解，则可以称作聚合量，Java对象是典型的聚合量。</p></li><li><p>如果把一个Java对象拆散，根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问，这过程成为标量替换</p></li><li><p>如果逃逸分析可以确定一个对象不会被外部访问，且这个对象可以被拆散，那程序真正执行的时候，可以不创建这个对象，而是直接创建它的成员变量来替换这个对象。将对象拆分后，可以在栈上分配内存</p></li></ul></li></ul><h4 id="3、测试实例"><a href="#3、测试实例" class="headerlink" title="3、测试实例"></a>3、测试实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Description：新建10000000个对象，计算执行时间，再配置不同JVM参数</span></span><br><span class="line"><span class="comment">* 比较执行结果</span></span><br><span class="line"><span class="comment">*    -XX:-DoEscapeAnalysis  关闭逃逸分析</span></span><br><span class="line"><span class="comment">*    -XX:-EliminateAllocations 关闭标量替换</span></span><br><span class="line"><span class="comment">*    -XX:-UseTLAB 关闭线程本地内存</span></span><br><span class="line"><span class="comment">*    -XX:-PrintGC 打印GC信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMTest1</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        String name;</span><br><span class="line">        </span><br><span class="line">        User(<span class="keyword">int</span> id,String name)&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alloc</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> User(i,<span class="string">"name"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            JVMTest1 t = <span class="keyword">new</span> JVMTest1();</span><br><span class="line">            <span class="keyword">long</span> s1 = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++)&#123;</span><br><span class="line">                t.alloc(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> s2 = System.currentTimeMillis();</span><br><span class="line">            System.out.println(s2-s1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果分析：</strong></p><p>a. 无逃逸分析、无栈上分配、不使用线程本地内存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:-UseTLAB -XX:+PrintGC</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)  49152K-&gt;688K(188416K), 0.0010012 secs]</span><br><span class="line">[GC (Allocation Failure)  49840K-&gt;728K(188416K), 0.0009848 secs]</span><br><span class="line">[GC (Allocation Failure)  49880K-&gt;640K(188416K), 0.0007432 secs]</span><br><span class="line">[GC (Allocation Failure)  49792K-&gt;672K(237568K), 0.0008412 secs]</span><br><span class="line">[GC (Allocation Failure)  98976K-&gt;640K(237568K), 0.0012708 secs]</span><br><span class="line">[GC (Allocation Failure)  98944K-&gt;656K(328704K), 0.0008696 secs]</span><br><span class="line">[GC (Allocation Failure)  197264K-&gt;624K(328704K), 0.0017397 secs]</span><br><span class="line">[GC (Allocation Failure)  197232K-&gt;624K(320512K), 0.0003312 secs]</span><br><span class="line">791</span><br></pre></td></tr></table></figure><p>b. 使用线程本地内存，无需在eden区分配内存时加锁，效率变高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+UseTLAB -XX:+PrintGC</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)  49760K-&gt;640K(188416K), 0.0007129 secs]</span><br><span class="line">[GC (Allocation Failure)  49792K-&gt;624K(237568K), 0.0008062 secs]</span><br><span class="line">[GC (Allocation Failure)  98928K-&gt;608K(237568K), 0.0014966 secs]</span><br><span class="line">[GC (Allocation Failure)  98912K-&gt;728K(328704K), 0.0008608 secs]</span><br><span class="line">[GC (Allocation Failure)  197336K-&gt;588K(328704K), 0.0016310 secs]</span><br><span class="line">[GC (Allocation Failure)  197196K-&gt;620K(525312K), 0.0003275 secs]</span><br><span class="line">528</span><br></pre></td></tr></table></figure><p>c. 开启逃逸分析、使用标量替换、使用线程本地内存、效率变高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+UseTLAB -XX:+PrintGC</span><br></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)  49152K-&gt;688K(188416K), 0.0010576 secs]</span><br><span class="line">[GC (Allocation Failure)  49840K-&gt;640K(188416K), 0.0009443 secs]</span><br><span class="line">[GC (Allocation Failure)  49792K-&gt;640K(188416K), 0.0007502 secs]</span><br><span class="line">[GC (Allocation Failure)  49792K-&gt;696K(237568K), 0.0008981 secs]</span><br><span class="line">[GC (Allocation Failure)  99000K-&gt;656K(237568K), 0.0011229 secs]</span><br><span class="line">[GC (Allocation Failure)  98960K-&gt;608K(328704K), 0.0010558 secs]</span><br><span class="line">[GC (Allocation Failure)  197216K-&gt;644K(328704K), 0.0015396 secs]</span><br><span class="line">486</span><br></pre></td></tr></table></figure><p>问题分析：开启逃逸分析存在开销，有时效率不如未开逃逸分析时的效率高</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="1、什么是可回收对象-垃圾-？"><a href="#1、什么是可回收对象-垃圾-？" class="headerlink" title="1、什么是可回收对象(垃圾)？"></a>1、什么是可回收对象(垃圾)？</h4><p><img src="/images/jvm3.png" alt=""></p><ul><li>强引用：强引用指的是子程序代码中普通存在的，类似Object obj = new Object()这类的引用，只要强引用还在，垃圾收集器则不会回收掉被引用的对象.</li><li>软引用：软引用用于描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常，在jdk1.2之后，提供了SoftReference类来实现软引用.</li><li>弱引用：弱引用也是用于描述非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象，在jdk1.2之后，提供了WeakReference类来实现弱引用.</li><li>虚引用：也称为幽灵引用、幻影引用，是最弱的一种引用关系，一个对象是否有虚引用的存在，不会对其生成时间构成影响，无法通过虚引用来引用对象。为一个对象设置虚引用的目的是能在这个对象被收集器回收时收到一个系统通知，jdk1.2提供PhantomReference类来实现虚引用.</li></ul><h4 id="2、GC是如何确定垃圾的？"><a href="#2、GC是如何确定垃圾的？" class="headerlink" title="2、GC是如何确定垃圾的？"></a>2、GC是如何确定垃圾的？</h4><ul><li><p>引用计数法</p><ul><li>算法思路：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象则是不可用的。</li><li>引用计数算法（Reference Counting）的实现简单，判定效率也很高，但是无法解决循环引用问题</li></ul></li><li><p>可达性分析</p><ul><li><p>从roots对象计算可以达到的对象</p></li><li><p>可作为GC Roots的对象包括：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ul></li><li><p>算法思路：以GC Roots 对象为起始点，从这些节点开始向下搜索（深度搜索），搜索所走过的路劲成为引用链（Reference Chain），当一个对象到GCRoots不存在引用链（不可达）时，则证明此对象是不可用，即判定为可回收对象。逻辑图如下：</p><p><img src="/images/jvm4.png" alt=""></p></li></ul></li></ul><h4 id="3、GC算法"><a href="#3、GC算法" class="headerlink" title="3、GC算法"></a>3、GC算法</h4><ol><li>Mark-Sweep标记清除</li></ol><ul><li>算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，标记过程通过可达性分析，将不可达的对象进行标记判定。</li><li>不足之处：<ul><li>效率问题，标记和清除两个过程效率都不高</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续需要分配较大内存的对象时，无法找到足够的连续内存，而不得不提前触发一次FGC</li></ul></li></ul><ol start="2"><li>Copying复制</li></ol><ul><li>将内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把使用过的内存空间一次清理掉。常用于新生代 survivor区的from/to的复制</li><li>优点：在内存上进行复制效率高，不存在内存碎片化问题</li><li>缺点：内存空间利用率低，算法代价高，因此实际分给新生代中的survivor区内存较小，与Eden区比例约为8:1:1</li></ul><ol start="3"><li>Mark-Compact标记压缩：</li></ol><ul><li>标记过程仍然与标记-清除算法一样，采用可达性分析标记判定，然后让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。</li><li>该算法效率略低于复制算法，但内存空间利用率高，常用于老年代GC</li></ul><ol start="4"><li><p>分代收集算法：</p><p>当前商业虚拟机的垃圾收集都采用分代收集（GenerationalCollection）算法,，该算法根据对象存活周期的不同将堆内存划分为几块：新生代、老年代，然后根据各个年代的特点采用最适当的GC算法：</p></li></ol><ul><li>在新生代中，每次GC时都发现有大量对象死去，只有少量存活，则选用复制算法，只需要付出少量存活对象的复制成本即可完成GC</li><li>在老年代中，对象存活率高、，没有额外空间对它进行分配担保，则需要使用标记-清除算法或者标记-压缩算法（默认使用）进行GC</li></ul><h4 id="4、垃圾收集器"><a href="#4、垃圾收集器" class="headerlink" title="4、垃圾收集器"></a>4、垃圾收集器</h4><ul><li><p>串行收集器 Serial Collector:</p><ul><li><p>串行收集器使用单个线程执行所有垃圾收集工作，这使得它相对高效，因为线程之间没有通信开销。它最适合于单处理器机器，因为它不能利用多处理器硬件，尽管对于具有小数据集（高达大约100 MB）的应用程序，它可能对多处理器很有用。串行收集器在某些硬件和操作系统配置中默认选中，或者可以使用该选项明确启用-XX:+UseSerialGC。</p></li><li><p>XX:+UseSerialGC</p></li><li><p>单线程</p></li></ul></li></ul><ul><li><p>并行收集器 Paraller Collector：</p><ul><li><p>官方文档(翻译)：并行收集器（也称为吞吐量收集器）并行执行次要收集，这可以显着减少垃圾收集开销。它适用于在多处理器或多线程硬件上运行的中型到大型数据集的应用程序。并行收集器在某些硬件和操作系统配置上默认选中，或者可以使用该选项明确启用-XX:+UseParallelGC。</p></li><li><p>并行压缩是一个使并行采集器能够并行执行主要采集的功能。如果没有并行压缩，主要集合将使用单个线程执行，这可能会极大地限制可伸缩性。如果-XX:+UseParallelGC指定了选项，则默认启用并行压缩。关闭它的选项是-XX:-UseParallelOldGC。</p></li><li><p>并发量大，每次GC时，JVM需要停顿</p></li></ul></li></ul><ul><li><p>并发收集器</p><ul><li><p>CMS Collector： 此收集器适用于希望缩短垃圾收集暂停时间并能够与垃圾收集共享处理器资源的应用程序。</p><ul><li>停顿时间短</li></ul></li><li><p>G1： 这种服务器式垃圾收集器适用于内存较大的多处理器机器。它以高概率满足垃圾收集暂停时间目标，同时实现高吞吐量。</p><ul><li>停顿短，同时并发大</li></ul></li></ul></li></ul><ul><li><p>并发开销：</p><ul><li><p>大多数并发收集器交换处理器资源（否则可用于应用程序）以缩短主要收集暂停时间。最明显的开销是在收集的并发部分期间使用一个或多个处理器。在N处理器系统上，并发部分集合将使用可用处理器的K / N，其中1 &lt;= K &lt;= ceiling { N / 4}。（注意K上的精确选择和边界）除了在并行阶段使用处理器之外，还会产生额外的开销以实现并发。因此，虽然垃圾收集暂停通常比并发收集器短得多，但应用程序吞吐量也往往略低于其他收集器。</p></li><li><p>在具有多个处理核心的计算机上，处理器可用于集合并发部分中的应用程序线程，因此并发垃圾收集器线程不会“暂停”应用程序。这通常会导致更短的暂停，但是应用程序可用的处理器资源也较少，应该会出现一些减速，特别是在应用程序最大限度地使用所有处理内核的情况下。随着N的增加，由于并发垃圾收集导致的处理器资源减少变得更小，同时收集的收益也增加。的部分并行模故障在并发标记扫描（CMS）集电极讨论了这样的缩放潜在限制。</p></li><li><p>由于至少有一个处理器用于并发阶段的垃圾收集，因此并发收集器通常不会为单处理器（单核）机器提供任何好处。但是，对于CMS（不是G1），可以使用单独的模式，可以在只有一个或两个处理器的系统上实现低暂停; 看到增量模式在并发标记扫描（CMS）收集器的详细信息。此功能在Java SE 8中不推荐使用，并可能在以后的主要版本中删除。</p></li></ul></li></ul><ul><li><p>选择收集器：除非应用程序具有相当严格的暂停时间要求，否则请先运行您的应用程序并允许VM选择收集器。如有必要，请调整堆大小以提高性能。如果性能仍不能达到您的目标，请使用以下指南作为选择收集器的起点。</p><ul><li>如果应用程序有一个小数据集（最多大约100MB），那么用选项选择串行收集器-XX:+UseSerialGC。</li><li>如果应用程序将在单个处理器上运行，并且没有暂停时间要求，则让VM选择收集器，或者使用该选项选择串行收集器-XX:+UseSerialGC。</li><li>如果（a）峰值应用程序性能是第一优先级并且（b）没有暂停时间要求或暂停1秒或更长时间是可接受的，则让VM选择收集器，或者选择并行收集器-XX:+UseParallelGC。</li><li>如果响应时间比整体吞吐量更重要，并且垃圾收集暂停时间必须短于大约1秒，那么使用-XX:+UseConcMarkSweepGC或选择并发收集器-XX:+UseG1GC。</li><li>如果推荐的收集器无法达到所需的性能，请首先尝试调整堆和代的大小以达到所需的目标。如果性能仍然不足，请尝试使用其他收集器：使用并发收集器来减少暂停时间，并使用并行收集器来提高多处理器硬件的整体吞吐量。</li></ul></li></ul><h3 id="OOM测试实例与内存查看工具的使用"><a href="#OOM测试实例与内存查看工具的使用" class="headerlink" title="OOM测试实例与内存查看工具的使用"></a>OOM测试实例与内存查看工具的使用</h3><h4 id="1、OOM测试实例"><a href="#1、OOM测试实例" class="headerlink" title="1、OOM测试实例"></a>1、OOM测试实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 内存溢出</span></span><br><span class="line"><span class="comment">* -XX:+HeapDumpOutOfMemoryError  当发生内存溢出时，导出dump文件</span></span><br><span class="line"><span class="comment">* -XX:HeapDumpPath=d:\tmp\jvm.dump  设置dump文件的路径为d:\tmp\jvm.dump2</span></span><br><span class="line"><span class="comment">* -XX:+PrintGCDetails  控制台打印详细GC信息</span></span><br><span class="line"><span class="comment">* -Xms10M  设置虚拟机初始堆内存为10M</span></span><br><span class="line"><span class="comment">* -Xmx10M  设置虚拟机最大堆内存为10M</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000000</span>;i++)&#123;</span><br><span class="line">            lists.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><ul><li>一般情况下，虚拟机的初始堆内存会比最大堆内存要小，而调优时往往会把初始值-Xms调至最大值-Xmx或者接近最大值,目的是减少中间的GC内存计算过程。</li><li>例如，设置-Xmx1G，-Xms256M，当程序运行时，虚拟机会不断地进行GC、申请新内存用于存新对象，且进行一次GC的效率较低，耗时。而直接设置-Xms1G时，初始内存开始就分配1G，与最大内存相等，程序运行时就省去了中间的内存计算及GC过程，进而提高了效率，这是调优的小技巧。</li></ul><h4 id="2、StackOverflow栈溢出"><a href="#2、StackOverflow栈溢出" class="headerlink" title="2、StackOverflow栈溢出"></a>2、StackOverflow栈溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMTest4</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算递归调用次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归查看栈深度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            foo();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Throwable t)&#123;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            t.printStackTrace();<span class="comment">//栈溢出，递归调用过深</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.StackOverflowError</span></span><br><span class="line">    <span class="selector-tag">at</span> <span class="selector-tag">com</span><span class="selector-class">.vechace</span><span class="selector-class">.JVM</span><span class="selector-class">.JVMTest4</span><span class="selector-class">.foo</span>(JVMTest4.<span class="attribute">java</span>:<span class="number">17</span>)</span><br><span class="line">    <span class="selector-tag">at</span> <span class="selector-tag">com</span><span class="selector-class">.vechace</span><span class="selector-class">.JVM</span><span class="selector-class">.JVMTest4</span><span class="selector-class">.foo</span>(JVMTest4.<span class="attribute">java</span>:<span class="number">17</span>)</span><br><span class="line">    <span class="selector-tag">at</span> <span class="selector-tag">com</span><span class="selector-class">.vechace</span><span class="selector-class">.JVM</span><span class="selector-class">.JVMTest4</span><span class="selector-class">.foo</span>(JVMTest4.<span class="attribute">java</span>:<span class="number">17</span>)</span><br><span class="line">    <span class="selector-tag">at</span> <span class="selector-tag">com</span><span class="selector-class">.vechace</span><span class="selector-class">.JVM</span><span class="selector-class">.JVMTest4</span><span class="selector-class">.foo</span>(JVMTest4.<span class="attribute">java</span>:<span class="number">17</span>)</span><br><span class="line">    <span class="selector-tag">at</span> <span class="selector-tag">com</span><span class="selector-class">.vechace</span><span class="selector-class">.JVM</span><span class="selector-class">.JVMTest4</span><span class="selector-class">.foo</span>(JVMTest4.<span class="attribute">java</span>:<span class="number">17</span>)</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><ul><li>分析：<ul><li>，在JVM调优时，-Xss也是一个非常重要的调优参数，当-Xss调的值较小时，线程的并发数就多（总内存不变，每个线程分的内存少，线程数自然变多）</li><li>而当-Xss调的比较大，则线程递归深度就深（内存分得多，调用栈深度越深，同时线程数变少），该值属于经验值，需要结合业务来进行分析。</li></ul></li></ul><h3 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h3><p><strong>1、商业虚拟机：</strong></p><ul><li>HotSpot：oracle商业虚拟机，在jdk1.8下，默认模式是Server</li><li>Openjdk：开源虚拟机</li></ul><p><strong>2、JVM参数格式</strong></p><p>-：标准参数，所有JVM都应该支持，可在命令行下输入Java查看 -X : 非标准参数，每个JVM实现都不同 -XX : 不稳定参数，下一个版本可能会取消</p><p><strong>3、常用JVM参数</strong></p><ul><li>堆设置：<ul><li>-Xms 初始堆大小</li><li>-Xmx 最大堆大小</li><li>-Xss 线程栈大小</li><li>-XX:NewSize=n 设置新生代大小</li><li>-XX:NewRatio=n设置新生代和老年代的比值，如-XX:NewRatio=3，表示新生代：老年代= 1:3，新生代占整个新老年代和的1/4</li><li>-XX:SurvivorRatio=n新生代中eden区与两个survivor区的比值，如-XX:SurvivorRatio=3，表示eden:survior =3:2，一个survivor区占整个新生代的1/5</li><li>-XX:MaxPermSize=n 设置永久代大小</li></ul></li><li>收集器设置：<ul><li>-XX:+UseSerialGC 设置使用串行收集器</li><li>-XX:+UseParallelGC 设置并行收集器</li><li>-XX:+UseConcMarkSweepGC 设置并发收集器</li></ul></li><li>GC统计信息：<ul><li>-XX:+PrintGC 打印GC信息</li><li>-XX:+PrintGCDetails 打印详细GC信息</li><li>-Xloggc:filename 打印GC信息到日志文件中</li></ul></li><li>其他：<ul><li>-XX:-DoEscapeAnalysis 关闭逃逸分析</li><li>-XX:-EliminateAllocations 关闭标量替换</li><li>-XX:-UseTLAB 关闭线程本地内存</li></ul></li></ul><h3 id="tomcat参数配置"><a href="#tomcat参数配置" class="headerlink" title="tomcat参数配置"></a>tomcat参数配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">set JAVA_OPTS = </span><br><span class="line"><span class="selector-tag">-Xms4g</span> </span><br><span class="line"><span class="selector-tag">-Xmx4g</span> </span><br><span class="line"><span class="selector-tag">-Xss512k</span> </span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:+AggressiveOpts</span> 尽可能地用上<span class="selector-tag">JVM</span>自带的优化策略</span><br><span class="line"><span class="selector-tag">-XX</span><span class="selector-pseudo">:+UseBiasedLocking</span>  启用偏置锁优化</span><br><span class="line">-XX:PermSize=64M //jdk1.8取消了该参数</span><br><span class="line">-XX:MaxPermSize=300M </span><br><span class="line"><span class="attribute">-XX</span>:+DisableExplicitGC  关闭显式调用GC，如System.gc()，以免打乱调优结构</span><br><span class="line"><span class="attribute">-XX</span>:+UseConcMarkSweepGC 使用CMS缩短响应时间，并发收集，低停顿</span><br><span class="line"><span class="attribute">-XX</span>:+UseParNewGC 并发收集新生代的垃圾</span><br><span class="line"><span class="attribute">-XX</span>:+CMSParallelRemarkEnabled 在使用UseParNewGC的情况下，尽量减少Mark标记时间</span><br><span class="line"><span class="attribute">-XX</span>:+UseCMSCompactAtFullCollection 使用并发收集器CMS时，开启对老年代的压缩，使得内存碎片减少</span><br><span class="line">-XX:LargePageSizeInBytes=128M 内存分页大小对性能的提升（操作系统）</span><br><span class="line"><span class="attribute">-XX</span>:+UseFastAccessorMethods get/set方法转成本地代码</span><br><span class="line">-Djava.awt.headless=true 修复Linux下tomcat处理图表时可能产生的一个bug</span><br></pre></td></tr></table></figure><ul><li><p>-Xms的内存值如何选择：</p><ul><li><p>根据实际业务来定，先查看服务器上部署了多少个Java应用，再来选择</p></li><li><p>例如：服务器内存64g，只部署了一个tomcat应用，那么可以设置-Xms的值接近64g，以达到内存最大利用，但是要注意设置前提：仅部署一个tomcat，如果部署了多个应用，则要根据实际业务来权衡</p></li><li><p>例如，一些业务中的实现需要频繁new对象的，则可以分配较大的eden区内存（调整-XX:NewRatio=n ，新老年代内存比例），以满足业务需求</p></li><li><p>而另一些业务服务需要不断的运行，老年代上对象占用较多，则可以分配较大的old区内存</p></li></ul></li></ul><ul><li>-XX:PermSize -XX:MaxPermSize值如何选择：当程序中类信息比较多的时候（类信息存在永久代），可适当调大永久代的内存空间，如：Eclipse启动速度慢，可以调大永久代内存大小，使得启动速度变快</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JVM内存结构&quot;&gt;&lt;a href=&quot;#JVM内存结构&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构&quot;&gt;&lt;/a&gt;JVM内存结构&lt;/h3&gt;&lt;p&gt;根据《Java虚拟机规范(Java SE 7版)》规定，Java虚拟机内存结构可划分为以下区域：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/jvm1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;程序计数器&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序计数器是一块较小的内存空间，可看作是当前线程所执行的字节码的行号指示器。在虚拟机概念模型里，字节码解释器工作时就是通过改变该计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖该计数器来完成。&lt;/li&gt;
&lt;li&gt;JVM中多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。即在任何时刻，CPU只会执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，该内存为线程私有。&lt;/li&gt;
&lt;li&gt;如果线程正在执行一个Java方法，则PC记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法，则PC值为Undefined，该内存区域是唯一一个没用OOM的区域。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;虚拟机栈&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的时候会创建一个栈帧，用来存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用至执行完成的过程对应着一个栈帧在虚拟机栈中入栈到出栈的过程.&lt;/li&gt;
&lt;li&gt;局部变量表：存放编译期可知的各种基本数据类型(如Boolean、byte、char、short、int、float、long、double)、对象引用类型（如：引用指针、句柄等）。局部变量表所需内存空间在编译期间完成分配，即进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是确定的，在方法运行期间不会改变局部变量表的大小。&lt;/li&gt;
&lt;li&gt;异常情况：&lt;ul&gt;
&lt;li&gt;StackOverflowError异常：线程请求的栈深度大于虚拟机所允许的深度时，会抛出栈上溢异常&lt;/li&gt;
&lt;li&gt;OutOfMemoryError异常：虚拟机栈动态扩展时无法申请到足够的内存，会抛出内存溢出异常&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;本地方法栈&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发挥的作用与虚拟机栈类似，区别在于虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务，如Java访问C语言的方法、汇编程序等。&lt;/li&gt;
&lt;li&gt;异常情况：与虚拟机栈一样。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆是Java所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建，用于存放对象实例，也是垃圾收集器管理的主要区域。&lt;/li&gt;
&lt;li&gt;根据GC分代收集算法，堆可细分为：新生代和老年代；新生代又分为Eden区、Survivor区（from,to）从内存分配的角度看，线程共享的Java堆可划分出多个线程私有的分配缓冲区（TLAB：Thread Local Allocation Buffer)&lt;/li&gt;
&lt;li&gt;堆内存仅要逻辑上连续即可，物理上不连续也可以，如果在堆中没有内存完成实例分配。并且堆也无法再扩展时，则会抛出OOM异常&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;方法区&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与堆一样，方法区是各线程共享的，用于存储已被虚拟机 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据&lt;/li&gt;
&lt;li&gt;对于开发者来说，该区又称为“永久代”Permanent Generation，当方法区无法满足内存分配时，将抛出OOM异常&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="jvm" scheme="blog.ppjys.cn/categories/jvm/"/>
    
    
      <category term="jvm java基础" scheme="blog.ppjys.cn/tags/jvm-java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Otter 跨机房数据同步方案</title>
    <link href="blog.ppjys.cn/2020/05/29/20200529_Otter%E8%B7%A8%E6%9C%BA%E6%88%BF%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/"/>
    <id>blog.ppjys.cn/2020/05/29/20200529_Otter跨机房数据同步方案/</id>
    <published>2020-05-29T12:37:35.000Z</published>
    <updated>2020-05-29T11:39:56.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Otter-跨机房数据同步方案"><a href="#Otter-跨机房数据同步方案" class="headerlink" title="Otter 跨机房数据同步方案"></a>Otter 跨机房数据同步方案</h1><p>由于项目需求要把整个线上产品迁移上云，从自建IDC机房的所有服务都迁移至腾讯云。原先考虑采用腾讯云的DTS服务,但是发现他们产品属于公测阶段，在加上腾讯云RDS服务居然没有提供外网访问的tls安全传输保证，这样如果一旦开启外网地址，可能导致数据库被入侵或者攻击。基于以上考虑点，在加上我们同机房数据迁移采用otter的定制版，最终我们决定改造otter，支持跨机房安全传输。<a href="https://ppj19891020.github.io/2019/06/12/Otter%E6%94%B9%E9%80%A0%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">otter的改造点详细请查看文章</a></p><h2 id="Otter工作原理"><a href="#Otter工作原理" class="headerlink" title="Otter工作原理"></a>Otter工作原理</h2><p><img src="https://camo.githubusercontent.com/2988fbbc7ddfe94ed027cd71720b1ffa5912a635/687474703a2f2f646c322e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038382f313138392f64343230636131342d326438302d336435352d383038312d6239303833363036613830312e6a7067" alt="otter工作原理"></p><p>说明：</p><ol><li>基于Canal开源产品，获取数据库增量日志数据。</li><li>典型管理系统架构，manager(web管理)+node(工作节点)<ol><li>manager运行时推送同步配置到node节点</li><li>node节点将同步状态反馈到manager上</li></ol></li><li>基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作。</li></ol><h2 id="跨机房原理"><a href="#跨机房原理" class="headerlink" title="跨机房原理"></a>跨机房原理</h2><p><img src="https://camo.githubusercontent.com/666157bf4b1bf4a0e24b138cfb22ab69c429a7a0/687474703a2f2f646c322e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038382f313938312f35333639623533332d356239612d333265362d626263302d3134633430373138386539332e6a7067" alt="跨机房原理"></p><p>说明：</p><ol><li>数据涉及网络传输，S/E/T/L几个阶段会分散在2个或者更多Node节点上，多个Node之间通过zookeeper进行协同工作 (一般是Select和Extract在一个机房的Node，Transform/Load落在另一个机房的Node)。</li><li>node节点可以有failover / loadBalancer. (每个机房的Node节点，都可以是集群，一台或者多台机器)。</li></ol><a id="more"></a><h2 id="跨机房传输开源方案"><a href="#跨机房传输开源方案" class="headerlink" title="跨机房传输开源方案"></a>跨机房传输开源方案</h2><ol><li>Node都需要开通3个外网端口，分别是dubbo通信默认2088端口、http下载服务默认2089端口和mbean服务默认2090端口；</li><li>数据源需要公网ip访问；</li><li>zookeeper需要实现跨机房数据同步；</li><li>manager节点需要提供公网ip，用于跨机房node注册到manager节点；</li></ol><p>由于开源方案需要node提供多个端口和数据库需公网访问，目前我们采用的rds云服务不支持ssl协议，故如果采用开源跨机房方案，会造成rds和业务服务器的安全漏洞，因此我们考虑适合公司的安全跨机房传输。</p><h2 id="安全传输改造点"><a href="#安全传输改造点" class="headerlink" title="安全传输改造点"></a>安全传输改造点</h2><p>   <img src="/images/otter_cross.png" alt="otter安全传输改造"></p><ol><li><p>跨机房zk采用ip隧道网络打通，最外层由运维增加tls加密传输通行，跨机房的Node本地增加端口映射；</p></li><li><p>IDC机房的manager节点调用跨机房Node节点也是通过ip隧道打通（node提供dubbo接口），跨机房Node启用外部ip，由本地端口映射转到隧道入口；</p></li><li><p>跨机房node节点调用IDC机房的manager节点采用ip隧道打通（manager提供dubbo接口），跨机房Node的配置文件otter.properties调整otter.manager.address配置，由本地端口映射到隧道入口；</p></li><li><p>跨机房node相互通信采用https通信，数据文件加密，修改Pipeline配置，将传输模式配置为http，文件传输加密配置为true，启用公网同步（需改造构造下载地址映射转换）；</p></li></ol><h2 id="全量同步改造点"><a href="#全量同步改造点" class="headerlink" title="全量同步改造点"></a>全量同步改造点</h2><p>由于全量同步我们是基于otter社区版本的自由门改造的，当在跨机房环境，逆向全量同步出现retl库和源库不在同一个机房，导致Node的extract阶段不能反查源库。考虑到逆向全量一般很少使用可以不解决，后来发现数据校验的一键修复功能也是采用了全量同步的原理来进行数据修正，最终我们决定直接将node的extract阶段给抽离出来，可以由用户选择。</p><p>   <img src="/images/otter_pipeline.png" alt="otter安全传输改造"></p><h2 id="数据校验改造点"><a href="#数据校验改造点" class="headerlink" title="数据校验改造点"></a>数据校验改造点</h2><p>由于之前的数据校验是通过manager阶段，分别想源库和目标库查询crc校验码来比较，但是在跨机房的场景下，manager节点不能直连跨机房的数据源，这里我们改造根据查询源库的情况下，直接查看select的node是否启用外网ip来判断该数据库是否是跨机房，然后提供对应的node上增加批量查询校验码的dubbo服务，由manager节点直接查询数据库或者调用对用node的dubbo服务来做比对。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过安全传输改造、全量同步改造、数据校验改造，otter跨机房传输可以支持源库跨机房、目标库跨机房、源库和目标库跨机房场景。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Otter-跨机房数据同步方案&quot;&gt;&lt;a href=&quot;#Otter-跨机房数据同步方案&quot; class=&quot;headerlink&quot; title=&quot;Otter 跨机房数据同步方案&quot;&gt;&lt;/a&gt;Otter 跨机房数据同步方案&lt;/h1&gt;&lt;p&gt;由于项目需求要把整个线上产品迁移上云，从自建IDC机房的所有服务都迁移至腾讯云。原先考虑采用腾讯云的DTS服务,但是发现他们产品属于公测阶段，在加上腾讯云RDS服务居然没有提供外网访问的tls安全传输保证，这样如果一旦开启外网地址，可能导致数据库被入侵或者攻击。基于以上考虑点，在加上我们同机房数据迁移采用otter的定制版，最终我们决定改造otter，支持跨机房安全传输。&lt;a href=&quot;https://ppj19891020.github.io/2019/06/12/Otter%E6%94%B9%E9%80%A0%E5%AE%9E%E8%B7%B5/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;otter的改造点详细请查看文章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Otter工作原理&quot;&gt;&lt;a href=&quot;#Otter工作原理&quot; class=&quot;headerlink&quot; title=&quot;Otter工作原理&quot;&gt;&lt;/a&gt;Otter工作原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/2988fbbc7ddfe94ed027cd71720b1ffa5912a635/687474703a2f2f646c322e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038382f313138392f64343230636131342d326438302d336435352d383038312d6239303833363036613830312e6a7067&quot; alt=&quot;otter工作原理&quot;&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于Canal开源产品，获取数据库增量日志数据。&lt;/li&gt;
&lt;li&gt;典型管理系统架构，manager(web管理)+node(工作节点)&lt;ol&gt;
&lt;li&gt;manager运行时推送同步配置到node节点&lt;/li&gt;
&lt;li&gt;node节点将同步状态反馈到manager上&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;跨机房原理&quot;&gt;&lt;a href=&quot;#跨机房原理&quot; class=&quot;headerlink&quot; title=&quot;跨机房原理&quot;&gt;&lt;/a&gt;跨机房原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/666157bf4b1bf4a0e24b138cfb22ab69c429a7a0/687474703a2f2f646c322e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038382f313938312f35333639623533332d356239612d333265362d626263302d3134633430373138386539332e6a7067&quot; alt=&quot;跨机房原理&quot;&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据涉及网络传输，S/E/T/L几个阶段会分散在2个或者更多Node节点上，多个Node之间通过zookeeper进行协同工作 (一般是Select和Extract在一个机房的Node，Transform/Load落在另一个机房的Node)。&lt;/li&gt;
&lt;li&gt;node节点可以有failover / loadBalancer. (每个机房的Node节点，都可以是集群，一台或者多台机器)。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="otter" scheme="blog.ppjys.cn/categories/otter/"/>
    
    
      <category term="性能压测" scheme="blog.ppjys.cn/tags/%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>seata客户端响应超时问题</title>
    <link href="blog.ppjys.cn/2020/03/13/20200313_seata%E5%93%8D%E5%BA%94%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>blog.ppjys.cn/2020/03/13/20200313_seata响应超时问题排查/</id>
    <published>2020-03-13T05:07:35.000Z</published>
    <updated>2020-04-03T11:00:33.032Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近我们在性能压测seata Tcc模式中发现了一些问题，<a href="https://github.com/seata/seata/issues/2431" target="_blank" rel="noopener">seata issue</a>：</p><ol><li><p>业务方tps稳定在200tps左右，但是实际去除seata依赖，tps达到了2000左右；</p></li><li><p>性能长时间压测几个小时之后，发现tm端出现了rpc 30s超时问题，导致所有的请求都超时，业务无法响应；</p><p><strong>seata性能压测</strong></p><p><img src="/images/seata_jmeter.png" alt="seata性能压测结果"></p><p><strong>TM端报错</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2020-01-16 19:00:19.956 ERROR 19765 --- [o-8873-exec-288] i.s.core.rpc.netty.AbstractRpcRemoting   : wait response error:cost 30000 ms,ip:192.168.202.137:8091,request:timeout=60000,transactionName=test(javax.servlet.http.HttpServletRequest, com.fly.seata.dto.OrderDTO)</span><br><span class="line"><span class="selector-tag">2020-01-16</span> <span class="selector-tag">19</span><span class="selector-pseudo">:00</span><span class="selector-pseudo">:19.960</span>  <span class="selector-tag">WARN</span> <span class="selector-tag">19765</span> <span class="selector-tag">---</span> <span class="selector-attr">[o-8873-exec-288]</span> <span class="selector-tag">i</span><span class="selector-class">.s</span><span class="selector-class">.tm</span><span class="selector-class">.api</span><span class="selector-class">.DefaultFailureHandlerImpl</span>     : <span class="selector-tag">Failed</span> <span class="selector-tag">to</span> <span class="selector-tag">begin</span> <span class="selector-tag">transaction</span>.</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.core</span><span class="selector-class">.exception</span><span class="selector-class">.TmTransactionException</span>: <span class="selector-tag">RPC</span> <span class="selector-tag">timeout</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.tm</span><span class="selector-class">.DefaultTransactionManager</span><span class="selector-class">.syncCall</span>(DefaultTransactionManager.<span class="attribute">java</span>:<span class="number">97</span>) ~<span class="selector-attr">[seata-all-1.0.0.jar!/:1.0.0]</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.tm</span><span class="selector-class">.DefaultTransactionManager</span><span class="selector-class">.begin</span>(DefaultTransactionManager.<span class="attribute">java</span>:<span class="number">53</span>) ~<span class="selector-attr">[seata-all-1.0.0.jar!/:1.0.0]</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.tm</span><span class="selector-class">.api</span><span class="selector-class">.DefaultGlobalTransaction</span><span class="selector-class">.begin</span>(DefaultGlobalTransaction.<span class="attribute">java</span>:<span class="number">102</span>) ~<span class="selector-attr">[seata-all-1.0.0.jar!/:1.0.0]</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.tm</span><span class="selector-class">.api</span><span class="selector-class">.TransactionalTemplate</span><span class="selector-class">.beginTransaction</span>(TransactionalTemplate.<span class="attribute">java</span>:<span class="number">123</span>) ~<span class="selector-attr">[seata-all-1.0.0.jar!/:1.0.0]</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.tm</span><span class="selector-class">.api</span><span class="selector-class">.TransactionalTemplate</span><span class="selector-class">.execute</span>(TransactionalTemplate.<span class="attribute">java</span>:<span class="number">58</span>) ~<span class="selector-attr">[seata-all-1.0.0.jar!/:1.0.0]</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.spring</span><span class="selector-class">.annotation</span><span class="selector-class">.GlobalTransactionalInterceptor</span><span class="selector-class">.handleGlobalTransaction</span>(GlobalTransactionalInterceptor.<span class="attribute">java</span>:<span class="number">106</span>) <span class="selector-attr">[seata-all-1.0.0.jar!/:1.0.0]</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.spring</span><span class="selector-class">.annotation</span><span class="selector-class">.GlobalTransactionalInterceptor</span><span class="selector-class">.invoke</span>(GlobalTransactionalInterceptor.<span class="attribute">java</span>:<span class="number">81</span>) <span class="selector-attr">[seata-all-1.0.0.jar!/:1.0.0]</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.aop</span><span class="selector-class">.framework</span><span class="selector-class">.ReflectiveMethodInvocation</span><span class="selector-class">.proceed</span>(ReflectiveMethodInvocation.<span class="attribute">java</span>:<span class="number">185</span>) <span class="selector-attr">[spring-aop-5.0.5.RELEASE.jar!/:5.0.5.RELEASE]</span></span><br><span class="line">at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689) [spring-aop-5.0.5.RELEASE.jar!/:5.0.5.RELEASE]</span><br><span class="line">at com.fly.seata.controller.TestController$$EnhancerBySpringCGLIB$$63e8794f.test(&lt;generated&gt;) [classes!/:1.0-SNAPSHOT]</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">sun</span><span class="selector-class">.reflect</span><span class="selector-class">.GeneratedMethodAccessor80</span><span class="selector-class">.invoke</span>(Unknown Source) ~<span class="selector-attr">[na:na]</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">sun</span><span class="selector-class">.reflect</span><span class="selector-class">.DelegatingMethodAccessorImpl</span><span class="selector-class">.invoke</span>(DelegatingMethodAccessorImpl.<span class="attribute">java</span>:<span class="number">43</span>) ~<span class="selector-attr">[na:1.8.0_181]</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span><span class="selector-class">.invoke</span>(Method.<span class="attribute">java</span>:<span class="number">498</span>) ~<span class="selector-attr">[na:1.8.0_181]</span></span><br></pre></td></tr></table></figure><p><strong>线程栈信息</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">"ServerHandlerThread_1_500" #86 daemon prio=5 os_prio=0 tid=0x00007fe594011800 nid=0x6138 waiting on condition [0x00007fe6507c0000]</span><br><span class="line">   <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">WAITING</span> (parking)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">sun</span><span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.park</span>(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x00000000c6f363c8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.LockSupport</span><span class="selector-class">.park</span>(LockSupport.<span class="attribute">java</span>:<span class="number">175</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.LinkedBlockingQueue</span><span class="selector-class">.take</span>(LinkedBlockingQueue.<span class="attribute">java</span>:<span class="number">442</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.getTask</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1074</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.runWorker</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1134</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">"ServerHandlerThread_1_500" #85 daemon prio=5 os_prio=0 tid=0x00007fe580013000 nid=0x6137 waiting on condition [0x00007fe650841000]</span><br><span class="line">   <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">WAITING</span> (parking)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">sun</span><span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.park</span>(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x00000000c6f363c8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.LockSupport</span><span class="selector-class">.park</span>(LockSupport.<span class="attribute">java</span>:<span class="number">175</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.LinkedBlockingQueue</span><span class="selector-class">.take</span>(LinkedBlockingQueue.<span class="attribute">java</span>:<span class="number">442</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.getTask</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1074</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.runWorker</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1134</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">"ServerHandlerThread_1_500" #84 daemon prio=5 os_prio=0 tid=0x00007fe580011000 nid=0x6136 waiting on condition [0x00007fe6508c2000]</span><br><span class="line">   <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">WAITING</span> (parking)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">sun</span><span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.park</span>(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x00000000c6f363c8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.LockSupport</span><span class="selector-class">.park</span>(LockSupport.<span class="attribute">java</span>:<span class="number">175</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.LinkedBlockingQueue</span><span class="selector-class">.take</span>(LinkedBlockingQueue.<span class="attribute">java</span>:<span class="number">442</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.getTask</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1074</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.runWorker</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1134</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">"ServerHandlerThread_1_500" #83 daemon prio=5 os_prio=0 tid=0x00007fe5a4080000 nid=0x6135 waiting on condition [0x00007fe650943000]</span><br><span class="line">   <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">WAITING</span> (parking)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">sun</span><span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.park</span>(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x00000000c6f363c8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.LockSupport</span><span class="selector-class">.park</span>(LockSupport.<span class="attribute">java</span>:<span class="number">175</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.LinkedBlockingQueue</span><span class="selector-class">.take</span>(LinkedBlockingQueue.<span class="attribute">java</span>:<span class="number">442</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.getTask</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1074</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.runWorker</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1134</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">"ServerHandlerThread_1_500" #82 daemon prio=5 os_prio=0 tid=0x00007fe594010000 nid=0x6134 waiting on condition [0x00007fe6509c4000]</span><br><span class="line">   <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">WAITING</span> (parking)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">sun</span><span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.park</span>(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x00000000c6f363c8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.LockSupport</span><span class="selector-class">.park</span>(LockSupport.<span class="attribute">java</span>:<span class="number">175</span>)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.LinkedBlockingQueue</span><span class="selector-class">.take</span>(LinkedBlockingQueue.<span class="attribute">java</span>:<span class="number">442</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.getTask</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1074</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.runWorker</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1134</span>)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br></pre></td></tr></table></figure><p><strong>出现超时之后，server端和Tm端、Rm端有建立连接的</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pangpeijie@mdw1:/home/dxy/seata-server/bin$ lsof -i:8091</span><br><span class="line"><span class="selector-tag">COMMAND</span>   <span class="selector-tag">PID</span>       <span class="selector-tag">USER</span>   <span class="selector-tag">FD</span>   <span class="selector-tag">TYPE</span>     <span class="selector-tag">DEVICE</span> <span class="selector-tag">SIZE</span>/<span class="selector-tag">OFF</span> <span class="selector-tag">NODE</span> <span class="selector-tag">NAME</span></span><br><span class="line"><span class="selector-tag">java</span>    <span class="selector-tag">24684</span> <span class="selector-tag">pangpeijie</span>    <span class="selector-tag">6u</span>  <span class="selector-tag">IPv4</span> <span class="selector-tag">1673279856</span>      <span class="selector-tag">0t0</span>  <span class="selector-tag">TCP</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span><span class="selector-pseudo">:8091-</span>&gt;<span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span><span class="selector-pseudo">:53212</span> (ESTABLISHED)</span><br><span class="line"><span class="selector-tag">java</span>    <span class="selector-tag">24684</span> <span class="selector-tag">pangpeijie</span>  <span class="selector-tag">270u</span>  <span class="selector-tag">IPv4</span> <span class="selector-tag">1591859785</span>      <span class="selector-tag">0t0</span>  <span class="selector-tag">TCP</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span><span class="selector-pseudo">:8091-</span>&gt;<span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span><span class="selector-pseudo">:44208</span> (ESTABLISHED)</span><br><span class="line"><span class="selector-tag">java</span>    <span class="selector-tag">24684</span> <span class="selector-tag">pangpeijie</span>  <span class="selector-tag">272u</span>  <span class="selector-tag">IPv4</span> <span class="selector-tag">1548003634</span>      <span class="selector-tag">0t0</span>  <span class="selector-tag">TCP</span> *<span class="selector-pseudo">:8091</span> (LISTEN)</span><br><span class="line"><span class="selector-tag">java</span>    <span class="selector-tag">24684</span> <span class="selector-tag">pangpeijie</span>  <span class="selector-tag">275u</span>  <span class="selector-tag">IPv4</span> <span class="selector-tag">1571258316</span>      <span class="selector-tag">0t0</span>  <span class="selector-tag">TCP</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span><span class="selector-pseudo">:8091-</span>&gt;<span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span><span class="selector-pseudo">:43734</span> (ESTABLISHED)</span><br><span class="line"><span class="selector-tag">java</span>    <span class="selector-tag">24684</span> <span class="selector-tag">pangpeijie</span>  <span class="selector-tag">276u</span>  <span class="selector-tag">IPv4</span> <span class="selector-tag">1571258317</span>      <span class="selector-tag">0t0</span>  <span class="selector-tag">TCP</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span><span class="selector-pseudo">:8091-</span>&gt;<span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span><span class="selector-pseudo">:43738</span> (ESTABLISHED)</span><br><span class="line"><span class="selector-tag">java</span>    <span class="selector-tag">24684</span> <span class="selector-tag">pangpeijie</span>  <span class="selector-tag">278u</span>  <span class="selector-tag">IPv4</span> <span class="selector-tag">1571258320</span>      <span class="selector-tag">0t0</span>  <span class="selector-tag">TCP</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span><span class="selector-pseudo">:8091-</span>&gt;<span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span><span class="selector-pseudo">:43806</span> (ESTABLISHED)</span><br><span class="line"><span class="selector-tag">java</span>    <span class="selector-tag">24684</span> <span class="selector-tag">pangpeijie</span>  <span class="selector-tag">280u</span>  <span class="selector-tag">IPv4</span> <span class="selector-tag">1571258321</span>      <span class="selector-tag">0t0</span>  <span class="selector-tag">TCP</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span><span class="selector-pseudo">:8091-</span>&gt;<span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span><span class="selector-pseudo">:43814</span> (ESTABLISHED)</span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pangpeijie@mdw2:~$ netstat -ano|grep "192.168.202.137:8091"</span><br><span class="line"><span class="selector-tag">tcp</span>        <span class="selector-tag">0</span>      <span class="selector-tag">0</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span><span class="selector-pseudo">:43814</span>   <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span><span class="selector-pseudo">:8091</span>    <span class="selector-tag">ESTABLISHED</span> <span class="selector-tag">keepalive</span> (<span class="number">2398.82</span>/<span class="number">0</span>/<span class="number">0</span>)</span><br><span class="line"><span class="selector-tag">tcp</span>        <span class="selector-tag">0</span>      <span class="selector-tag">0</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span><span class="selector-pseudo">:53212</span>   <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span><span class="selector-pseudo">:8091</span>    <span class="selector-tag">ESTABLISHED</span> <span class="selector-tag">keepalive</span> (<span class="number">4753.92</span>/<span class="number">0</span>/<span class="number">0</span>)</span><br><span class="line"><span class="selector-tag">tcp</span>        <span class="selector-tag">0</span>      <span class="selector-tag">0</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span><span class="selector-pseudo">:43738</span>   <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span><span class="selector-pseudo">:8091</span>    <span class="selector-tag">ESTABLISHED</span> <span class="selector-tag">keepalive</span> (<span class="number">2396.00</span>/<span class="number">0</span>/<span class="number">0</span>)</span><br><span class="line"><span class="selector-tag">tcp</span>        <span class="selector-tag">0</span>      <span class="selector-tag">0</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span><span class="selector-pseudo">:43806</span>   <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span><span class="selector-pseudo">:8091</span>    <span class="selector-tag">ESTABLISHED</span> <span class="selector-tag">keepalive</span> (<span class="number">2397.65</span>/<span class="number">0</span>/<span class="number">0</span>)</span><br><span class="line"><span class="selector-tag">tcp</span>        <span class="selector-tag">0</span>      <span class="selector-tag">0</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span><span class="selector-pseudo">:44208</span>   <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span><span class="selector-pseudo">:8091</span>    <span class="selector-tag">ESTABLISHED</span> <span class="selector-tag">keepalive</span> (<span class="number">4107.33</span>/<span class="number">0</span>/<span class="number">0</span>)</span><br><span class="line"><span class="selector-tag">tcp</span>        <span class="selector-tag">0</span>      <span class="selector-tag">0</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span><span class="selector-pseudo">:43734</span>   <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span><span class="selector-pseudo">:8091</span>    <span class="selector-tag">ESTABLISHED</span> <span class="selector-tag">keepalive</span> (<span class="number">2396.14</span>/<span class="number">0</span>/<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>其他报错信息请查看github的<a href="https://github.com/seata/seata/issues/2193" target="_blank" rel="noopener">issue</a></strong></p></li></ol><a id="more"></a><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><h3 id="server端服务器负载"><a href="#server端服务器负载" class="headerlink" title="server端服务器负载"></a>server端服务器负载</h3><p>刚开始我们怀疑是seata-server的服务器压力太大，导致服务端处理能力低下或者负载过高导致频繁fullgc，结果发现server端的服务器负载和gc情况正常，如下图</p><p><strong>服务器负载情况，server端服务器的配置是8核16G内存配置</strong></p><p><img src="/images/seata2.png" alt="服务器负载"></p><p><strong>server端gc情况</strong></p><p><img src="/images/seata3.png" alt="gc情况"></p><p><strong>数据库连接情况</strong>,看起来绝大多数的数据库连接都是sleep状态，觉得数据库也不应该存在瓶颈</p><p><img src="/images/seata4.png" alt="数据库连接情况"></p><h3 id="网络io瓶颈"><a href="#网络io瓶颈" class="headerlink" title="网络io瓶颈"></a>网络io瓶颈</h3><p>和运维沟通后，server和tm端是属于同一台宿主机，用的是虚拟网卡，应该是千兆网卡(物理网卡是千兆网卡)，所以不应该网络io成瓶颈。</p><p><img src="/images/seata8.png" alt="网卡信息"></p><p><img src="/images/seata9.png" alt="流量信息"></p><h3 id="优化参数"><a href="#优化参数" class="headerlink" title="优化参数"></a>优化参数</h3><h4 id="client端timeout时间"><a href="#client端timeout时间" class="headerlink" title="client端timeout时间"></a>client端timeout时间</h4><p>总觉得如果绝大多数服务端响应超时处理总导致总体的服务雪崩问题，将客户端发送服务端消息的超时时间由原先的30s调整到2s。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientConfig</span> <span class="keyword">extends</span> <span class="title">NettyBaseConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RPC_REQUEST_TIMEOUT = <span class="number">30</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="client端netty的处理线程调大"><a href="#client端netty的处理线程调大" class="headerlink" title="client端netty的处理线程调大"></a>client端netty的处理线程调大</h4><p>由于TM和RM端是采用一个channel连接，连接池的线程数配置为当前服务器cpu核数，我们将这个客户端的处理线程调整到100个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientConfig</span> <span class="keyword">extends</span> <span class="title">NettyBaseConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> clientWorkerThreads = WORKER_THREAD_SIZE;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="server端netty的处理线程数调大"><a href="#server端netty的处理线程数调大" class="headerlink" title="server端netty的处理线程数调大"></a>server端netty的处理线程数调大</h4><p>将server端对应的业务处理线程池messageExecutor调大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RpcMessage) &#123;</span><br><span class="line">    <span class="keyword">final</span> RpcMessage rpcMessage = (RpcMessage) msg;</span><br><span class="line">    <span class="keyword">if</span> (rpcMessage.getMessageType() == ProtocolConstants.MSGTYPE_RESQUEST</span><br><span class="line">        || rpcMessage.getMessageType() == ProtocolConstants.MSGTYPE_RESQUEST_ONEWAY) &#123;</span><br><span class="line">      <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">        LOGGER.debug(String.format(<span class="string">"%s msgId:%s, body:%s"</span>, <span class="keyword">this</span>, rpcMessage.getId(), rpcMessage.getBody()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        messageExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              dispatch(rpcMessage, ctx);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">              LOGGER.error(FrameworkErrorCode.NetDispatch.getErrCode(), th.getMessage(), th);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        LOGGER.error(FrameworkErrorCode.ThreadPoolFull.getErrCode(),</span><br><span class="line">                     <span class="string">"thread pool is full, current max pool size is "</span> + messageExecutor.getActiveCount());</span><br><span class="line">        <span class="keyword">if</span> (allowDumpStack) &#123;</span><br><span class="line">          String name = ManagementFactory.getRuntimeMXBean().getName();</span><br><span class="line">          String pid = name.split(<span class="string">"@"</span>)[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">int</span> idx = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"jstack "</span> + pid + <span class="string">" &gt;d:/"</span> + idx + <span class="string">".log"</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException exx) &#123;</span><br><span class="line">            LOGGER.error(exx.getMessage());</span><br><span class="line">          &#125;</span><br><span class="line">          allowDumpStack = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      MessageFuture messageFuture = futures.remove(rpcMessage.getId());</span><br><span class="line">      <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">        LOGGER.debug(String</span><br><span class="line">                     .format(<span class="string">"%s msgId:%s, future :%s, body:%s"</span>, <span class="keyword">this</span>, rpcMessage.getId(), messageFuture,</span><br><span class="line">                             rpcMessage.getBody()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (messageFuture != <span class="keyword">null</span>) &#123;</span><br><span class="line">        messageFuture.setResultMessage(rpcMessage.getBody());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          messageExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                dispatch(rpcMessage, ctx);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">                LOGGER.error(FrameworkErrorCode.NetDispatch.getErrCode(), th.getMessage(), th);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">          LOGGER.error(FrameworkErrorCode.ThreadPoolFull.getErrCode(),</span><br><span class="line">                       <span class="string">"thread pool is full, current max pool size is "</span> + messageExecutor.getActiveCount());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调整client端批量消息发送"><a href="#调整client端批量消息发送" class="headerlink" title="调整client端批量消息发送"></a>调整client端批量消息发送</h4><p>调整客户端参数,发现后端是1个线程1ms将消息合并成一条然后发送给服务端</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transport</span> &#123;</span><br><span class="line">  # <span class="selector-tag">the</span> <span class="selector-tag">client</span> <span class="selector-tag">batch</span> <span class="selector-tag">send</span> <span class="selector-tag">request</span> <span class="selector-tag">enable</span></span><br><span class="line">  enableClientBatchSendRequest = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过调整这些参数后，发现还是出问题，发现在压测十几分钟就能复现问题，一直没搞明白是啥原因？</p><h3 id="分析线程dump信息"><a href="#分析线程dump信息" class="headerlink" title="分析线程dump信息"></a>分析线程dump信息</h3><p>发现所有的server端线程都是在waiting，等待一个queue的锁，看起来也是就是server端根本没有消息堆积，所有的处理线程都在等待消息过来消费。</p><p><strong>处理线程阻塞</strong></p><p><img src="/images/seata5.png" alt="线程阻塞"></p><p><strong>线程cpu执行情况</strong></p><p><img src="/images/seata6.png" alt="线程cpu执行情况"></p><p><img src="/images/seata7.png" alt="线程情况"></p><p><img src="/images/seata10.png" alt="线程执行情况"></p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p><img src="/images/seata10.png" alt="线程执行情况"></p><p>通过最后一个线程监控，发现所有的瓶颈都在执行数据库压力下，然后查看了下server的数据库连接池的源码，默认的minconn为1，但是我们server上的配置只配置了maxconn最大连接数，这个最大连接数还是配置为100，理论上应该也没啥问题，就开始怀疑是不是dbcp数据源问题，然后就开始切换用druid数据源，其他配置项不变。经过一整晚的性能压测，tps达到了500多，比原先提高了4倍。</p><p><img src="/images/seata11.png" alt="性能压测"></p><p>然后我们就开始复盘为啥切换成dbcp性能会如此差，该版本也算是稳定版，毕竟很多公司生产环境在使用，接着我们就怀疑dbcp的参数配置问题，分析了源码终于找到了原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LoadLevel</span>(name = <span class="string">"dbcp"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbcpDataSourceGenerator</span> <span class="keyword">extends</span> <span class="title">AbstractDataSourceGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">generateDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BasicDataSource ds = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">        ds.setDriverClassName(getDriverClassName());</span><br><span class="line">        ds.setUrl(getUrl());</span><br><span class="line">        ds.setUsername(getUser());</span><br><span class="line">        ds.setPassword(getPassword());</span><br><span class="line">        ds.setInitialSize(getMinConn());</span><br><span class="line">        ds.setMaxActive(getMaxConn());</span><br><span class="line">        <span class="comment">// 最小空间链接和最大空闲连接</span></span><br><span class="line">        ds.setMinIdle(getMinConn());</span><br><span class="line">        ds.setMaxIdle(getMinConn());</span><br><span class="line">        ds.setMaxWait(<span class="number">5000</span>);</span><br><span class="line">        ds.setTimeBetweenEvictionRunsMillis(<span class="number">120000</span>);</span><br><span class="line">        ds.setNumTestsPerEvictionRun(<span class="number">1</span>);</span><br><span class="line">        ds.setTestWhileIdle(<span class="keyword">true</span>);</span><br><span class="line">        ds.setValidationQuery(getValidationQuery(getDBType()));</span><br><span class="line">        ds.setConnectionProperties(<span class="string">"useUnicode=yes;characterEncoding=utf8;socketTimeout=5000;connectTimeout=500"</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化dbcp数据源，配置了最小空闲数配置成1（默认），最大连接处配置成50（手动配置为50，默认是10），当并发量超过50时，在maxIdle和maxActive之间，因此当一个连接使用结束后由于当前连接数大于maxIdle连接无法被复用会被立即断开，新来一个请求也无法获取一个空闲的连接需要重新建立一个新的连接，由于断开连接的响应时间较慢，断开连接都在等待资源的释放，大量的线程出现排队，这样就出现了通过jstack看到的，线程被block住的现象。<a href="https://www.cnblogs.com/andashu/p/6441526.html" target="_blank" rel="noopener">参考博客文章</a></p><p>dbcp获取数据源逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create (if necessary) and return a connection to the database.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException if a database access error occurs</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> a database connection</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> createDataSource().getConnection();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> DataSource <span class="title">createDataSource</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"Data source is closed"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Return the pool if we have already created it</span></span><br><span class="line">      <span class="keyword">if</span> (dataSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> (dataSource);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// create factory which returns raw physical connections</span></span><br><span class="line">      ConnectionFactory driverConnectionFactory = createConnectionFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// create a pool for our connections</span></span><br><span class="line">      createConnectionPool();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set up statement pool, if desired</span></span><br><span class="line">      GenericKeyedObjectPoolFactory statementPoolFactory = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (isPoolPreparedStatements()) &#123;</span><br><span class="line">          statementPoolFactory = <span class="keyword">new</span> GenericKeyedObjectPoolFactory(<span class="keyword">null</span>,</span><br><span class="line">                      -<span class="number">1</span>, <span class="comment">// unlimited maxActive (per key)</span></span><br><span class="line">                      GenericKeyedObjectPool.WHEN_EXHAUSTED_FAIL,</span><br><span class="line">                      <span class="number">0</span>, <span class="comment">// maxWait</span></span><br><span class="line">                      <span class="number">1</span>, <span class="comment">// maxIdle (per key)</span></span><br><span class="line">                      maxOpenPreparedStatements);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set up the poolable connection factory</span></span><br><span class="line">      createPoolableConnectionFactory(driverConnectionFactory, statementPoolFactory, abandonedConfig);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Create and return the pooling data source to manage the connections</span></span><br><span class="line">      createDataSourceInstance();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; initialSize ; i++) &#123;</span><br><span class="line">              connectionPool.addObject();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> SQLNestedException(<span class="string">"Error preloading the connection pool"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> dataSource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get a db connection from the pool.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * If removeAbandoned=true, recovers db connections which</span></span><br><span class="line"><span class="comment">   * have been idle &gt; removeAbandonedTimeout and</span></span><br><span class="line"><span class="comment">   * getNumActive() &gt; getMaxActive() - 3 and</span></span><br><span class="line"><span class="comment">   * getNumIdle() &lt; 2</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Object jdbc Connection</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if an exception occurs retrieving a </span></span><br><span class="line"><span class="comment">   * connection from the pool</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">borrowObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (config != <span class="keyword">null</span></span><br><span class="line">              &amp;&amp; config.getRemoveAbandoned()</span><br><span class="line">              &amp;&amp; (getNumIdle() &lt; <span class="number">2</span>)</span><br><span class="line">              &amp;&amp; (getNumActive() &gt; getMaxActive() - <span class="number">3</span>) ) &#123;</span><br><span class="line">          removeAbandoned();</span><br><span class="line">      &#125;</span><br><span class="line">      Object obj = <span class="keyword">super</span>.borrowObject();</span><br><span class="line">      <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> AbandonedTrace) &#123;</span><br><span class="line">          ((AbandonedTrace) obj).setStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; config != <span class="keyword">null</span> &amp;&amp; config.getRemoveAbandoned()) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (trace) &#123;</span><br><span class="line">              trace.add(obj);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>但是这个也只能影响server端的吞吐量，也不应该所有的请求都超时，带着这个问题，我们再一次的将druid连接池的minconn调整为1，压测差不多半个多小时，还是出现了。这时我们想着从客户端的netty的解码器看下客户端是否有无接受到包，发现Object decoded = super.decode(ctx, in)返回为null。在每次出问题之后，客户端都会接收到响应包，但是解码都是为null，这是什么原因呢？</p><p><strong>io.seata.core.rpc.netty.v1.ProtocolV1Decoder#decode</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Object decoded = <span class="keyword">super</span>.decode(ctx, in);</span><br><span class="line">    <span class="keyword">if</span> (decoded <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">        ByteBuf frame = (ByteBuf) decoded;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> decodeFrame(frame);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Decode frame error!"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            frame.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decoded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始我们一直认为这个返回为null是由于tcp拆包之后的空包导致，后来继续远程debug代码，发现解码那边一直在丢弃包。</p><p><strong>io.netty.handler.codec.LengthFieldBasedFrameDecoder#decode(io.netty.channel.ChannelHandlerContext, io.netty.buffer.ByteBuf)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (discardingTooLongFrame) &#123;</span><br><span class="line">    discardingTooLongFrame(in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我们开始怀疑是不是服务端发送的包有问题呢，这时候发现server端发现编码异常</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">2020-03-25</span> <span class="selector-tag">17</span><span class="selector-pseudo">:06</span><span class="selector-pseudo">:43.587</span> <span class="selector-tag">ERROR</span><span class="selector-attr">[NettyServerNIOWorker_1_16]</span><span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.core</span><span class="selector-class">.rpc</span><span class="selector-class">.netty</span><span class="selector-class">.v1</span><span class="selector-class">.ProtocolV1Encoder</span><span class="selector-class">.encode</span><span class="selector-pseudo">:118</span> <span class="selector-tag">-Encode</span> <span class="selector-tag">request</span> <span class="selector-tag">error</span>!</span><br><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.NullPointerException</span>: <span class="selector-tag">null</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.serializer</span><span class="selector-class">.seata</span><span class="selector-class">.protocol</span><span class="selector-class">.transaction</span><span class="selector-class">.AbstractGlobalEndResponseCodec</span><span class="selector-class">.encode</span>(AbstractGlobalEndResponseCodec.<span class="attribute">java</span>:<span class="number">42</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.serializer</span><span class="selector-class">.seata</span><span class="selector-class">.protocol</span><span class="selector-class">.MergeResultMessageCodec</span><span class="selector-class">.encode</span>(MergeResultMessageCodec.<span class="attribute">java</span>:<span class="number">52</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.serializer</span><span class="selector-class">.seata</span><span class="selector-class">.SeataSerializer</span><span class="selector-class">.serialize</span>(SeataSerializer.<span class="attribute">java</span>:<span class="number">47</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.core</span><span class="selector-class">.rpc</span><span class="selector-class">.netty</span><span class="selector-class">.v1</span><span class="selector-class">.ProtocolV1Encoder</span><span class="selector-class">.encode</span>(ProtocolV1Encoder.<span class="attribute">java</span>:<span class="number">97</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.handler</span><span class="selector-class">.codec</span><span class="selector-class">.MessageToByteEncoder</span><span class="selector-class">.write</span>(MessageToByteEncoder.<span class="attribute">java</span>:<span class="number">107</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.AbstractChannelHandlerContext</span><span class="selector-class">.invokeWrite0</span>(AbstractChannelHandlerContext.<span class="attribute">java</span>:<span class="number">738</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.AbstractChannelHandlerContext</span><span class="selector-class">.invokeWrite</span>(AbstractChannelHandlerContext.<span class="attribute">java</span>:<span class="number">730</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.AbstractChannelHandlerContext</span><span class="selector-class">.write</span>(AbstractChannelHandlerContext.<span class="attribute">java</span>:<span class="number">816</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.AbstractChannelHandlerContext</span><span class="selector-class">.write</span>(AbstractChannelHandlerContext.<span class="attribute">java</span>:<span class="number">723</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.ChannelDuplexHandler</span><span class="selector-class">.write</span>(ChannelDuplexHandler.<span class="attribute">java</span>:<span class="number">106</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.AbstractChannelHandlerContext</span><span class="selector-class">.invokeWrite0</span>(AbstractChannelHandlerContext.<span class="attribute">java</span>:<span class="number">738</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.AbstractChannelHandlerContext</span><span class="selector-class">.invokeWrite</span>(AbstractChannelHandlerContext.<span class="attribute">java</span>:<span class="number">730</span>)</span><br><span class="line">at io.netty.channel.AbstractChannelHandlerContext.access$1900(AbstractChannelHandlerContext.java:38)</span><br><span class="line">at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write(AbstractChannelHandlerContext.java:1081)</span><br><span class="line">at io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:1128)</span><br><span class="line">at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:1070)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.AbstractEventExecutor</span><span class="selector-class">.safeExecute</span>(AbstractEventExecutor.<span class="attribute">java</span>:<span class="number">163</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.SingleThreadEventExecutor</span><span class="selector-class">.runAllTasks</span>(SingleThreadEventExecutor.<span class="attribute">java</span>:<span class="number">404</span>)</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.run</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">462</span>)</span><br></pre></td></tr></table></figure><p>接着看了编码器的代码，发现没有针对编码异常做throw或者close channel处理，此时就有理由怀疑是server端的编码异常，最终导致将有问题的数据包发送给客户端，由于tcp传输可能存在粘包和拆包问题，最终导致客户端解码的时候异常，最终所有的客户端请求无响应。</p><p><strong>io.seata.core.rpc.netty.v1.ProtocolV1Encoder</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolV1Encoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ProtocolV1Encoder.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RpcMessage) &#123;</span><br><span class="line">                RpcMessage rpcMessage = (RpcMessage) msg;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> fullLength = ProtocolConstants.V1_HEAD_LENGTH;</span><br><span class="line">                <span class="keyword">int</span> headLength = ProtocolConstants.V1_HEAD_LENGTH;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span> messageType = rpcMessage.getMessageType();</span><br><span class="line">                out.writeBytes(ProtocolConstants.MAGIC_CODE_BYTES);</span><br><span class="line">                out.writeByte(ProtocolConstants.VERSION);</span><br><span class="line">                <span class="comment">// full Length(4B) and head length(2B) will fix in the end. </span></span><br><span class="line">                out.writerIndex(out.writerIndex() + <span class="number">6</span>);</span><br><span class="line">                out.writeByte(messageType);</span><br><span class="line">                out.writeByte(rpcMessage.getCodec());</span><br><span class="line">                out.writeByte(rpcMessage.getCompressor());</span><br><span class="line">                out.writeInt(rpcMessage.getId());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// direct write head with zero-copy</span></span><br><span class="line">                Map&lt;String, String&gt; headMap = rpcMessage.getHeadMap();</span><br><span class="line">                <span class="keyword">if</span> (headMap != <span class="keyword">null</span> &amp;&amp; !headMap.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> headMapBytesLength = HeadMapSerializer.getInstance().encode(headMap, out);</span><br><span class="line">                    headLength += headMapBytesLength;</span><br><span class="line">                    fullLength += headMapBytesLength;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] bodyBytes = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (messageType != ProtocolConstants.MSGTYPE_HEARTBEAT_REQUEST</span><br><span class="line">                        &amp;&amp; messageType != ProtocolConstants.MSGTYPE_HEARTBEAT_RESPONSE) &#123;</span><br><span class="line">                    <span class="comment">// heartbeat has no body</span></span><br><span class="line">                    Serializer serializer = SerializerFactory.getSerializer(rpcMessage.getCodec());</span><br><span class="line">                    bodyBytes = serializer.serialize(rpcMessage.getBody());</span><br><span class="line">                    Compressor compressor = CompressorFactory.getCompressor(rpcMessage.getCompressor());</span><br><span class="line">                    bodyBytes = compressor.compress(bodyBytes);</span><br><span class="line">                    fullLength += bodyBytes.length;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bodyBytes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    out.writeBytes(bodyBytes);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// fix fullLength and headLength</span></span><br><span class="line">                <span class="keyword">int</span> writeIndex = out.writerIndex();</span><br><span class="line">                <span class="comment">// skip magic code(2B) + version(1B)</span></span><br><span class="line">                out.writerIndex(writeIndex - fullLength + <span class="number">3</span>);</span><br><span class="line">                out.writeInt(fullLength);</span><br><span class="line">                out.writeShort(headLength);</span><br><span class="line">                out.writerIndex(writeIndex);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Not support this class:"</span> + msg.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Encode request error!"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们修改了编码器，出现异常的时候关闭channel通道，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RpcMessage) &#123;</span><br><span class="line">            RpcMessage rpcMessage = (RpcMessage) msg;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> fullLength = ProtocolConstants.V1_HEAD_LENGTH;</span><br><span class="line">            <span class="keyword">int</span> headLength = ProtocolConstants.V1_HEAD_LENGTH;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span> messageType = rpcMessage.getMessageType();</span><br><span class="line">            out.writeBytes(ProtocolConstants.MAGIC_CODE_BYTES);</span><br><span class="line">            out.writeByte(ProtocolConstants.VERSION);</span><br><span class="line">            <span class="comment">// full Length(4B) and head length(2B) will fix in the end. </span></span><br><span class="line">            out.writerIndex(out.writerIndex() + <span class="number">6</span>);</span><br><span class="line">            out.writeByte(messageType);</span><br><span class="line">            out.writeByte(rpcMessage.getCodec());</span><br><span class="line">            out.writeByte(rpcMessage.getCompressor());</span><br><span class="line">            out.writeInt(rpcMessage.getId());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// direct write head with zero-copy</span></span><br><span class="line">            Map&lt;String, String&gt; headMap = rpcMessage.getHeadMap();</span><br><span class="line">            <span class="keyword">if</span> (headMap != <span class="keyword">null</span> &amp;&amp; !headMap.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">int</span> headMapBytesLength = HeadMapSerializer.getInstance().encode(headMap, out);</span><br><span class="line">                headLength += headMapBytesLength;</span><br><span class="line">                fullLength += headMapBytesLength;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] bodyBytes = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (messageType != ProtocolConstants.MSGTYPE_HEARTBEAT_REQUEST</span><br><span class="line">                    &amp;&amp; messageType != ProtocolConstants.MSGTYPE_HEARTBEAT_RESPONSE) &#123;</span><br><span class="line">                <span class="comment">// heartbeat has no body</span></span><br><span class="line">                Serializer serializer = SerializerFactory.getSerializer(rpcMessage.getCodec());</span><br><span class="line">                bodyBytes = serializer.serialize(rpcMessage.getBody());</span><br><span class="line">                Compressor compressor = CompressorFactory.getCompressor(rpcMessage.getCompressor());</span><br><span class="line">                bodyBytes = compressor.compress(bodyBytes);</span><br><span class="line">                fullLength += bodyBytes.length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bodyBytes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                out.writeBytes(bodyBytes);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// fix fullLength and headLength</span></span><br><span class="line">            <span class="keyword">int</span> writeIndex = out.writerIndex();</span><br><span class="line">            <span class="comment">// skip magic code(2B) + version(1B)</span></span><br><span class="line">            out.writerIndex(writeIndex - fullLength + <span class="number">3</span>);</span><br><span class="line">            out.writeInt(fullLength);</span><br><span class="line">            out.writeShort(headLength);</span><br><span class="line">            out.writerIndex(writeIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Not support this class:"</span> + msg.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">"Encode request error!"</span>, e);</span><br><span class="line">        <span class="keyword">final</span> String addrRemote = RemoteUtils.parseChannelRemoteAddr(ctx.channel());</span><br><span class="line">        ctx.channel().close().addListener(</span><br><span class="line">            <span class="keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="keyword">super</span> Void&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;? <span class="keyword">super</span> Void&gt; future)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    LOGGER.error(<span class="string">"Encode request error closeChannel: close the connection to remote address[&#123;&#125;] result: &#123;&#125;"</span>, addrRemote,</span><br><span class="line">                        future.isSuccess());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在压测24小时候无出现异常后我们才能肯定就是server端在高并发压力下可能存在编码问题，然后给社区提了<a href="https://github.com/seata/seata/issues/2458" target="_blank" rel="noopener">issue</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过这次排查过程，虽然花了很多时间去排查性能瓶颈，但是最终找到问题原因还是很惊喜，没想到居然是这个问题，中间也踩了很多坑，很多监控也是现学的，学习了问题的发现和查找思路，最重要的就是了解了没接触过的netty框架。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;最近我们在性能压测seata Tcc模式中发现了一些问题，&lt;a href=&quot;https://github.com/seata/seata/issues/2431&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;seata issue&lt;/a&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;业务方tps稳定在200tps左右，但是实际去除seata依赖，tps达到了2000左右；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;性能长时间压测几个小时之后，发现tm端出现了rpc 30s超时问题，导致所有的请求都超时，业务无法响应；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;seata性能压测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/seata_jmeter.png&quot; alt=&quot;seata性能压测结果&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TM端报错&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2020-01-16 19:00:19.956 ERROR 19765 --- [o-8873-exec-288] i.s.core.rpc.netty.AbstractRpcRemoting   : wait response error:cost 30000 ms,ip:192.168.202.137:8091,request:timeout=60000,transactionName=test(javax.servlet.http.HttpServletRequest, com.fly.seata.dto.OrderDTO)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;2020-01-16&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;19&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:00&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:19.960&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;WARN&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;19765&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;---&lt;/span&gt; &lt;span class=&quot;selector-attr&quot;&gt;[o-8873-exec-288]&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.s&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tm&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.api&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.DefaultFailureHandlerImpl&lt;/span&gt;     : &lt;span class=&quot;selector-tag&quot;&gt;Failed&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;begin&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;transaction&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.seata&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.core&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.exception&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.TmTransactionException&lt;/span&gt;: &lt;span class=&quot;selector-tag&quot;&gt;RPC&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;timeout&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.seata&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tm&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.DefaultTransactionManager&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.syncCall&lt;/span&gt;(DefaultTransactionManager.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;97&lt;/span&gt;) ~&lt;span class=&quot;selector-attr&quot;&gt;[seata-all-1.0.0.jar!/:1.0.0]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.seata&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tm&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.DefaultTransactionManager&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.begin&lt;/span&gt;(DefaultTransactionManager.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;53&lt;/span&gt;) ~&lt;span class=&quot;selector-attr&quot;&gt;[seata-all-1.0.0.jar!/:1.0.0]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.seata&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tm&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.api&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.DefaultGlobalTransaction&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.begin&lt;/span&gt;(DefaultGlobalTransaction.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;102&lt;/span&gt;) ~&lt;span class=&quot;selector-attr&quot;&gt;[seata-all-1.0.0.jar!/:1.0.0]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.seata&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tm&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.api&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.TransactionalTemplate&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.beginTransaction&lt;/span&gt;(TransactionalTemplate.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;) ~&lt;span class=&quot;selector-attr&quot;&gt;[seata-all-1.0.0.jar!/:1.0.0]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.seata&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.tm&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.api&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.TransactionalTemplate&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.execute&lt;/span&gt;(TransactionalTemplate.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;58&lt;/span&gt;) ~&lt;span class=&quot;selector-attr&quot;&gt;[seata-all-1.0.0.jar!/:1.0.0]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.seata&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.spring&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.annotation&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.GlobalTransactionalInterceptor&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.handleGlobalTransaction&lt;/span&gt;(GlobalTransactionalInterceptor.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;106&lt;/span&gt;) &lt;span class=&quot;selector-attr&quot;&gt;[seata-all-1.0.0.jar!/:1.0.0]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.seata&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.spring&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.annotation&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.GlobalTransactionalInterceptor&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.invoke&lt;/span&gt;(GlobalTransactionalInterceptor.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;81&lt;/span&gt;) &lt;span class=&quot;selector-attr&quot;&gt;[seata-all-1.0.0.jar!/:1.0.0]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.springframework&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.aop&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.framework&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.ReflectiveMethodInvocation&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.proceed&lt;/span&gt;(ReflectiveMethodInvocation.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;185&lt;/span&gt;) &lt;span class=&quot;selector-attr&quot;&gt;[spring-aop-5.0.5.RELEASE.jar!/:5.0.5.RELEASE]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689) [spring-aop-5.0.5.RELEASE.jar!/:5.0.5.RELEASE]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at com.fly.seata.controller.TestController$$EnhancerBySpringCGLIB$$63e8794f.test(&amp;lt;generated&amp;gt;) [classes!/:1.0-SNAPSHOT]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;sun&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.reflect&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.GeneratedMethodAccessor80&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.invoke&lt;/span&gt;(Unknown Source) ~&lt;span class=&quot;selector-attr&quot;&gt;[na:na]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;sun&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.reflect&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.DelegatingMethodAccessorImpl&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.invoke&lt;/span&gt;(DelegatingMethodAccessorImpl.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;43&lt;/span&gt;) ~&lt;span class=&quot;selector-attr&quot;&gt;[na:1.8.0_181]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.reflect&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Method&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.invoke&lt;/span&gt;(Method.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;498&lt;/span&gt;) ~&lt;span class=&quot;selector-attr&quot;&gt;[na:1.8.0_181]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;线程栈信息&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&quot;ServerHandlerThread_1_500&quot; #86 daemon prio=5 os_prio=0 tid=0x00007fe594011800 nid=0x6138 waiting on condition [0x00007fe6507c0000]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Thread&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.State&lt;/span&gt;: &lt;span class=&quot;selector-tag&quot;&gt;WAITING&lt;/span&gt; (parking)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;sun&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.misc&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Unsafe&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.park&lt;/span&gt;(Native Method)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	- parking to wait for  &amp;lt;0x00000000c6f363c8&amp;gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.locks&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.LockSupport&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.park&lt;/span&gt;(LockSupport.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;175&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.LinkedBlockingQueue&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.take&lt;/span&gt;(LinkedBlockingQueue.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;442&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.getTask&lt;/span&gt;(ThreadPoolExecutor.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1074&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.runWorker&lt;/span&gt;(ThreadPoolExecutor.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1134&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.netty&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.FastThreadLocalRunnable&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.run&lt;/span&gt;(FastThreadLocalRunnable.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Thread&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.run&lt;/span&gt;(Thread.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;748&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;ServerHandlerThread_1_500&quot; #85 daemon prio=5 os_prio=0 tid=0x00007fe580013000 nid=0x6137 waiting on condition [0x00007fe650841000]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Thread&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.State&lt;/span&gt;: &lt;span class=&quot;selector-tag&quot;&gt;WAITING&lt;/span&gt; (parking)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;sun&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.misc&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Unsafe&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.park&lt;/span&gt;(Native Method)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	- parking to wait for  &amp;lt;0x00000000c6f363c8&amp;gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.locks&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.LockSupport&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.park&lt;/span&gt;(LockSupport.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;175&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.LinkedBlockingQueue&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.take&lt;/span&gt;(LinkedBlockingQueue.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;442&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.getTask&lt;/span&gt;(ThreadPoolExecutor.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1074&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.runWorker&lt;/span&gt;(ThreadPoolExecutor.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1134&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.netty&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.FastThreadLocalRunnable&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.run&lt;/span&gt;(FastThreadLocalRunnable.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Thread&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.run&lt;/span&gt;(Thread.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;748&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;ServerHandlerThread_1_500&quot; #84 daemon prio=5 os_prio=0 tid=0x00007fe580011000 nid=0x6136 waiting on condition [0x00007fe6508c2000]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Thread&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.State&lt;/span&gt;: &lt;span class=&quot;selector-tag&quot;&gt;WAITING&lt;/span&gt; (parking)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;sun&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.misc&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Unsafe&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.park&lt;/span&gt;(Native Method)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	- parking to wait for  &amp;lt;0x00000000c6f363c8&amp;gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.locks&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.LockSupport&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.park&lt;/span&gt;(LockSupport.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;175&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.LinkedBlockingQueue&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.take&lt;/span&gt;(LinkedBlockingQueue.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;442&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.getTask&lt;/span&gt;(ThreadPoolExecutor.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1074&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.runWorker&lt;/span&gt;(ThreadPoolExecutor.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1134&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.netty&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.FastThreadLocalRunnable&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.run&lt;/span&gt;(FastThreadLocalRunnable.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Thread&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.run&lt;/span&gt;(Thread.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;748&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;ServerHandlerThread_1_500&quot; #83 daemon prio=5 os_prio=0 tid=0x00007fe5a4080000 nid=0x6135 waiting on condition [0x00007fe650943000]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Thread&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.State&lt;/span&gt;: &lt;span class=&quot;selector-tag&quot;&gt;WAITING&lt;/span&gt; (parking)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;sun&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.misc&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Unsafe&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.park&lt;/span&gt;(Native Method)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	- parking to wait for  &amp;lt;0x00000000c6f363c8&amp;gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.locks&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.LockSupport&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.park&lt;/span&gt;(LockSupport.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;175&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.LinkedBlockingQueue&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.take&lt;/span&gt;(LinkedBlockingQueue.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;442&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.getTask&lt;/span&gt;(ThreadPoolExecutor.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1074&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.runWorker&lt;/span&gt;(ThreadPoolExecutor.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1134&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.netty&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.FastThreadLocalRunnable&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.run&lt;/span&gt;(FastThreadLocalRunnable.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Thread&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.run&lt;/span&gt;(Thread.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;748&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;ServerHandlerThread_1_500&quot; #82 daemon prio=5 os_prio=0 tid=0x00007fe594010000 nid=0x6134 waiting on condition [0x00007fe6509c4000]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Thread&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.State&lt;/span&gt;: &lt;span class=&quot;selector-tag&quot;&gt;WAITING&lt;/span&gt; (parking)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;sun&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.misc&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Unsafe&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.park&lt;/span&gt;(Native Method)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	- parking to wait for  &amp;lt;0x00000000c6f363c8&amp;gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.locks&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.LockSupport&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.park&lt;/span&gt;(LockSupport.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;175&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.LinkedBlockingQueue&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.take&lt;/span&gt;(LinkedBlockingQueue.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;442&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.getTask&lt;/span&gt;(ThreadPoolExecutor.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1074&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.runWorker&lt;/span&gt;(ThreadPoolExecutor.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1134&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.netty&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.util&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.concurrent&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.FastThreadLocalRunnable&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.run&lt;/span&gt;(FastThreadLocalRunnable.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;selector-tag&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Thread&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.run&lt;/span&gt;(Thread.&lt;span class=&quot;attribute&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;748&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;出现超时之后，server端和Tm端、Rm端有建立连接的&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pangpeijie@mdw1:/home/dxy/seata-server/bin$ lsof -i:8091&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;COMMAND&lt;/span&gt;   &lt;span class=&quot;selector-tag&quot;&gt;PID&lt;/span&gt;       &lt;span class=&quot;selector-tag&quot;&gt;USER&lt;/span&gt;   &lt;span class=&quot;selector-tag&quot;&gt;FD&lt;/span&gt;   &lt;span class=&quot;selector-tag&quot;&gt;TYPE&lt;/span&gt;     &lt;span class=&quot;selector-tag&quot;&gt;DEVICE&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;SIZE&lt;/span&gt;/&lt;span class=&quot;selector-tag&quot;&gt;OFF&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;NODE&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;NAME&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;    &lt;span class=&quot;selector-tag&quot;&gt;24684&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;pangpeijie&lt;/span&gt;    &lt;span class=&quot;selector-tag&quot;&gt;6u&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;IPv4&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;1673279856&lt;/span&gt;      &lt;span class=&quot;selector-tag&quot;&gt;0t0&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;TCP&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.137&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:8091-&lt;/span&gt;&amp;gt;&lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.138&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:53212&lt;/span&gt; (ESTABLISHED)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;    &lt;span class=&quot;selector-tag&quot;&gt;24684&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;pangpeijie&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;270u&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;IPv4&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;1591859785&lt;/span&gt;      &lt;span class=&quot;selector-tag&quot;&gt;0t0&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;TCP&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.137&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:8091-&lt;/span&gt;&amp;gt;&lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.138&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:44208&lt;/span&gt; (ESTABLISHED)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;    &lt;span class=&quot;selector-tag&quot;&gt;24684&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;pangpeijie&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;272u&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;IPv4&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;1548003634&lt;/span&gt;      &lt;span class=&quot;selector-tag&quot;&gt;0t0&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;TCP&lt;/span&gt; *&lt;span class=&quot;selector-pseudo&quot;&gt;:8091&lt;/span&gt; (LISTEN)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;    &lt;span class=&quot;selector-tag&quot;&gt;24684&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;pangpeijie&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;275u&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;IPv4&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;1571258316&lt;/span&gt;      &lt;span class=&quot;selector-tag&quot;&gt;0t0&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;TCP&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.137&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:8091-&lt;/span&gt;&amp;gt;&lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.138&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:43734&lt;/span&gt; (ESTABLISHED)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;    &lt;span class=&quot;selector-tag&quot;&gt;24684&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;pangpeijie&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;276u&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;IPv4&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;1571258317&lt;/span&gt;      &lt;span class=&quot;selector-tag&quot;&gt;0t0&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;TCP&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.137&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:8091-&lt;/span&gt;&amp;gt;&lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.138&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:43738&lt;/span&gt; (ESTABLISHED)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;    &lt;span class=&quot;selector-tag&quot;&gt;24684&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;pangpeijie&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;278u&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;IPv4&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;1571258320&lt;/span&gt;      &lt;span class=&quot;selector-tag&quot;&gt;0t0&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;TCP&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.137&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:8091-&lt;/span&gt;&amp;gt;&lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.138&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:43806&lt;/span&gt; (ESTABLISHED)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;java&lt;/span&gt;    &lt;span class=&quot;selector-tag&quot;&gt;24684&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;pangpeijie&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;280u&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;IPv4&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;1571258321&lt;/span&gt;      &lt;span class=&quot;selector-tag&quot;&gt;0t0&lt;/span&gt;  &lt;span class=&quot;selector-tag&quot;&gt;TCP&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.137&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:8091-&lt;/span&gt;&amp;gt;&lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.138&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:43814&lt;/span&gt; (ESTABLISHED)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pangpeijie@mdw2:~$ netstat -ano|grep &quot;192.168.202.137:8091&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;tcp&lt;/span&gt;        &lt;span class=&quot;selector-tag&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;selector-tag&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.138&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:43814&lt;/span&gt;   &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.137&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:8091&lt;/span&gt;    &lt;span class=&quot;selector-tag&quot;&gt;ESTABLISHED&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;keepalive&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;2398.82&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;tcp&lt;/span&gt;        &lt;span class=&quot;selector-tag&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;selector-tag&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.138&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:53212&lt;/span&gt;   &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.137&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:8091&lt;/span&gt;    &lt;span class=&quot;selector-tag&quot;&gt;ESTABLISHED&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;keepalive&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;4753.92&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;tcp&lt;/span&gt;        &lt;span class=&quot;selector-tag&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;selector-tag&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.138&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:43738&lt;/span&gt;   &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.137&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:8091&lt;/span&gt;    &lt;span class=&quot;selector-tag&quot;&gt;ESTABLISHED&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;keepalive&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;2396.00&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;tcp&lt;/span&gt;        &lt;span class=&quot;selector-tag&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;selector-tag&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.138&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:43806&lt;/span&gt;   &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.137&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:8091&lt;/span&gt;    &lt;span class=&quot;selector-tag&quot;&gt;ESTABLISHED&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;keepalive&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;2397.65&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;tcp&lt;/span&gt;        &lt;span class=&quot;selector-tag&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;selector-tag&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.138&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:44208&lt;/span&gt;   &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.137&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:8091&lt;/span&gt;    &lt;span class=&quot;selector-tag&quot;&gt;ESTABLISHED&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;keepalive&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;4107.33&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;tcp&lt;/span&gt;        &lt;span class=&quot;selector-tag&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;selector-tag&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.138&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:43734&lt;/span&gt;   &lt;span class=&quot;selector-tag&quot;&gt;192&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.202&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.137&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:8091&lt;/span&gt;    &lt;span class=&quot;selector-tag&quot;&gt;ESTABLISHED&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;keepalive&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;2396.14&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;其他报错信息请查看github的&lt;a href=&quot;https://github.com/seata/seata/issues/2193&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;issue&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="快速排查线上问题" scheme="blog.ppjys.cn/categories/%E5%BF%AB%E9%80%9F%E6%8E%92%E6%9F%A5%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="性能压测" scheme="blog.ppjys.cn/tags/%E6%80%A7%E8%83%BD%E5%8E%8B%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>线上服务堆外内存OOM问题</title>
    <link href="blog.ppjys.cn/2020/02/19/20200219_%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98OOM%E9%97%AE%E9%A2%98/"/>
    <id>blog.ppjys.cn/2020/02/19/20200219_线上服务堆外内存OOM问题/</id>
    <published>2020-02-19T09:07:35.000Z</published>
    <updated>2020-03-13T09:32:20.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近我们生产上的消息推送服务不断的爆出内存增长过大导致操作系统kill该进程，并且随着业务量的增长出现的频次越来越高，由去年12月底的半个月出现一次，到现在的一天出现一次。</p><p>该服务的业务逻辑就是消息推送，业务方推送消息，服务方通过rocketmq做削峰处理（<strong>之前使用kafka来左右消息队列没出现过问题</strong>），其中主要通道是个推和apns（使用pushy框架）通道，业务方的全局推送大概在5000w用户左右，每全局推送一次，内存就会增长几百mb，直到jvm进程内存达到5g之后，系统就会出现服务请求没响应或者被守护进程重启等问题。</p><p>刚开始的快速解决方案也只能重启，虽然重启能解决问题，但是也没找到根本原因！</p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>由于我们jvm堆内的初始内存和最大内存都是配置成2g ,但是进程的内存达到5g，那就是说堆外占了3g</p><blockquote><p>-Xms2048m -Xmx2048m</p></blockquote><h3 id="运维平台监控"><a href="#运维平台监控" class="headerlink" title="运维平台监控"></a>运维平台监控</h3><p>下面是运维监控平台的cpu、内存、线程资源数据，内存在一直在增长，没有回收释放。</p><p><img src="/images/oom1.png" alt="oom内存和cpu"></p><p>出问题的时候监控应用fullgc情况</p><p><img src="/images/oom4.png" alt="fullgc情况"></p><p>监控jvm虚拟机的线程增长情况</p><p><img src="/images/thread_inc.png" alt="线程增长情况"></p><a id="more"></a><h3 id="NMT监控"><a href="#NMT监控" class="headerlink" title="NMT监控"></a>NMT监控</h3><p>接下来我们就一直想知道这个增长的内存到底是啥，我们参考<a href="https://tech.meituan.com/2019/01/03/spring-boot-native-memory-leak.html" target="_blank" rel="noopener">Spring Boot引起的“堆外内存泄漏”排查及经验总结</a>文章来监控堆外内存,然后看了官方文档<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html#BABJGHDB" target="_blank" rel="noopener">How to Monitor VM Internal Memory</a>。</p><blockquote><p>jvm参数增加 “-XX:NativeMemoryTracking=detail”</p><p>然后在jvm启动成功后，执行命令”jcmd pid VM.native_memory baseline”设置基准。</p></blockquote><p>使用命令<code>jcmd pid VM.native_memory summary.diff</code>查看到的内存分布如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Native</span> <span class="selector-tag">Memory</span> <span class="selector-tag">Tracking</span>:</span><br><span class="line">Total: reserved=6292013KB +1539438KB, committed=5135497KB +1547890KB</span><br><span class="line"><span class="selector-tag">-</span>                 <span class="selector-tag">Java</span> <span class="selector-tag">Heap</span> (reserved=<span class="number">2097152</span>KB, committed=<span class="number">2097152</span>KB)</span><br><span class="line">                            (<span class="attribute">mmap</span>: reserved=<span class="number">2097152</span>KB, committed=<span class="number">2097152</span>KB)</span><br><span class="line"><span class="selector-tag">-</span>                     <span class="selector-tag">Class</span> (reserved=<span class="number">1195883</span>KB +<span class="number">2229</span>KB, committed=<span class="number">164035</span>KB +<span class="number">2229</span>KB)</span><br><span class="line">                            (classes <span class="number">#24637</span>)</span><br><span class="line">                            (malloc=<span class="number">14187</span>KB +<span class="number">181</span>KB <span class="number">#58583</span> -<span class="number">3174</span>)</span><br><span class="line">                            (<span class="attribute">mmap</span>: reserved=<span class="number">1181696</span>KB +<span class="number">2048</span>KB, committed=<span class="number">149848</span>KB +<span class="number">2048</span>KB)</span><br><span class="line"><span class="selector-tag">-</span>                    <span class="selector-tag">Thread</span> (reserved=<span class="number">330857</span>KB +<span class="number">16399</span>KB, committed=<span class="number">330857</span>KB +<span class="number">16399</span>KB)</span><br><span class="line">                            (thread <span class="number">#625</span> +<span class="number">32</span>)</span><br><span class="line">                            (<span class="attribute">stack</span>: reserved=<span class="number">328076</span>KB +<span class="number">16512</span>KB, committed=<span class="number">328076</span>KB +<span class="number">16512</span>KB)</span><br><span class="line">                            (malloc=<span class="number">2049</span>KB +<span class="number">105</span>KB <span class="number">#3129</span> +<span class="number">160</span>)</span><br><span class="line">                            (arena=<span class="number">732</span>KB -<span class="number">218</span> <span class="number">#1246</span> +<span class="number">64</span>)</span><br><span class="line"><span class="selector-tag">-</span>                      <span class="selector-tag">Code</span> (reserved=<span class="number">269720</span>KB -<span class="number">4533</span>KB, committed=<span class="number">145052</span>KB +<span class="number">3919</span>KB)</span><br><span class="line">                            (malloc=<span class="number">20120</span>KB -<span class="number">4533</span>KB <span class="number">#22197</span> -<span class="number">10586</span>)</span><br><span class="line">                            (<span class="attribute">mmap</span>: reserved=<span class="number">249600</span>KB, committed=<span class="number">124932</span>KB +<span class="number">8452</span>KB)</span><br><span class="line"><span class="selector-tag">-</span>                        <span class="selector-tag">GC</span> (reserved=<span class="number">85877</span>KB -<span class="number">1</span>KB, committed=<span class="number">85877</span>KB -<span class="number">1</span>KB)</span><br><span class="line">                            (malloc=<span class="number">9253</span>KB -<span class="number">1</span>KB <span class="number">#856</span> -<span class="number">42</span>)</span><br><span class="line">                            (<span class="attribute">mmap</span>: reserved=<span class="number">76624</span>KB, committed=<span class="number">76624</span>KB)</span><br><span class="line"><span class="selector-tag">-</span>                  <span class="selector-tag">Compiler</span> (reserved=<span class="number">1753</span>KB -<span class="number">159</span>KB, committed=<span class="number">1753</span>KB -<span class="number">159</span>KB)</span><br><span class="line">                            (malloc=<span class="number">1623</span>KB -<span class="number">159</span>KB <span class="number">#2892</span> -<span class="number">1291</span>)</span><br><span class="line">                            (arena=<span class="number">131</span>KB <span class="number">#6</span>)</span><br><span class="line"><span class="selector-tag">-</span>                  <span class="selector-tag">Internal</span> (reserved=<span class="number">2267668</span>KB +<span class="number">1520485</span>KB, committed=<span class="number">2267668</span>KB +<span class="number">1520485</span>KB)</span><br><span class="line">                            (malloc=<span class="number">2267636</span>KB +<span class="number">1520485</span>KB <span class="number">#39668</span> +<span class="number">996</span>)</span><br><span class="line">                            (<span class="attribute">mmap</span>: reserved=<span class="number">32</span>KB, committed=<span class="number">32</span>KB)</span><br><span class="line"><span class="selector-tag">-</span>                    <span class="selector-tag">Symbol</span> (reserved=<span class="number">30690</span>KB +<span class="number">10</span>KB, committed=<span class="number">30690</span>KB +<span class="number">10</span>KB)</span><br><span class="line">                            (malloc=<span class="number">26686</span>KB +<span class="number">10</span>KB <span class="number">#273270</span> +<span class="number">61</span>)</span><br><span class="line">                            (arena=<span class="number">4004</span>KB <span class="number">#1</span>)</span><br><span class="line"><span class="selector-tag">-</span>    <span class="selector-tag">Native</span> <span class="selector-tag">Memory</span> <span class="selector-tag">Tracking</span> (reserved=<span class="number">7216</span>KB +<span class="number">16</span>KB, committed=<span class="number">7216</span>KB +<span class="number">16</span>KB)</span><br><span class="line">                            (malloc=<span class="number">766</span>KB +<span class="number">190</span>KB <span class="number">#10648</span> +<span class="number">2568</span>)</span><br><span class="line">                            (tracking overhead=<span class="number">6450</span>KB -<span class="number">173</span>KB)</span><br><span class="line"><span class="selector-tag">-</span>               <span class="selector-tag">Arena</span> <span class="selector-tag">Chunk</span> (reserved=<span class="number">5196</span>KB +<span class="number">4991</span>KB, committed=<span class="number">5196</span>KB +<span class="number">4991</span>KB)</span><br><span class="line">                            (malloc=<span class="number">5196</span>KB +<span class="number">4991</span>KB)</span><br></pre></td></tr></table></figure><p>发现增长的区域居然是Internal区域，刚开始感到一脸疑惑，后来在网上看到<code>堆外内存申请也是属于Internal区域</code>，才觉得应该是什么中间件使用了堆外内存导致的内存泄漏。</p><h3 id="pmap查看内存分配情况"><a href="#pmap查看内存分配情况" class="headerlink" title="pmap查看内存分配情况"></a>pmap查看内存分配情况</h3><p> 通过linux工具查看进程的内存映射</p><blockquote><p>pmap -x 11305|sort -k 3 -n -r </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">----------------</span> <span class="selector-tag">-------</span> <span class="selector-tag">-------</span> <span class="selector-tag">-------</span> </span><br><span class="line">&gt; <span class="selector-tag">0000000080000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">0000000101100000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">0000000101100000</span> <span class="selector-tag">1031168</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">000055f7262ed000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">r-x--</span> <span class="selector-tag">java</span></span><br><span class="line">&gt; <span class="selector-tag">000055f7264ed000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">r----</span> <span class="selector-tag">java</span></span><br><span class="line">&gt; <span class="selector-tag">000055f7264ee000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span> <span class="selector-tag">java</span></span><br><span class="line">&gt; <span class="selector-tag">000055f728243000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6970000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6973003000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6973003000</span>   <span class="selector-tag">16372</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6974000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6977010000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6977010000</span>   <span class="selector-tag">16320</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6978000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f697b001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f697b001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f697c000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f697e001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f697e001000</span>   <span class="selector-tag">32764</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6980000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6983001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6983001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6988000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f698b001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f698b001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f698c000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f698f001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f698f001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6990000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6993001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6993001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6994000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6997001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6997001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f6998000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f699b001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f699b001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f699c000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f699f001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f699f001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69a0000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69a3001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69a3001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69a4000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69a7001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69a7001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69a8000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69ab001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69ab001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69ada9a000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69afa9c000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69afa9c000</span>      <span class="selector-tag">12</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69afa9f000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69afb1d000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69afb1d000</span>      <span class="selector-tag">12</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69afb20000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69afb9e000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69afb9e000</span>      <span class="selector-tag">12</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69afba1000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69afc1f000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69afc1f000</span>      <span class="selector-tag">12</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69afc22000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt; <span class="selector-tag">00007f69afda2000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>备注：由于篇幅问题，该地方只截取了部分。</p><p>从以上也没看出有啥特别多的内存块，所以这里也不好怀疑。</p></blockquote><h3 id="操作系统工具分析"><a href="#操作系统工具分析" class="headerlink" title="操作系统工具分析"></a>操作系统工具分析</h3><p>由于操作系统监控运维不给装，我们也就放弃这方面的定位了，这边就写一下大概的思路。</p><blockquote><p>1.使用strace去追踪系统调用 </p><p>2.使用GDB去dump可疑内存 </p><p>3.使用jstack去查看对应的线程</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">strace</span>: <span class="selector-tag">Process</span> <span class="selector-tag">11305</span> <span class="selector-tag">attached</span> <span class="selector-tag">with</span> <span class="selector-tag">442</span> <span class="selector-tag">threads</span></span><br><span class="line">&gt; <span class="selector-tag">strace</span>: <span class="selector-attr">[ Process PID=11314 runs in x32 mode. ]</span></span><br><span class="line">&gt; <span class="selector-tag">strace</span>: <span class="selector-attr">[ Process PID=11312 runs in x32 mode. ]</span></span><br><span class="line">&gt; <span class="selector-tag">strace</span>: <span class="selector-attr">[ Process PID=11314 runs in 64 bit mode. ]</span></span><br><span class="line">&gt; <span class="selector-tag">strace</span>: <span class="selector-attr">[ Process PID=11308 runs in x32 mode. ]</span></span><br><span class="line">&gt; <span class="selector-tag">strace</span>: <span class="selector-attr">[ Process PID=11312 runs in 64 bit mode. ]</span></span><br><span class="line">&gt; <span class="selector-tag">strace</span>: <span class="selector-attr">[ Process PID=11307 runs in x32 mode. ]</span></span><br><span class="line">&gt; <span class="selector-tag">strace</span>: <span class="selector-attr">[ Process PID=11307 runs in 64 bit mode. ]</span></span><br><span class="line">&gt; <span class="selector-tag">strace</span>: <span class="selector-attr">[ Process PID=11308 runs in 64 bit mode. ]</span></span><br><span class="line">&gt; [pid 11453] --- SIGSEGV &#123;si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0x8&#125; ---</span><br><span class="line">&gt; [pid 11453] --- SIGSEGV &#123;si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0x8&#125; ---</span><br><span class="line">&gt; [pid 11453] --- SIGSEGV &#123;si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0x8&#125; ---</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 8329, PROT_READ, MAP_SHARED, 296, 0x12000) = 0x7ff8c036b000</span><br><span class="line">&gt; [pid 11462] --- SIGSEGV &#123;si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0xc&#125; ---</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 3482, PROT_READ, MAP_SHARED, 186, 0) = 0x7ff8c0672000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 8742, PROT_READ, MAP_SHARED, 189, 0x14000) = 0x7ff8c0368000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 19304, PROT_READ, MAP_SHARED, 192, 0x68000) = 0x7ff8c0363000</span><br><span class="line">&gt; [pid 11485] --- SIGSEGV &#123;si_signo=SIGSEGV, si_code=SEGV_ACCERR, si_addr=0x7ff8e901fc00&#125; ---</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 25507, PROT_READ, MAP_SHARED, 302, 0x4c000) = 0x7ff8c035c000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 2164, PROT_READ, MAP_SHARED, 306, 0) = 0x7ff8c035b000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 99469, PROT_READ, MAP_SHARED, 307, 0x1bf000) = 0x7ff8c0342000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 15813, PROT_READ, MAP_SHARED, 308, 0x35000) = 0x7ff8c033e000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 27163, PROT_READ, MAP_SHARED, 309, 0x38000) = 0x7ff8c0337000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 2155, PROT_READ, MAP_SHARED, 310, 0x2000) = 0x7ff8c0336000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 9433, PROT_READ, MAP_SHARED, 311, 0x18000) = 0x7ff8c0333000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 4679, PROT_READ, MAP_SHARED, 312, 0x15000) = 0x7ff8c0331000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 8824, PROT_READ, MAP_SHARED, 314, 0x21000) = 0x7ff8c032e000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 26825, PROT_READ, MAP_SHARED, 315, 0x73000) = 0x7ff8c0327000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 6971, PROT_READ, MAP_SHARED, 316, 0x6000) = 0x7ff8c0023000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 7756, PROT_READ, MAP_SHARED, 317, 0xe000) = 0x7ff8c0021000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 16798, PROT_READ, MAP_SHARED, 318, 0x38000) = 0x7ff8c001c000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 14199, PROT_READ, MAP_SHARED, 319, 0x2f000) = 0x7ff8c0018000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 26136, PROT_READ, MAP_SHARED, 320, 0x3f000) = 0x7ff8c0011000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 51761, PROT_READ, MAP_SHARED, 321, 0x83000) = 0x7ff8c0004000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 60574, PROT_READ, MAP_SHARED, 322, 0xa9000) = 0x7ff8b8de4000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 26807, PROT_READ, MAP_SHARED, 323, 0x52000) = 0x7ff8b8ddd000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 7562, PROT_READ, MAP_SHARED, 324, 0xf000) = 0x7ff8c0002000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 22377, PROT_READ, MAP_SHARED, 325, 0x45000) = 0x7ff8b8dd7000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 13843, PROT_READ, MAP_SHARED, 326, 0x27000) = 0x7ff8b8dd3000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 16049, PROT_READ, MAP_SHARED, 327, 0x3c000) = 0x7ff8b8dcf000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 32840, PROT_READ, MAP_SHARED, 328, 0x73000) = 0x7ff8b8dc6000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 7438, PROT_READ, MAP_SHARED, 329, 0xd000) = 0x7ff8c0000000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 12333, PROT_READ, MAP_SHARED, 330, 0x1c000) = 0x7ff8b8dc2000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 244913, PROT_READ, MAP_SHARED, 331, 0x24d000) = 0x7ff8b8027000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 33213, PROT_READ, MAP_SHARED, 332, 0x43000) = 0x7ff8b8db9000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 28353, PROT_READ, MAP_SHARED, 333, 0x41000) = 0x7ff8b837b000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 9944, PROT_READ, MAP_SHARED, 334, 0x11000) = 0x7ff8b8db6000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 18986, PROT_READ, MAP_SHARED, 335, 0x48000) = 0x7ff8b8376000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 21674, PROT_READ, MAP_SHARED, 336, 0x3e000) = 0x7ff8b8370000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 136760, PROT_READ, MAP_SHARED, 337, 0x1f1000) = 0x7ff8b8005000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 5109, PROT_READ, MAP_SHARED, 338, 0x4000) = 0x7ff8b836e000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 3686, PROT_READ, MAP_SHARED, 339, 0) = 0x7ff8b836d000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 4542, PROT_READ, MAP_SHARED, 340, 0x5000) = 0x7ff8b836b000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 1280, PROT_READ, MAP_SHARED, 341, 0x1000) = 0x7ff8b836a000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 8572, PROT_READ, MAP_SHARED, 342, 0xb000) = 0x7ff8b8367000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 893527, PROT_READ, MAP_SHARED, 343, 0x7c4000) = 0x7ff7485e6000</span><br><span class="line">&gt; [pid 11452] mmap(NULL, 5512, PROT_READ, MAP_SHARED, 344, 0x2000) = 0x7ff8b8365000</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><h3 id="内存堆栈分析"><a href="#内存堆栈分析" class="headerlink" title="内存堆栈分析"></a>内存堆栈分析</h3><p>由于系统层面堆栈无法分析，我们只能考虑dump内存，如果是堆外内存，肯定有堆内的引用，此时也只能这样操作。</p><blockquote><p>jmap -heap pid</p><p>jmap -histo:live pid | more</p><p>jmap -dump:format=b,file=/filetransfer/heap.hprof</p></blockquote><p>以下是通过jprofile的分析图</p><p><img src="/images/oom2.png" alt="大对象图"></p><p><img src="/images/oom3.png" alt="nioEventLoop引用分析"></p><p>经过以上分析我们能分析出堆内存在大对象是apns推送相关，我们苹果推送用的是pushy框架，此时发现需要看关注下业务代码发送逻辑和pushy源码相关。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h4 id="pushy消息内存堆积"><a href="#pushy消息内存堆积" class="headerlink" title="pushy消息内存堆积"></a>pushy消息内存堆积</h4><p>查阅了pushy的官方文档，发现框架为了提高总的tps，本身做了一层消息缓存功能，以下是官方文档摘录。</p><blockquote><p>The APNs server allows for (at the time of this writing) 1,500 notifications in flight at any time. If we hit that limit, Pushy will buffer notifications automatically behind the scenes and send them to the server as in-flight notifications are resolved.</p></blockquote><blockquote><p>In short, asynchronous operation allows Pushy to make the most of local resources (especially CPU time) by sending notifications as quickly as possible.</p></blockquote><p>然后看了业务代码逻辑，<strong>rocketmq消费者消费tps比较高，然后真正推送的时候是直接采用异步的时候推送，这时候导致会存在大量的futuretask回调，而且监听器回调里居然还有while(trysave()){sleep(2000)}方法，导致回调的tps很低，大量的futuretask都积压在内存</strong>，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送anps服务器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> Notification notification)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> String topic = notification.getTopic();</span><br><span class="line">  <span class="keyword">final</span> String deviceToken = notification.getDeviceToken();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ApnsPayloadBuilder builder = <span class="keyword">new</span> ApnsPayloadBuilder();</span><br><span class="line">  builder</span><br><span class="line">    .setAlertTitle(notification.getTitle())</span><br><span class="line">    .setAlertBody(notification.getDescription()).setMutableContent(<span class="keyword">true</span>)</span><br><span class="line">    .addCustomProperty(<span class="string">"*****"</span>, String.valueOf(notification.getTraceId()));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Map&lt;String, Object&gt; properties = CommonHelper.Json2Map(notification.getPayload());</span><br><span class="line">  setProperties(properties, builder);</span><br><span class="line">  <span class="keyword">final</span> String payload = builder.buildWithDefaultMaximumLength();</span><br><span class="line">  <span class="keyword">final</span> Future&lt;PushNotificationResponse&lt;SimpleApnsPushNotification&gt;&gt; notificationResponseFuture =</span><br><span class="line">    client.sendNotification(<span class="keyword">new</span> SimpleApnsPushNotification(deviceToken, topic, payload));</span><br><span class="line"></span><br><span class="line">  notificationResponseFuture.addListener(future -&gt; &#123;</span><br><span class="line">    NotificationStatus status = NotificationStatus.FAILED;</span><br><span class="line">    PushyNotificationService.count.decrementAndGet();</span><br><span class="line">    <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">      <span class="keyword">final</span> PushNotificationResponse&lt;SimpleApnsPushNotification&gt; response =</span><br><span class="line">        (PushNotificationResponse&lt;SimpleApnsPushNotification&gt;) future.get();</span><br><span class="line">      <span class="keyword">if</span> (response.isAccepted()) &#123;</span><br><span class="line">        status = NotificationStatus.RECEIVED;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"failed reason: &#123;&#125;, notification: &#123;&#125;"</span>, response.getRejectionReason(),</span><br><span class="line">                 ReflectionToStringBuilder.toString(notification));</span><br><span class="line">        notification.setFailedReason(response.getRejectionReason());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      status = NotificationStatus.RETRY;</span><br><span class="line">      <span class="keyword">final</span> String errorMessage = future.cause().getMessage();</span><br><span class="line">      <span class="comment">// 处理 apns 证书过期情况</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtil.isNotEmpty(errorMessage) &amp;&amp; errorMessage.contains(ERROR_CERT_EXPIRE)) &#123;</span><br><span class="line">        status = NotificationStatus.FAILED;</span><br><span class="line">        notification.setFailedReason(ERROR_CERT_EXPIRE);</span><br><span class="line">      &#125;</span><br><span class="line">      log.warn(<span class="string">"pushy send notification failed... &#123;&#125;"</span>, errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      notification.setNotificationStatus(status);</span><br><span class="line">      operator.postSendOperate(notification);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">      log.error(<span class="string">"apns response error"</span>,ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSendOperate</span><span class="params">(<span class="keyword">final</span> BatchNotificationWrapper notification)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//省略......</span></span><br><span class="line">  <span class="keyword">while</span> (!messageService.trySave(msg)) &#123;</span><br><span class="line">    CommonHelper.sleep(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//省略......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终我们在发送代码里加入限流逻辑和优化回调方法，最终发版上线，观察了1天后还未发现内存异常，不过还需要持续关注，就怕pushy会存在内存泄漏问题。<a href="https://www.jianshu.com/p/2f71690ff473" target="_blank" rel="noopener">参考pushy最佳实践</a></p><h4 id="threadlocal内存泄漏"><a href="#threadlocal内存泄漏" class="headerlink" title="threadlocal内存泄漏"></a>threadlocal内存泄漏</h4><p>发现业务代码中有使用threadlocal操作，但是没有使用remove，这可能会出现堆内存泄漏问题，由于threadlocal使用的ThreadLocal.ThreadLocalMap只有gc的时候回收弱引用。参考<a href="https://www.jianshu.com/p/1342a879f523" target="_blank" rel="noopener">深入分析 ThreadLocal 内存泄漏问题</a>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">         * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">         * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="线程泄漏问题"><a href="#线程泄漏问题" class="headerlink" title="线程泄漏问题"></a>线程泄漏问题</h4><p>线上环境线程比较发现netty包中的nioEventLoopGroup增长了将近300个线程，占总线程数的40%，分析了项目中除了rocket-mq-clinet，就是apns苹果推送，最终定位到apns推送每一次实例化apnsClient就会new 4个nioEventLoopGroup线程，项目总共有将近30个苹果推送的渠道，如果按照这个算法应该也就4*30=120个nioEventLoopGroup线程，但是实际远远超过这个线程，接下来我们继续看源码中问题。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">Mar  4 11:55:02 pay3 push[13039]: "nioEventLoopGroup-21-4" #8729 prio=10 os_prio=0 tid=0x00007f22e4002800 nid=0x5b0e runnable [0x00007f22ac0c9000]</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>:    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">RUNNABLE</span></span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.select</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">97</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.SelectedSelectionKeySetSelector</span><span class="selector-class">.select</span>(SelectedSelectionKeySetSelector.<span class="attribute">java</span>:<span class="number">62</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.select</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">806</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.run</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">454</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: </span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: "nioEventLoopGroup-21-2" #8727 prio=10 os_prio=0 tid=0x00007f22dc13d000 nid=0x5b0c runnable [0x00007f22ab349000]</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>:    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">RUNNABLE</span></span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.epollWait</span>(Native Method)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.poll</span>(EPollArrayWrapper.<span class="attribute">java</span>:<span class="number">269</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollSelectorImpl</span><span class="selector-class">.doSelect</span>(EPollSelectorImpl.<span class="attribute">java</span>:<span class="number">93</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.lockAndDoSelect</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">86</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c1495e0&gt; (a io.netty.channel.nio.SelectedSelectionKeySet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c1496d0&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c1495f8&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.select</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">97</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.SelectedSelectionKeySetSelector</span><span class="selector-class">.select</span>(SelectedSelectionKeySetSelector.<span class="attribute">java</span>:<span class="number">62</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.select</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">806</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.run</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">454</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: </span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: "nioEventLoopGroup-21-1" #8726 prio=10 os_prio=0 tid=0x00007f24f0024800 nid=0x5b0b runnable [0x00007f22ab838000]</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>:    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">RUNNABLE</span></span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.epollWait</span>(Native Method)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.poll</span>(EPollArrayWrapper.<span class="attribute">java</span>:<span class="number">269</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollSelectorImpl</span><span class="selector-class">.doSelect</span>(EPollSelectorImpl.<span class="attribute">java</span>:<span class="number">93</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.lockAndDoSelect</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">86</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c16f878&gt; (a io.netty.channel.nio.SelectedSelectionKeySet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c16f968&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c16f890&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.select</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">97</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.SelectedSelectionKeySetSelector</span><span class="selector-class">.select</span>(SelectedSelectionKeySetSelector.<span class="attribute">java</span>:<span class="number">62</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.select</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">806</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.run</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">454</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: </span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: "nioEventLoopGroup-29-4" #7680 prio=10 os_prio=0 tid=0x00007f265c002000 nid=0x54bf runnable [0x00007f22abb3e000]</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>:    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">RUNNABLE</span></span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.epollWait</span>(Native Method)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.poll</span>(EPollArrayWrapper.<span class="attribute">java</span>:<span class="number">269</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollSelectorImpl</span><span class="selector-class">.doSelect</span>(EPollSelectorImpl.<span class="attribute">java</span>:<span class="number">93</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.lockAndDoSelect</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">86</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c02eec8&gt; (a io.netty.channel.nio.SelectedSelectionKeySet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c02efb8&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c02eee0&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.select</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">97</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.SelectedSelectionKeySetSelector</span><span class="selector-class">.select</span>(SelectedSelectionKeySetSelector.<span class="attribute">java</span>:<span class="number">62</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.select</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">806</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.run</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">454</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: </span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: "nioEventLoopGroup-29-3" #7662 prio=10 os_prio=0 tid=0x00007f2650006800 nid=0x54a4 runnable [0x00007f22ac3cb000]</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>:    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">RUNNABLE</span></span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.epollWait</span>(Native Method)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.poll</span>(EPollArrayWrapper.<span class="attribute">java</span>:<span class="number">269</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollSelectorImpl</span><span class="selector-class">.doSelect</span>(EPollSelectorImpl.<span class="attribute">java</span>:<span class="number">93</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.lockAndDoSelect</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">86</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c329300&gt; (a io.netty.channel.nio.SelectedSelectionKeySet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c3293f0&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c329318&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.select</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">97</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.SelectedSelectionKeySetSelector</span><span class="selector-class">.select</span>(SelectedSelectionKeySetSelector.<span class="attribute">java</span>:<span class="number">62</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.select</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">806</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.run</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">454</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: </span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: "nioEventLoopGroup-29-2" #7661 prio=10 os_prio=0 tid=0x00007f2654058800 nid=0x54a3 runnable [0x00007f22b8af5000]</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>:    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">RUNNABLE</span></span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.epollWait</span>(Native Method)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.poll</span>(EPollArrayWrapper.<span class="attribute">java</span>:<span class="number">269</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollSelectorImpl</span><span class="selector-class">.doSelect</span>(EPollSelectorImpl.<span class="attribute">java</span>:<span class="number">93</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.lockAndDoSelect</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">86</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c011ba0&gt; (a io.netty.channel.nio.SelectedSelectionKeySet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c011c90&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c011bb8&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.select</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">97</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.SelectedSelectionKeySetSelector</span><span class="selector-class">.select</span>(SelectedSelectionKeySetSelector.<span class="attribute">java</span>:<span class="number">62</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.select</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">806</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.run</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">454</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span><span class="selector-pseudo">:55</span><span class="selector-pseudo">:02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br></pre></td></tr></table></figure><p>最终发现每天定时任务有重新初始化apns通道，但是初始化的时候没关闭原先apns客户端，这才最终导致线程增长不释放问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spring容器初始化成功调用 和 每天晚上凌晨2点调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillDeliveryStrategyMapper</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> MessageService messageService = context.getBean(MessageService.class);</span><br><span class="line">  <span class="keyword">final</span> AsyncUserService asyncUserService = context.getBean(AsyncUserService.class);</span><br><span class="line">  <span class="keyword">final</span> RocketMQQueueService rocketMQQueueService = context.getBean(RocketMQQueueService.class);</span><br><span class="line">  RuntimeService runtimeService = context.getBean(RuntimeService.class);</span><br><span class="line">  <span class="keyword">final</span> DeliveryStrategyMapper deliveryStrategyMapper = context</span><br><span class="line">    .getBean(DeliveryStrategyMapper.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Builder&lt;String, Delivery&lt;NotificationPackage&gt;&gt; builder = ImmutableMap.builder();</span><br><span class="line">  <span class="keyword">final</span> List&lt;String&gt; registeredAppNames = CommonHelper.getRegisteredApps();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> String appName : registeredAppNames) &#123;</span><br><span class="line">    <span class="keyword">final</span> PushyRegistry registry = CommonHelper.getPushyRegistry(appName);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != registry) &#123;</span><br><span class="line">      builder.put(appName + Constants.Channel.PUSHY,</span><br><span class="line">                  <span class="keyword">new</span> ImmediateDelivery(</span><br><span class="line">                    <span class="keyword">new</span> PushyNotificationService(runtimeService,registry, messageService, rocketMQQueueService,</span><br><span class="line">                                                 asyncUserService, <span class="keyword">false</span>)));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//iso Sandbox</span></span><br><span class="line">      builder.put(appName + Constants.Channel.IOS_SANDBOX,</span><br><span class="line">                  <span class="keyword">new</span> ImmediateDelivery(</span><br><span class="line">                    <span class="keyword">new</span> PushyNotificationService(runtimeService,registry, messageService, rocketMQQueueService,</span><br><span class="line">                                                 asyncUserService, <span class="keyword">true</span>)));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> String secret = CommonHelper.getAndroidPushProviderProperty(appName, CommonHelper.PUSH_MI_REGISTRY_SECRET);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotEmpty(secret)) &#123;</span><br><span class="line">      builder.put(appName + Constants.Channel.MI,</span><br><span class="line">                  <span class="keyword">new</span> BufferedDelivery(</span><br><span class="line">                    <span class="keyword">new</span> MiNotificationService(secret, messageService, asyncUserService), <span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String appKey = CommonHelper.getAndroidPushProviderProperty(appName, CommonHelper.PUSH_UPUSH_REGISTRY_APPKEY);</span><br><span class="line">    <span class="keyword">final</span> String uPushSecret = CommonHelper.getAndroidPushProviderProperty(appName, CommonHelper.PUSH_UPUSH_REGISTRY_SECRET);</span><br><span class="line">    <span class="keyword">if</span> (StringUtil.isNotEmpty(appKey, uPushSecret)) &#123;</span><br><span class="line">      builder.put(appName + Constants.Channel.UPUSH,</span><br><span class="line">                  <span class="keyword">new</span> BufferedDelivery(</span><br><span class="line">                    <span class="keyword">new</span> UPushNotificationService(appKey, uPushSecret, messageService, asyncUserService),</span><br><span class="line">                    <span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String getuiAppId = CommonHelper.getAndroidPushProviderProperty(appName, CommonHelper.PUSH_GETUI_REGISTRY_APP_ID_MATCHER);</span><br><span class="line">    <span class="keyword">final</span> String getuiAppKey = CommonHelper.getAndroidPushProviderProperty(appName, CommonHelper.PUSH_GETUI_REGISTRY_APP_KEY_MATCHER);</span><br><span class="line">    <span class="keyword">final</span> String getuiMasterSecret = CommonHelper.getAndroidPushProviderProperty(appName, CommonHelper.PUSH_GETUI_REGISTRY_MASTER_SECRET_MATCHER);</span><br><span class="line">    <span class="keyword">if</span> (StringUtil.isNotEmpty(getuiAppId, getuiAppKey, getuiMasterSecret)) &#123;</span><br><span class="line">      builder.put(appName + Constants.Channel.GETUI,</span><br><span class="line">                  <span class="keyword">new</span> BufferedDelivery(<span class="keyword">new</span> GetuiNotificationService(getuiAppId, getuiAppKey, getuiMasterSecret, messageService, asyncUserService, appName), GetuiChannel.GETUI_MAX_BATCH_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化所有的推送通道，这里没有关闭以前的创建的客户端</span></span><br><span class="line">  deliveryStrategyMapper.setMapper(builder.build());</span><br><span class="line"></span><br><span class="line">  log.info(<span class="string">"push notification delivery strategies: &#123;&#125;"</span>,</span><br><span class="line">           ReflectionToStringBuilder.toString(deliveryStrategyMapper));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lxd容器线程不能创建问题"><a href="#lxd容器线程不能创建问题" class="headerlink" title="lxd容器线程不能创建问题"></a>lxd容器线程不能创建问题</h4><p>由于线上某一台服务器经常出现线程数创建到470的时候，就直接报oom问题，然后触发jsw守护线程重启现象。刚开始我们也调整了lxd的线程数限制调整到4000，但是发现还是一直报错，最终调整容器的UserTasksMax参数。<a href="http://manpages.ubuntu.com/manpages/xenial/man5/logind.conf.5.html" target="_blank" rel="noopener">ubuntu文档</a></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span><span class="selector-pseudo">:33</span><span class="selector-pseudo">:04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>: <span class="selector-tag">unable</span> <span class="selector-tag">to</span> <span class="selector-tag">create</span> <span class="selector-tag">new</span> <span class="selector-tag">native</span> <span class="selector-tag">thread</span></span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span><span class="selector-pseudo">:33</span><span class="selector-pseudo">:04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-tag">The</span> <span class="selector-tag">JVM</span> <span class="selector-tag">has</span> <span class="selector-tag">run</span> <span class="selector-tag">out</span> <span class="selector-tag">of</span> <span class="selector-tag">memory</span>.  <span class="selector-tag">Restarting</span> <span class="selector-tag">JVM</span>.</span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span><span class="selector-pseudo">:33</span><span class="selector-pseudo">:04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.start0</span>(Native Method) <span class="selector-attr">[na:1.8.0_242]</span></span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span><span class="selector-pseudo">:33</span><span class="selector-pseudo">:04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.start</span>(Thread.<span class="attribute">java</span>:<span class="number">717</span>) <span class="selector-attr">[na:1.8.0_242]</span></span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span><span class="selector-pseudo">:33</span><span class="selector-pseudo">:04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.addWorker</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">957</span>) ~<span class="selector-attr">[na:1.8.0_242]</span></span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span><span class="selector-pseudo">:33</span><span class="selector-pseudo">:04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.execute</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1378</span>) ~<span class="selector-attr">[na:1.8.0_242]</span></span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span><span class="selector-pseudo">:33</span><span class="selector-pseudo">:04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.tomcat</span><span class="selector-class">.util</span><span class="selector-class">.threads</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.execute</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">166</span>) ~<span class="selector-attr">[tomcat-coyote.jar:7.0.91]</span></span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span><span class="selector-pseudo">:33</span><span class="selector-pseudo">:04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.tomcat</span><span class="selector-class">.util</span><span class="selector-class">.threads</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.execute</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">146</span>) ~<span class="selector-attr">[tomcat-coyote.jar:7.0.91]</span></span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span><span class="selector-pseudo">:33</span><span class="selector-pseudo">:04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.tomcat</span><span class="selector-class">.util</span><span class="selector-class">.net</span><span class="selector-class">.NioEndpoint</span><span class="selector-class">.processSocket</span>(NioEndpoint.<span class="attribute">java</span>:<span class="number">761</span>) ~<span class="selector-attr">[tomcat-coyote.jar:7.0.91]</span></span><br><span class="line">Mar 11 17:33:04 pay3 push[16255]: #011at org.apache.tomcat.util.net.NioEndpoint$Poller.processKey(NioEndpoint.java:1304) ~[tomcat-coyote.jar:7.0.91]</span><br><span class="line">Mar 11 17:33:04 pay3 push[16255]: #011at org.apache.tomcat.util.net.NioEndpoint$Poller.run(NioEndpoint.java:1260) ~[tomcat-coyote.jar:7.0.91]</span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span><span class="selector-pseudo">:33</span><span class="selector-pseudo">:04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>) <span class="selector-attr">[na:1.8.0_242]</span></span><br></pre></td></tr></table></figure><p><strong>解决点：</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UserTasksMax=</span><br><span class="line"><span class="selector-tag">Sets</span> <span class="selector-tag">the</span> <span class="selector-tag">maximum</span> <span class="selector-tag">number</span> <span class="selector-tag">of</span> <span class="selector-tag">OS</span> <span class="selector-tag">tasks</span> <span class="selector-tag">each</span> <span class="selector-tag">user</span> <span class="selector-tag">may</span> <span class="selector-tag">run</span> <span class="selector-tag">concurrently</span>. <span class="selector-tag">This</span> <span class="selector-tag">controls</span> <span class="selector-tag">the</span></span><br><span class="line">TasksMax= setting of the per-user slice unit, see systemd.resource-control(5) for</span><br><span class="line"><span class="selector-tag">details</span>. <span class="selector-tag">Defaults</span> <span class="selector-tag">to</span> <span class="selector-tag">12288</span> (<span class="number">12</span>K).</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分析这次堆外内存虽然最终定位到问题，总结下出现的问题和原因：</p><ol><li>由于之前的消息队列用kafka，后来切换到rocketmq就出现内存堆外内存增长问题，是因为kafka是每个分区分配一个线程去消费处理，但是rocketmq是多线程消费，每个topic默认是16个queue，是异步拉取消费，在加上apns内部用了内存队列来堆积消息，这就导致了内存暴增，最终导致fullgc问题；</li><li>threadlocal内存泄漏问题；</li><li>线程泄漏没有销毁问题；</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;最近我们生产上的消息推送服务不断的爆出内存增长过大导致操作系统kill该进程，并且随着业务量的增长出现的频次越来越高，由去年12月底的半个月出现一次，到现在的一天出现一次。&lt;/p&gt;
&lt;p&gt;该服务的业务逻辑就是消息推送，业务方推送消息，服务方通过rocketmq做削峰处理（&lt;strong&gt;之前使用kafka来左右消息队列没出现过问题&lt;/strong&gt;），其中主要通道是个推和apns（使用pushy框架）通道，业务方的全局推送大概在5000w用户左右，每全局推送一次，内存就会增长几百mb，直到jvm进程内存达到5g之后，系统就会出现服务请求没响应或者被守护进程重启等问题。&lt;/p&gt;
&lt;p&gt;刚开始的快速解决方案也只能重启，虽然重启能解决问题，但是也没找到根本原因！&lt;/p&gt;
&lt;h2 id=&quot;问题排查&quot;&gt;&lt;a href=&quot;#问题排查&quot; class=&quot;headerlink&quot; title=&quot;问题排查&quot;&gt;&lt;/a&gt;问题排查&lt;/h2&gt;&lt;p&gt;由于我们jvm堆内的初始内存和最大内存都是配置成2g ,但是进程的内存达到5g，那就是说堆外占了3g&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-Xms2048m -Xmx2048m&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;运维平台监控&quot;&gt;&lt;a href=&quot;#运维平台监控&quot; class=&quot;headerlink&quot; title=&quot;运维平台监控&quot;&gt;&lt;/a&gt;运维平台监控&lt;/h3&gt;&lt;p&gt;下面是运维监控平台的cpu、内存、线程资源数据，内存在一直在增长，没有回收释放。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/oom1.png&quot; alt=&quot;oom内存和cpu&quot;&gt;&lt;/p&gt;
&lt;p&gt;出问题的时候监控应用fullgc情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/oom4.png&quot; alt=&quot;fullgc情况&quot;&gt;&lt;/p&gt;
&lt;p&gt;监控jvm虚拟机的线程增长情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/thread_inc.png&quot; alt=&quot;线程增长情况&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="快速排查线上问题" scheme="blog.ppjys.cn/categories/%E5%BF%AB%E9%80%9F%E6%8E%92%E6%9F%A5%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="线上问题" scheme="blog.ppjys.cn/tags/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码构建环境搭建</title>
    <link href="blog.ppjys.cn/2019/09/01/Spring%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>blog.ppjys.cn/2019/09/01/Spring源码构建环境搭建/</id>
    <published>2019-09-01T15:28:33.000Z</published>
    <updated>2019-09-30T15:07:53.648Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Spring源码Debug的过程中，遇到了一些问题，如下：</p><p><strong>问题1.</strong>  cannot find symbol CoroutinesUtils<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Error:(347, 51) java: cannot find symbol</span><br><span class="line">  symbol:   variable CoroutinesUtils</span><br><span class="line">  location: class org.springframework.core.ReactiveAdapterRegistry.CoroutinesRegistrar</span><br><span class="line">  Error:(348, 51) java: cannot find symbol</span><br><span class="line">  symbol:   variable CoroutinesUtils</span><br><span class="line">  location: class org.springframework.core.ReactiveAdapterRegistry.CoroutinesRegistrar</span><br></pre></td></tr></table></figure></p><p><strong>问题2.</strong>  找不到符号符号: 类 AnnotationTransactionAspect位置: 类 org.springframework.transaction.aspectj.AspectJTransactionManagementConfiguration</p><p><strong>问题3.</strong> Unexpected AOP exception; nested exception is java.lang.IllegalStateException: Unable to load cache item<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.aop.framework.AopConfigException: Unexpected AOP exception; nested exception is java.lang.IllegalStateException: Unable to load cache item</span><br><span class="line">at org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:214)</span><br><span class="line">at org.springframework.aop.framework.ProxyFactory.getProxy(ProxyFactory.java:110)</span><br><span class="line">at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.createProxy(AbstractAutoProxyCreator.java:488)</span><br><span class="line">at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:367)</span><br><span class="line">at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:310)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:431)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1861)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:608)</span><br><span class="line">... 10 more</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>通过报错信息可以猜测到这些问题应该是和动态代理有关系。查阅相关资料，发现spring原来写了一份源码构建文档import-into-idea如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">The following has been tested against IntelliJ IDEA 2016.2.2</span><br><span class="line"></span><br><span class="line">## Steps</span><br><span class="line"></span><br><span class="line">_Within your locally cloned spring-framework working directory:_</span><br><span class="line"></span><br><span class="line">1. Precompile `spring-oxm` with `./gradlew :spring-oxm:compileTestJava`</span><br><span class="line">2. Import into IntelliJ (File -&gt; New -&gt; Project from Existing Sources -&gt; Navigate to directory -&gt; Select build.gradle)</span><br><span class="line">3. When prompted exclude the `spring-aspects` module (or after the import via File-&gt; Project Structure -&gt; Modules)</span><br><span class="line">4. Code away</span><br><span class="line"></span><br><span class="line">## Known issues</span><br><span class="line"></span><br><span class="line">1. `spring-core` and `spring-oxm` should be pre-compiled due to repackaged dependencies.</span><br><span class="line">See `*RepackJar` tasks in the build and https://youtrack.jetbrains.com/issue/IDEA-160605).</span><br><span class="line">2. `spring-aspects` does not compile due to references to aspect types unknown to</span><br><span class="line">IntelliJ IDEA. See https://youtrack.jetbrains.com/issue/IDEA-64446 for details. In the meantime, the</span><br><span class="line">&apos;spring-aspects&apos; can be excluded from the project to avoid compilation errors.</span><br><span class="line">3. While JUnit tests pass from the command line with Gradle, some may fail when run from</span><br><span class="line">IntelliJ IDEA. Resolving this is a work in progress. If attempting to run all JUnit tests from within</span><br><span class="line">IntelliJ IDEA, you will likely need to set the following VM options to avoid out of memory errors:</span><br><span class="line">    -XX:MaxPermSize=2048m -Xmx2048m -XX:MaxHeapSize=2048m</span><br><span class="line">4. If you invoke &quot;Rebuild Project&quot; in the IDE, you&apos;ll have to generate some test</span><br><span class="line">resources of the `spring-oxm` module again (`./gradlew :spring-oxm:compileTestJava`)    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Tips</span><br><span class="line"></span><br><span class="line">In any case, please do not check in your own generated .iml, .ipr, or .iws files.</span><br><span class="line">You&apos;ll notice these files are already intentionally in .gitignore. The same policy goes for eclipse metadata.</span><br><span class="line"></span><br><span class="line">## FAQ</span><br><span class="line"></span><br><span class="line">Q. What about IntelliJ IDEA&apos;s own [Gradle support](https://confluence.jetbrains.net/display/IDEADEV/Gradle+integration)?</span><br><span class="line"></span><br><span class="line">A. Keep an eye on https://youtrack.jetbrains.com/issue/IDEA-53476</span><br></pre></td></tr></table></figure><h3 id="Spring5源码的编译环境"><a href="#Spring5源码的编译环境" class="headerlink" title="Spring5源码的编译环境"></a>Spring5源码的编译环境</h3><ol><li>JDK &gt;= 1.8</li><li>Gradle环境</li><li>Eclipse/IDEA</li></ol><p>Spring源码下载后推荐不直接导入IDE，大型的开源项目都是借助于自动糊构建工具实现编译打包，编译的过程中容易出现依赖问题。</p><h3 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h3><ol><li>进入spring-framework目录，执行./gradlew :spring-oxm:compileTestJava 先对Spring-oxm模块进行预编译；</li><li><p>还是进入spring-framework目录，执行./gradlew build -x test编译整个源码。后面的-x test是编译期间忽略测试用例，因为编译过程中可能会出现编译不通过问题。最好跳过一些task任务如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">//skip Test tasks</span><br><span class="line">gradle.taskGraph.whenReady &#123;</span><br><span class="line">tasks.each &#123; task -&gt;</span><br><span class="line">if (task.name.contains(&quot;checkstyleTest&quot;) || task.name.contains(&quot;spring-test&quot;))</span><br><span class="line">&#123;</span><br><span class="line">task.enabled = false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>源码导入到IDEA,用gradle导入，由于涉及到aop功能，序号1和序号2只能选取其中一个</p><p> 3.1. (可选)排除 spring-aspects项目，idea工具的ajc编译bug(<a href="http://youtrack.jetbrains.com/issue/IDEA-64446);选中" target="_blank" rel="noopener">http://youtrack.jetbrains.com/issue/IDEA-64446);选中</a> spring-aspects 项目 右键，选择“Load/Unload Moudules” 在弹出的窗体中进行设置.  </p><p> <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/spring/1.png" width="500"></p><p> 3.2. (可选)由于idea默认是不支持acj编译的，不能直接使用aspectj功能，报错内容Error:(42, 16) java: 找不到符号符号: 类 AnnotationTransactionAspect等</p><ol><li><p>将idea的编译器设置为ajc</p><blockquote><p>打开：IDEA–Preferences–Build,Execution,Deployment–Compiler–JavaCompiler,将Use compiler设置为Ajc，将Path to Ajc compiler设置为AspectJ安装目录下的lib文件夹中的aspectjtools.jar文件，同时，可以勾选Delegate to Javac选项，它能够只编译AspectJ的Facets项目，而其他普通项目还是交由Javac来编译。</p></blockquote><p> <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/spring/4.png" width="500"></p></li><li><p>安装aspetj，下载地址:<a href="https://www.eclipse.org/aspectj/downloads.php" target="_blank" rel="noopener">https://www.eclipse.org/aspectj/downloads.php</a></p></li><li><p>idea 安装aspctj插件Aspectj Support和Spring AOP/@Aspectj</p><p> <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/spring/5.png" width="500"></p></li><li><p>将spring-aop_main和spring_aspectjs_main模块添加aspectj facets</p><blockquote><p>打开：File–Project Structure–Facets，点击+号，选择AspectJ，选择spring-aop_main。添加完后，同样的操作，将spring-aspectjs_main模块也设置AspectJ。</p></blockquote><p> <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/spring/6.png" width="500"></p><p>3.3. cglib和objenesis需要重新打包，用gradle下的task任务打包</p><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/spring/2.png" width="500"></p><p>3.4.添加kotlin编译,用于解决spring-core包下kt文件编译</p><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/spring/3.png" width="500"></p></li></ol></li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>问题3没有找到根本原因，应该是cglib包的问题。由于一开始spring版本我下载的是5.1.9-SNAPSHOT分支的代码，最后我合并了最终的5.2.10-RELEASE分支代码，错误就没出现了，怀疑是开发版本问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Spring源码Debug的过程中，遇到了一些问题，如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题1.&lt;/strong&gt;  cannot find symbol CoroutinesUtils&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Error:(347, 51) java: cannot find symbol&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  symbol:   variable CoroutinesUtils&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  location: class org.springframework.core.ReactiveAdapterRegistry.CoroutinesRegistrar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Error:(348, 51) java: cannot find symbol&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  symbol:   variable CoroutinesUtils&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  location: class org.springframework.core.ReactiveAdapterRegistry.CoroutinesRegistrar&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题2.&lt;/strong&gt;  找不到符号符号: 类 AnnotationTransactionAspect位置: 类 org.springframework.transaction.aspectj.AspectJTransactionManagementConfiguration&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题3.&lt;/strong&gt; Unexpected AOP exception; nested exception is java.lang.IllegalStateException: Unable to load cache item&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Caused by: org.springframework.aop.framework.AopConfigException: Unexpected AOP exception; nested exception is java.lang.IllegalStateException: Unable to load cache item&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:214)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at org.springframework.aop.framework.ProxyFactory.getProxy(ProxyFactory.java:110)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.createProxy(AbstractAutoProxyCreator.java:488)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:367)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:310)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:431)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1861)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:608)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	... 10 more&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="源码解析系列" scheme="blog.ppjys.cn/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Spring" scheme="blog.ppjys.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Otter遇到的问题</title>
    <link href="blog.ppjys.cn/2019/06/12/Otter%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>blog.ppjys.cn/2019/06/12/Otter遇到的问题/</id>
    <published>2019-06-12T13:28:33.000Z</published>
    <updated>2019-06-12T13:32:06.498Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-biglog文件被清理"><a href="#1-biglog文件被清理" class="headerlink" title="1. biglog文件被清理"></a>1. biglog文件被清理</h3><pre><code>1.1 报错日志  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not find first log file name in binary log index file</span><br></pre></td></tr></table></figure>1.2 现象  pipeline的mainstem状态 一直处于定位中状态1.3 问题排查  一般出现这个报错，都是由于清空数据库binlog文件导致（自动清除biglog），我们按下述步骤确定是否由于binlog文件被清理：  首先，查看当前同步的binlog位点;  其次，登录数据库查看binlog信息（show master logs）；最后，对比位点信息就能发现biglog丢失；1.4 处理方法1）通道停止增量同步；  2）清空掉otter的同步信息；  3）检查canal的同步位点信息；  4）重新启动otter同步；  </code></pre><h3 id="2-mysql大事物造成otter假死"><a href="#2-mysql大事物造成otter假死" class="headerlink" title="2. mysql大事物造成otter假死"></a>2. mysql大事物造成otter假死</h3><pre><code>2.1 报错日志      无报错日志2.2 现象      channel状态正常，mainstrm状态正常，但是position信息里，position的信息一直不更新（超过半小时以上）2.3 问题排查      确认是否为大事物的方法      1）查询数据库当前位点信息（show master logs）；    2）查询位点的详细信息（show binlog events in &apos;binlog名称&apos;）；    3）查看binlog日志中begin和commit的偏移量相差多大即可；2.4 处理方法    1）清空掉otter同步信息；    2）检查canal的同步位点配置；    3）重新启动otter同步；</code></pre><h3 id="3-node节点内存溢出"><a href="#3-node节点内存溢出" class="headerlink" title="3. node节点内存溢出"></a>3. node节点内存溢出</h3><pre><code>3.1 报错日志<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: unable to create new native thread</span><br></pre></td></tr></table></figure>3.2 现象  node节点均为运行状态，但是涉及到问题node的channel同步处于挂起状态，且无法解挂及停止；3.3问题排查  1）根据报错log找到对应的node节点；2）查看该node节点的日志找到该报错日志；3.4处理方法   1）重启node节点；</code></pre><a id="more"></a><h3 id="4-node节点挂掉"><a href="#4-node节点挂掉" class="headerlink" title="4. node节点挂掉"></a>4. node节点挂掉</h3><pre><code>4.1 现象  Channel配置显示为挂起或者停止状态，并且启动或者解挂操作置灰不可操作，可以判定为node节点挂了。4.2 问题排查  进入node管理页面，查看是否有node节点处于未启动状态；4.3 处理方法  1） 重启node节点</code></pre><h3 id="5-otter网络故障"><a href="#5-otter网络故障" class="headerlink" title="5. otter网络故障"></a>5. otter网络故障</h3><pre><code>5.1 报错日志  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pid:14 nid:1 exception:canal:dataplatform:com.alibaba.otter.canal.parse.exception.CanalParseException: java.io.IOException: connect /192.168.116.16:3306 failure</span><br><span class="line">Caused by: java.io.IOException: connect /192.168.116.16:3306 failure</span><br><span class="line"> at com.alibaba.otter.canal.parse.driver.mysql.MysqlConnector.connect(MysqlConnector.java:77)</span><br><span class="line"> at com.alibaba.otter.canal.parse.inbound.mysql.MysqlConnection.connect(MysqlConnection.java:86)</span><br><span class="line"> at com.alibaba.otter.canal.parse.inbound.mysql.MysqlEventParser.preDump(MysqlEventParser.java:85)</span><br><span class="line"> at com.alibaba.otter.canal.parse.inbound.AbstractEventParser$3.run(AbstractEventParser.java:175)</span><br><span class="line"> at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Caused by: java.net.ConnectException: Connection timed out (Connection timed out)</span><br></pre></td></tr></table></figure>5.2 现象channel同步处于挂起状态，解挂后有开始挂起状态；5.3 问题排查查看对应的node日志，是否数据库连接失败；5.4 处理方法联系dba处理；</code></pre><h3 id="6-数据源ip变更处理方法"><a href="#6-数据源ip变更处理方法" class="headerlink" title="6.数据源ip变更处理方法"></a>6.数据源ip变更处理方法</h3><pre><code>6.1 现象生产环境下，偶尔会因为主备设置或者ip规划导致需要更改同步的数据源ip。6.2 处理方法1）Channel停止同步；2）记录binlog的同步进度；3）修改对应canal的数据源地址；4）删除当前同步位点信息；5）重新开启同步；</code></pre><h3 id="7-日志列表中出现miss-data-with-keys异常，同步出现挂起后又自动恢复"><a href="#7-日志列表中出现miss-data-with-keys异常，同步出现挂起后又自动恢复" class="headerlink" title="7.日志列表中出现miss data with keys异常，同步出现挂起后又自动恢复"></a>7.日志列表中出现miss data with keys异常，同步出现挂起后又自动恢复</h3><pre><code>7.1 报错日志<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid:2 nid:2 exception:setl:load miss data with keys:[MemoryPipeKey[identity=Identity[channelId=1,pipelineId=2,processId=4991953],time=1383190001987,dataType=DB_BATCH]]</span><br></pre></td></tr></table></figure>7.2 处理方式要理解该异常，需要先了解一下otter调度模型，里面SEDA中多个stage之间通过pipe进行数据交互，比如T模块完成后会将数据存到pipe中，然后通知SEDA中心，中心会通知L模块起来工作，L模块就会根据T传给中心的pipeKey去提取数据，而该异常就是当L模块根据pipeKey去提取数据时，发现数据没了。 主要原因：pipe在设计时，如果是单机传输时，会使用softReference来存储，所以当jvm内存不足时就会被GC掉，所以就会出现无数据的情况.ps. 如果miss data with keys异常非常多的时候，你就得考虑是否当前node已经超负载运行，内存不够，需要将上面的部分同步任务迁移出去。如果是偶尔的异常，那可以忽略，该异常会有自动恢复RESTART同步任务的处理。</code></pre><h3 id="8-日志列表中出现manager异常"><a href="#8-日志列表中出现manager异常" class="headerlink" title="8.日志列表中出现manager异常"></a>8.日志列表中出现manager异常</h3><pre><code>8.1 报错日志<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pid:2 nid:null exception:channel:can&apos;t restart by no select live node</span><br><span class="line">//该异常代表pipelineId = 2，select模块的node没有可用的节点.</span><br><span class="line"></span><br><span class="line">pid:-1 nid:null exception:cid:2 restart recovery successful for rid:-1</span><br><span class="line">//该异常代表channelId = 2，成功发起了一次restart同步任务的操作.</span><br><span class="line"></span><br><span class="line">pid:-1 nid:null exception:nid:2 is dead and restart cids:[1,2]</span><br><span class="line">//该异常代表node id = 2，因为该node挂了，触发了channelId = 1 / 2的两个同步任务发起restart同步任务的操作. (一种failover的机制)</span><br></pre></td></tr></table></figure>8.2 处理方式无需处理</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-biglog文件被清理&quot;&gt;&lt;a href=&quot;#1-biglog文件被清理&quot; class=&quot;headerlink&quot; title=&quot;1. biglog文件被清理&quot;&gt;&lt;/a&gt;1. biglog文件被清理&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1.1 报错日志  
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Could not find first log file name in binary log index file&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

1.2 现象  

pipeline的mainstem状态 一直处于定位中状态

1.3 问题排查  
一般出现这个报错，都是由于清空数据库binlog文件导致（自动清除biglog），我们按下述步骤确定是否由于binlog文件被清理：  

首先，查看当前同步的binlog位点;  
其次，登录数据库查看binlog信息（show master logs）；
最后，对比位点信息就能发现biglog丢失；

1.4 处理方法

1）通道停止增量同步；  
2）清空掉otter的同步信息；  
3）检查canal的同步位点信息；  
4）重新启动otter同步；  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-mysql大事物造成otter假死&quot;&gt;&lt;a href=&quot;#2-mysql大事物造成otter假死&quot; class=&quot;headerlink&quot; title=&quot;2. mysql大事物造成otter假死&quot;&gt;&lt;/a&gt;2. mysql大事物造成otter假死&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;2.1 报错日志  
    无报错日志

2.2 现象  
    channel状态正常，mainstrm状态正常，但是position信息里，position的信息一直不更新（超过半小时以上）

2.3 问题排查  
    确认是否为大事物的方法  
    1）查询数据库当前位点信息（show master logs）；
    2）查询位点的详细信息（show binlog events in &amp;apos;binlog名称&amp;apos;）；
    3）查看binlog日志中begin和commit的偏移量相差多大即可；

2.4 处理方法
    1）清空掉otter同步信息；
    2）检查canal的同步位点配置；
    3）重新启动otter同步；
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-node节点内存溢出&quot;&gt;&lt;a href=&quot;#3-node节点内存溢出&quot; class=&quot;headerlink&quot; title=&quot;3. node节点内存溢出&quot;&gt;&lt;/a&gt;3. node节点内存溢出&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;3.1 报错日志
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.lang.OutOfMemoryError: unable to create new native thread&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


3.2 现象  
node节点均为运行状态，但是涉及到问题node的channel同步处于挂起状态，且无法解挂及停止；

3.3问题排查  
1）根据报错log找到对应的node节点；
2）查看该node节点的日志找到该报错日志；

3.4处理方法   
1）重启node节点；
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="otter" scheme="blog.ppjys.cn/categories/otter/"/>
    
    
      <category term="otter" scheme="blog.ppjys.cn/tags/otter/"/>
    
  </entry>
  
  <entry>
    <title>数据平滑迁移方案</title>
    <link href="blog.ppjys.cn/2019/06/12/%E6%95%B0%E6%8D%AE%E5%B9%B3%E6%BB%91%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88/"/>
    <id>blog.ppjys.cn/2019/06/12/数据平滑迁移方案/</id>
    <published>2019-06-12T13:26:09.000Z</published>
    <updated>2019-06-12T13:31:45.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据迁移方案"><a href="#数据迁移方案" class="headerlink" title="数据迁移方案"></a>数据迁移方案</h1><p>数据迁移核心思路抽象起来其实很简单，但如何稳定平滑迁移数据，我们会遇到不少问题，如：</p><ol><li>数据如何迁移？</li><li>如何校验数据迁移过程中的正确性？如果发现数据不一致，如何修复？</li><li>我们的业务改造有问题如何回滚？</li></ol><h3 id="数据同步中间件选型"><a href="#数据同步中间件选型" class="headerlink" title="数据同步中间件选型"></a>数据同步中间件选型</h3><p>开源数据同步中间件主要包括canal、otter、maxwell、kettle等，下面进行简单比对说明。</p><ul><li>canal：canal是阿里巴巴旗下的一款开源项目，纯Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费，目前主要支持了MySQL。</li><li>otter：阿里巴巴旗下的另一款开源项目，始于中美数据同步需求，纯Java开发。可以理解为canal+ETL，对数据抽取进行了扩展，加入自由门、反查等功能，拓展了已经无法从binlog获取的数据来源。同时提供页面的ETL编辑配置功能，方便快速实现带逻辑的业务数据同步。</li><li>maxwell：Maxwell 是java语言编写的能够读取、解析MySQL binlog，将行更新以json格式发送到 Kafka、RabbitMQ等，有了增量的数据流，可以想象的应用场景实在太多了，如ETL、维护缓存、收集表级别的dml指标、增量到搜索引擎、数据分区迁移、切库binlog回滚方案等等。</li><li>kettle:kettle可以实现从不同数据源（excel、数据库、文本文件等）获取数据，然后将数据进行整合、转换处理，可以再将数据输出到指定的位置（excel、数据库、文本文件）等；是B/S架构，多用于数仓作业。</li></ul><p>最终结合公司需求，otter功能最强大，二次开发比较方便，最终选择用otter来作为数据同步工具。</p><h3 id="重点原理阐述"><a href="#重点原理阐述" class="headerlink" title="重点原理阐述"></a>重点原理阐述</h3><ul><li><p>全量迁移：数据迁移首要目标如何将历史全量数据迁移到新库中，我们利用otter的自由门原理改造支持全量数据同步功能，整个过程都是查询在线库的备库，因此不影响在线业务的数据库服务，自由门原理如下：</p><p>  a. 基于otter系统表retl_buffer，插入特定的数据，包含需要同步的表名，pk信息。</p><p>  b. otter系统感知后会根据表名和pk提取对应的数据(整行记录)，和正常的增量同步一起同步到目标库。</p></li><li><p>增量迁移：通过模拟mysql slave获取binlog数据，然后通过canal解析增量数据，最终准实时同步数据。</p><blockquote><p>  方案一：先开启全量任务，等全量数据同步完成后，在开启增量任务。由于迁移过程中业务服务一直运行，因此全量迁移完全成，并且要将全量时间点后的数据追回来，这里核心原理是同步全量时间位点后binlog日志数据来保证数据一致性，需要注意的是增量时间需要前移一小断时间(如5分钟)，其主要原因是全量迁移启动的那刻会有时间差，需要增量前移来保证数据最终一致性。</p></blockquote><blockquote><p>方案二：先开启增量任务，然后开启全量任务，这种方案存在当全量和增量任务同时操作同一条pk数据的时候，就可能会产生丢失更新。推荐使用该方案，操作比较简单，这种场景出现的问题是很小的概率，最终还能通过数据校验服务来找到问题数据，然后用一键修复功能即可。</p></blockquote><p>  增量同步原理如下：</p><p>  a. 基于Canal获取数据库增量日志数据。</p><p>  b. 利用SETL调度模型实现调度和处理实现。</p><p>  c. 基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作。</p><p>  工作原理如下：</p><p>  <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/1.png" width="600px/"></p></li></ul><ul><li><p>反向同步：迁移到新库后，为了保证业务方出现业务回滚，保证源库与目标库数据一致性，需要建立从新库到老库的回流任务，原理跟增量迁移一样，只是变更一下原库及目标库。</p></li><li><p>一致性校验：通过比对源库和目标库的所有同步字段的crc校验码，如果出现不一致，重新比对3次，如果最终数据不一致，则会将该条数据落库。流程图如下：<br><img src="https://github.com/ppj19891020/pictures/blob/master/otter/7.png?raw=true" width="500px/"></p></li><li><p>一键修复：将一致性校验比对失败的数据，通过全量同步原理来触发数据修复功能。</p></li></ul><a id="more"></a><h1 id="项目分库分表实施总体方案"><a href="#项目分库分表实施总体方案" class="headerlink" title="项目分库分表实施总体方案"></a>项目分库分表实施总体方案</h1><h4 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h4><ol><li>业务系统改造和测试：业务方接入sharding-jdbc和分布式主键中间件，然后验收测试改造功能；</li><li>数据迁移：利用otter的数据迁移功能，涉及到全量迁移、增量迁移、一致性校验及反向任务。</li></ol><h4 id="迁库流程"><a href="#迁库流程" class="headerlink" title="迁库流程"></a>迁库流程</h4><p>事先一定创建好增量任务、全量任务、逆向任务和一致性校验任务等操作，然后如下操作：</p><ol><li>开启Otter增量同步,然后开通全量同步；</li><li>系统切换前做数据一致性校验，如若发现数据不一致，通过一键修复来修复数据；</li><li>业务系统升级；</li><li>升级完成后，同时关闭增量同步任务，防止无效覆盖；</li><li>反向同步任务要清空位点信息和手动设置canal位点信息，时间戳为关闭增量的时间，最后开启反向同步任务，数据回流老库；</li></ol><p>问题点：</p><ol><li><p>如何保证全量任务已同步完成？</p><blockquote><p>通过查看”总控通道”的最后位点时间如果一直没更新，就表示全量任务同步完成；目前由于全量数据量不可控制，推荐根据历史时间推算或者按照全量数据24小时之后来表示全量同步完成（通过线下环境测试，全量数据大概1分钟可以导入19w左右）；</p></blockquote></li><li><p>如何保证在开启反向任务之后，新库同步到老库数据丢失问题？</p><blockquote><p>在关闭正向同步之后，开启反向同步前，为了防止数据丢失，将反向同步的canal位点信息前移一段时间（停止正向增量任务的时间）；注意位点可以直接指定时间戳，如：{“journalName”:””,”position”:0,”timestamp”:1559628000000};</p></blockquote></li></ol><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/8.png" width="600px/"></p><h4 id="回滚方案"><a href="#回滚方案" class="headerlink" title="回滚方案"></a>回滚方案</h4><p>事先一定创建好逆向一致性校验任务等操作，然后如下操作：</p><ol><li>系统切换前做反向数据一致性校验，如若发现数据不一致，通过一键修复来修复数据；</li><li>业务系统回滚；</li><li>回滚完成后，同时关闭逆向增量任务；</li><li>正向同步任务要清空位点信息和手动设置cancal位点信息，时间戳为关闭逆向增量任务的时间，最后开启正向同步任务；</li></ol><p>问题点：</p><ol><li><p>业务一旦发生问题，一定要快速回滚，如何保证在短时间内能校验老库数据是一致的？</p><blockquote><p>针对需要快速校验和修复，同步前推荐业务方的同步表需要有”更新时间”字段,该字段最好有索引字段，这样既可以在校验服务中加入用”更新时间”的过滤条件，这样就可以不用全库校验，只校验这段时间内更新的数据；</p></blockquote></li><li><p>由于业务是在回滚完成之后，然后在开启正向增量同步，存在这段时间过程中的丢失更新？</p><blockquote><p>在关闭反向同步之后，开启正向同步前，为了防止丢失数据，将正向同步的canal位点信息前移一小断时间（停止反向同步的时间）；注意位点可以直接指定时间戳，如：{“journalName”:””,”position”:0,”timestamp”:1559628000000};</p></blockquote></li></ol><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/9.png" width="600px/"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据迁移方案&quot;&gt;&lt;a href=&quot;#数据迁移方案&quot; class=&quot;headerlink&quot; title=&quot;数据迁移方案&quot;&gt;&lt;/a&gt;数据迁移方案&lt;/h1&gt;&lt;p&gt;数据迁移核心思路抽象起来其实很简单，但如何稳定平滑迁移数据，我们会遇到不少问题，如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据如何迁移？&lt;/li&gt;
&lt;li&gt;如何校验数据迁移过程中的正确性？如果发现数据不一致，如何修复？&lt;/li&gt;
&lt;li&gt;我们的业务改造有问题如何回滚？&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;数据同步中间件选型&quot;&gt;&lt;a href=&quot;#数据同步中间件选型&quot; class=&quot;headerlink&quot; title=&quot;数据同步中间件选型&quot;&gt;&lt;/a&gt;数据同步中间件选型&lt;/h3&gt;&lt;p&gt;开源数据同步中间件主要包括canal、otter、maxwell、kettle等，下面进行简单比对说明。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;canal：canal是阿里巴巴旗下的一款开源项目，纯Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;amp;消费，目前主要支持了MySQL。&lt;/li&gt;
&lt;li&gt;otter：阿里巴巴旗下的另一款开源项目，始于中美数据同步需求，纯Java开发。可以理解为canal+ETL，对数据抽取进行了扩展，加入自由门、反查等功能，拓展了已经无法从binlog获取的数据来源。同时提供页面的ETL编辑配置功能，方便快速实现带逻辑的业务数据同步。&lt;/li&gt;
&lt;li&gt;maxwell：Maxwell 是java语言编写的能够读取、解析MySQL binlog，将行更新以json格式发送到 Kafka、RabbitMQ等，有了增量的数据流，可以想象的应用场景实在太多了，如ETL、维护缓存、收集表级别的dml指标、增量到搜索引擎、数据分区迁移、切库binlog回滚方案等等。&lt;/li&gt;
&lt;li&gt;kettle:kettle可以实现从不同数据源（excel、数据库、文本文件等）获取数据，然后将数据进行整合、转换处理，可以再将数据输出到指定的位置（excel、数据库、文本文件）等；是B/S架构，多用于数仓作业。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终结合公司需求，otter功能最强大，二次开发比较方便，最终选择用otter来作为数据同步工具。&lt;/p&gt;
&lt;h3 id=&quot;重点原理阐述&quot;&gt;&lt;a href=&quot;#重点原理阐述&quot; class=&quot;headerlink&quot; title=&quot;重点原理阐述&quot;&gt;&lt;/a&gt;重点原理阐述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;全量迁移：数据迁移首要目标如何将历史全量数据迁移到新库中，我们利用otter的自由门原理改造支持全量数据同步功能，整个过程都是查询在线库的备库，因此不影响在线业务的数据库服务，自由门原理如下：&lt;/p&gt;
&lt;p&gt;  a. 基于otter系统表retl_buffer，插入特定的数据，包含需要同步的表名，pk信息。&lt;/p&gt;
&lt;p&gt;  b. otter系统感知后会根据表名和pk提取对应的数据(整行记录)，和正常的增量同步一起同步到目标库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;增量迁移：通过模拟mysql slave获取binlog数据，然后通过canal解析增量数据，最终准实时同步数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  方案一：先开启全量任务，等全量数据同步完成后，在开启增量任务。由于迁移过程中业务服务一直运行，因此全量迁移完全成，并且要将全量时间点后的数据追回来，这里核心原理是同步全量时间位点后binlog日志数据来保证数据一致性，需要注意的是增量时间需要前移一小断时间(如5分钟)，其主要原因是全量迁移启动的那刻会有时间差，需要增量前移来保证数据最终一致性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;方案二：先开启增量任务，然后开启全量任务，这种方案存在当全量和增量任务同时操作同一条pk数据的时候，就可能会产生丢失更新。推荐使用该方案，操作比较简单，这种场景出现的问题是很小的概率，最终还能通过数据校验服务来找到问题数据，然后用一键修复功能即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  增量同步原理如下：&lt;/p&gt;
&lt;p&gt;  a. 基于Canal获取数据库增量日志数据。&lt;/p&gt;
&lt;p&gt;  b. 利用SETL调度模型实现调度和处理实现。&lt;/p&gt;
&lt;p&gt;  c. 基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作。&lt;/p&gt;
&lt;p&gt;  工作原理如下：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/1.png&quot; width=&quot;600px/&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;反向同步：迁移到新库后，为了保证业务方出现业务回滚，保证源库与目标库数据一致性，需要建立从新库到老库的回流任务，原理跟增量迁移一样，只是变更一下原库及目标库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一致性校验：通过比对源库和目标库的所有同步字段的crc校验码，如果出现不一致，重新比对3次，如果最终数据不一致，则会将该条数据落库。流程图如下：&lt;br&gt;&lt;img src=&quot;https://github.com/ppj19891020/pictures/blob/master/otter/7.png?raw=true&quot; width=&quot;500px/&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一键修复：将一致性校验比对失败的数据，通过全量同步原理来触发数据修复功能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="otter" scheme="blog.ppjys.cn/categories/otter/"/>
    
    
      <category term="otter" scheme="blog.ppjys.cn/tags/otter/"/>
    
  </entry>
  
  <entry>
    <title>Otter改造实践</title>
    <link href="blog.ppjys.cn/2019/06/12/Otter%E6%94%B9%E9%80%A0%E5%AE%9E%E8%B7%B5/"/>
    <id>blog.ppjys.cn/2019/06/12/Otter改造实践/</id>
    <published>2019-06-12T13:22:21.000Z</published>
    <updated>2019-06-12T13:31:25.485Z</updated>
    
    <content type="html"><![CDATA[<h3 id="otter简介"><a href="#otter简介" class="headerlink" title="otter简介"></a>otter简介</h3><p>Otter的业务域是支持异构数据库实时同步，数据记录变更订阅服务。<br>Otter需要保障数据库的事务一致性，包括DDL（表结构变更）也可以进行同步或过滤。而DBA天生就在这个坑里，绝对不能让主备不一致、或事务不完整，哪怕只是一条数据。而且DBA迫切希望以后不用通知下游了，让DRC自动适配主备切换或拆库。</p><p>定位：基于数据库增量日志解析，准实时同步到本机房或异地机房的mysql/oracle数据库.一个分布式数据库同步系统.</p><p>Otter具备的三大特性：</p><ul><li>1)稳定性，支持HA；</li><li>2)实时性;</li><li>3)一致性，数据同步前后必须保证数据的一致性;</li></ul><p>我们公司对Otter的需求场景：</p><ul><li>MySQL原生复制</li><li>大数据实时抽取</li><li>搜索实时索引</li><li>数据迁移</li></ul><h3 id="Otter架构"><a href="#Otter架构" class="headerlink" title="Otter架构"></a>Otter架构</h3><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/1.png" width="800px/"></p><p>数据同步过程可以分为Select–&gt;Extract、Transform–&gt;Load四个过程，也就是上图中的S、E、T、L，通过将这4个步骤进行服务拆分，每个服务都具有自己的线程池。通过S、L过程的串型，保证数据的一致性，E、T过程的并行提升系统处理的性能。</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><ol><li>基于Canal开源产品，获取数据库增量日志数据。</li><li><p>典型管理系统架构，manager(web管理)+node(工作节点)</p><p> a. manager运行时推送同步配置到node节点;<br> b. node节点将同步状态反馈到manager上;</p></li><li>基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作.</li></ol><a id="more"></a><h3 id="功能改造"><a href="#功能改造" class="headerlink" title="功能改造"></a>功能改造</h3><h4 id="分库分表支持"><a href="#分库分表支持" class="headerlink" title="分库分表支持"></a>分库分表支持</h4><p>原生的otter是不支持分库分表场景的，分库分表已经不属于Otter数据同步业务领域，但是分库分表的支持又是绝大多数功能数据同步不可避免的。</p><h5 id="我们公司业务在改造过程中，涉及到以下需求："><a href="#我们公司业务在改造过程中，涉及到以下需求：" class="headerlink" title="我们公司业务在改造过程中，涉及到以下需求："></a>我们公司业务在改造过程中，涉及到以下需求：</h5><ol><li>支持分库场景；</li><li>支持分表场景；</li><li>支持分库分表场景；</li><li>分片算法支持简单取模算法；</li><li>分片支持自定义算法，只需要实现DxyShardingAlgorithm接口即可；</li></ol><p>我们是在DataMedia上做扩展的，增加了分片类型、分片字段和分片算法字段。</p><ol><li><p>分库分表：</p><p> <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/2.jpg" width="500px/"></p></li><li><p>分表：  </p><p> <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/3.jpg" width="500px/"></p></li><li><p>分库：  </p><p> <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/4.jpg" width="500px/"></p></li></ol><h5 id="改造点"><a href="#改造点" class="headerlink" title="改造点"></a>改造点</h5><p>1).在Transform阶段进行了扩展，当目标数据表配置为分库分表时候，这时候会加载最终目标数据表的路由；</p><p>2).当eventdata不包含分片字段导致无法确定分片路由，我们将会为每个分片拷贝eventdata，解决多路拷贝分发；</p><p>3).多路拷贝情况下，针对多库多表，增加库表验证防止库表不一致路由问题；</p><p>4).在Extract阶段，针对数据库反查数据为空的情况，去除反查为null列（问题：通道同步模式为列模式，先插入数据，然后更新数据，最后删除数据，otter在Extract阶段会反查数据库查询未更新的列，此时该数据已删除，造成生成sql中出现null列）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分库分表路由计算</span></span><br><span class="line"><span class="comment"> * 在T模型中计算路由</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result 结果集</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targerDataMedia 目标datamedia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true表示需要过滤该条数据;false不需要过滤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShardingCalDTO <span class="title">sharingCalculate</span><span class="params">(EventData result, DataMedia targerDataMedia)</span></span>&#123;</span><br><span class="line">    ShardingCalDTO shardingCalDTO = <span class="keyword">new</span> ShardingCalDTO();</span><br><span class="line">    List&lt;ShardingCalDTO.ShardingDSDTO&gt; list = <span class="keyword">new</span> ArrayList&lt;ShardingCalDTO.ShardingDSDTO&gt;();</span><br><span class="line">    shardingCalDTO.setShardingDSDTOList(list);</span><br><span class="line">    <span class="keyword">if</span>(targerDataMedia.getShardingType().intValue() != ShardingTypeEnum.NORMAL.getCode())&#123;</span><br><span class="line">        DbMediaSource dbDataMediaSource = <span class="keyword">null</span>;<span class="comment">//最终数据源</span></span><br><span class="line">        String schema = <span class="string">""</span>;<span class="comment">//数据库</span></span><br><span class="line">        String table = <span class="string">""</span>;<span class="comment">//数据表`</span></span><br><span class="line">        List&lt;DbMediaSource&gt; sharingDataSources = targerDataMedia.getShardingDBSources();</span><br><span class="line">        Assert.assertNotNull(sharingDataSources);</span><br><span class="line">        <span class="comment">//数据源名称对应的数据元缓存</span></span><br><span class="line">        Map&lt;String,DbMediaSource&gt; dbMediaSourcemap = <span class="keyword">new</span> HashMap&lt;String,DbMediaSource&gt;(sharingDataSources.size());</span><br><span class="line">        <span class="comment">//列名对应column缓存</span></span><br><span class="line">        Map&lt;String, EventColumn&gt; columnMap = <span class="keyword">new</span> HashMap&lt;String, EventColumn&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(DbMediaSource dbMediaSource:sharingDataSources)&#123;</span><br><span class="line">            dbMediaSourcemap.put(dbMediaSource.getName(),dbMediaSource);</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != result.getKeys() &amp;&amp; <span class="number">0</span> != result.getKeys().size())&#123;</span><br><span class="line">            <span class="keyword">for</span>(EventColumn eventColumn:result.getKeys())&#123;</span><br><span class="line">                columnMap.put(eventColumn.getColumnName(),eventColumn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != result.getColumns() &amp;&amp; <span class="number">0</span> != result.getColumns().size())&#123;</span><br><span class="line"></span><br><span class="line">               columnMap.put(eventColumn.getColumnName(),eventColumn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(result.getEventType() == EventType.INSERT &amp;&amp; <span class="keyword">null</span> == columnMap.get(targerDataMedia.getShardingDBColumn()) &amp;&amp;</span><br><span class="line">                <span class="keyword">null</span> == columnMap.get(targerDataMedia.getShardingTableColumn()))&#123;</span><br><span class="line">            <span class="comment">//插入语句不存在分片键则直接跳过该数据</span></span><br><span class="line">            shardingCalDTO.setSkip(<span class="keyword">true</span>);</span><br><span class="line">            LOGGER.error(<span class="string">"插入语句不存在分片键，跳过 eventdate:&#123;&#125;"</span>,result.toString());</span><br><span class="line">            <span class="keyword">return</span> shardingCalDTO;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分库数据源计算</span></span><br><span class="line">        <span class="keyword">if</span>(targerDataMedia.getShardingType().intValue() == ShardingTypeEnum.SHARDING_TABLE.getCode())&#123;</span><br><span class="line">            <span class="comment">//分表情况</span></span><br><span class="line">            List&lt;ShardingTableDTO&gt; shardingTableDTOs = targerDataMedia.getShardingTableDTOS();</span><br><span class="line">            Assert.assertNotNull(shardingTableDTOs);</span><br><span class="line">            EventColumn eventColumn = columnMap.get(targerDataMedia.getShardingTableColumn());</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == eventColumn || <span class="keyword">null</span> == eventColumn.getColumnValue())&#123;</span><br><span class="line">                <span class="comment">//不存在分片键的时候，需要组装多数据源，用于组装多个evebtdata数据</span></span><br><span class="line">                <span class="keyword">for</span>(ShardingTableDTO shardingTableDTO:shardingTableDTOs)&#123;</span><br><span class="line">                    ShardingCalDTO.ShardingDSDTO shardingDSDTO = shardingCalDTO.new ShardingDSDTO();</span><br><span class="line">                    shardingDSDTO.setShardingDbMediaSource(dbMediaSourcemap.get(shardingTableDTO.getDsName()));</span><br><span class="line">                    shardingDSDTO.setShardingScheme(shardingTableDTO.getDbName());</span><br><span class="line">                    shardingDSDTO.setShardingTabele(shardingTableDTO.getTableName());</span><br><span class="line">                    list.add(shardingDSDTO);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dbDataMediaSource = dbMediaSourcemap.get(shardingTableDTOs.get(<span class="number">0</span>).getDsName());</span><br><span class="line">                schema = shardingTableDTOs.get(<span class="number">0</span>).getDbName();</span><br><span class="line">                ShardingTableDTO shardingTableDTOResult = shardingStrategyFactory.getSharingStrategy(shardingTableDTOs,targerDataMedia.getShardingTableAlgorithm(),</span><br><span class="line">                    targerDataMedia.getShardingTableColumn(), eventColumn.getColumnValue());</span><br><span class="line">                table = shardingTableDTOResult.getTableName();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//分库和分库分表情况</span></span><br><span class="line">            List&lt;ShardingDBDTO&gt; shardingDBDTOS = targerDataMedia.getShardingDBDTOS();</span><br><span class="line">            EventColumn dbColumn = columnMap.get(targerDataMedia.getShardingDBColumn());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != dbColumn &amp;&amp; <span class="keyword">null</span> != dbColumn.getColumnValue())&#123;</span><br><span class="line">                ShardingDBDTO shardingDBDTO = shardingStrategyFactory.getSharingStrategy(shardingDBDTOS,targerDataMedia.getShardingDBAlgorithm(),</span><br><span class="line">                    targerDataMedia.getShardingDBColumn(), dbColumn.getColumnValue());</span><br><span class="line">                dbDataMediaSource = dbMediaSourcemap.get(shardingDBDTO.getDsName());</span><br><span class="line">                schema = shardingDBDTO.getDbName();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(targerDataMedia.getShardingType().intValue() == ShardingTypeEnum.SHARDING_DB_TABLE.getCode()) &#123;</span><br><span class="line">                    List&lt;ShardingTableDTO&gt; shardingTableDTOs = targerDataMedia.getShardingTableDTOS();</span><br><span class="line">                    EventColumn tableColumn = columnMap.get(targerDataMedia.getShardingTableColumn());</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">null</span> == tableColumn || <span class="keyword">null</span> == tableColumn.getColumnValue()) &#123;</span><br><span class="line">                        <span class="comment">//如果分表键为空，则需要遍历所有的分表</span></span><br><span class="line">                        <span class="keyword">for</span>(ShardingTableDTO shardingTableDTO:shardingTableDTOs)&#123;</span><br><span class="line">                            ShardingCalDTO.ShardingDSDTO shardingDSDTO = shardingCalDTO.new ShardingDSDTO();</span><br><span class="line">                            shardingDSDTO.setShardingDbMediaSource(dbMediaSourcemap.get(shardingDBDTO.getDsName()));</span><br><span class="line">                            shardingDSDTO.setShardingScheme(shardingDBDTO.getDbName());</span><br><span class="line">                            shardingDSDTO.setShardingTabele(shardingTableDTO.getTableName());</span><br><span class="line">                            list.add(shardingDSDTO);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        ShardingTableDTO shardingTableDTO= shardingStrategyFactory.getSharingStrategy(shardingTableDTOs,targerDataMedia.getShardingTableAlgorithm(),</span><br><span class="line">                                targerDataMedia.getShardingTableColumn(), tableColumn.getColumnValue());</span><br><span class="line">                        table = shardingTableDTO.getTableName();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(targerDataMedia.getShardingType().intValue() == ShardingTypeEnum.SHARDING_DB.getCode()) &#123;</span><br><span class="line">                    table = targerDataMedia.getName();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//分片键为空</span></span><br><span class="line">                <span class="keyword">if</span>(targerDataMedia.getShardingType().intValue() == ShardingTypeEnum.SHARDING_DB_TABLE.getCode()) &#123;</span><br><span class="line">                    List&lt;ShardingTableDTO&gt; shardingTableDTOs = targerDataMedia.getShardingTableDTOS();</span><br><span class="line">                    <span class="keyword">for</span>(ShardingDBDTO shardingDBDTO:shardingDBDTOS)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(ShardingTableDTO shardingTableDTO:shardingTableDTOs)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(!shardingDBDTO.getAvaliableTabelName().contains(shardingTableDTO.getTableName()))&#123;</span><br><span class="line">                                LOGGER.warn(<span class="string">"跳过该表名:&#123;&#125; eventData:&#123;&#125;"</span>,shardingTableDTO.getTableName(),result.toString());</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ShardingCalDTO.ShardingDSDTO shardingDSDTO = shardingCalDTO.new ShardingDSDTO();</span><br><span class="line">                            shardingDSDTO.setShardingDbMediaSource(dbMediaSourcemap.get(shardingDBDTO.getDsName()));</span><br><span class="line">                            shardingDSDTO.setShardingScheme(shardingDBDTO.getDbName());</span><br><span class="line">                            shardingDSDTO.setShardingTabele(shardingTableDTO.getTableName());</span><br><span class="line">                            list.add(shardingDSDTO);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(targerDataMedia.getShardingType().intValue() == ShardingTypeEnum.SHARDING_DB.getCode())&#123;</span><br><span class="line">                    <span class="keyword">for</span>(ShardingDBDTO shardingDBDTO:shardingDBDTOS)&#123;</span><br><span class="line">                        ShardingCalDTO.ShardingDSDTO shardingDSDTO = shardingCalDTO.new ShardingDSDTO();</span><br><span class="line">                        shardingDSDTO.setShardingDbMediaSource(dbMediaSourcemap.get(shardingDBDTO.getDsName()));</span><br><span class="line">                        shardingDSDTO.setShardingScheme(shardingDBDTO.getDbName());</span><br><span class="line">                        shardingDSDTO.setShardingTabele(targerDataMedia.getName());</span><br><span class="line">                        list.add(shardingDSDTO);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != dbDataMediaSource &amp;&amp; StringUtils.isNotEmpty(schema) &amp;&amp; StringUtils.isNotEmpty(table))&#123;</span><br><span class="line">            ShardingCalDTO.ShardingDSDTO shardingDSDTO = shardingCalDTO.new ShardingDSDTO();</span><br><span class="line">            shardingDSDTO.setShardingDbMediaSource(dbDataMediaSource);</span><br><span class="line">            shardingDSDTO.setShardingScheme(schema);</span><br><span class="line">            shardingDSDTO.setShardingTabele(table);</span><br><span class="line">            list.add(shardingDSDTO);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shardingCalDTO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4).Load阶段改造合并sql适配分片合并；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把old中的值存在而new中不存在的值合并到new中,并且把old中的变更前的主键保存到new中的变更前的主键.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newEventData</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> oldEventData</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> EventData <span class="title">replaceColumnValue</span><span class="params">(EventData newEventData, EventData oldEventData)</span> </span>&#123;</span><br><span class="line">    List&lt;EventColumn&gt; newColumns = newEventData.getColumns();</span><br><span class="line">    List&lt;EventColumn&gt; oldColumns = oldEventData.getColumns();</span><br><span class="line">    List&lt;EventColumn&gt; temp = <span class="keyword">new</span> ArrayList&lt;EventColumn&gt;();</span><br><span class="line">    <span class="keyword">for</span> (EventColumn oldColumn : oldColumns) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> contain = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (EventColumn newColumn : newColumns) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldColumn.getColumnName().equalsIgnoreCase(newColumn.getColumnName())) &#123;</span><br><span class="line">                newColumn.setUpdate(newColumn.isUpdate() || oldColumn.isUpdate());<span class="comment">// 合并isUpdate字段</span></span><br><span class="line">                contain = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!contain) &#123;</span><br><span class="line">            temp.add(oldColumn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2019.04.18 by ppj 验证新的字段中是否存在通过反查还未查询到的列，</span></span><br><span class="line">    <span class="comment">// 这边做用旧值替换（先insert，后update情况下会出现，反正数据库做了not null验证导致挂起状态）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;newColumns.size();i++)&#123;</span><br><span class="line">        EventColumn newColumn = newColumns.get(i);</span><br><span class="line">        <span class="keyword">if</span>(newColumn.isReverse())&#123;</span><br><span class="line">            <span class="keyword">boolean</span> bol = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(EventColumn oldColumn:oldColumns)&#123;</span><br><span class="line">                <span class="keyword">if</span>(newColumn.getColumnName().equalsIgnoreCase(oldColumn.getColumnName()))&#123;</span><br><span class="line">                    newColumns.set(i,oldColumn);</span><br><span class="line">                    bol = <span class="keyword">true</span>;</span><br><span class="line">                    logger.warn(<span class="string">"insert-&gt;update 合并反查字段为空,重新设置反查字段 newEventData:&#123;&#125; oldEventData:&#123;&#125;"</span>,</span><br><span class="line">                            newEventData.toString(),oldEventData.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!bol)&#123;</span><br><span class="line">                newColumns.remove(i);</span><br><span class="line">                logger.warn(<span class="string">"insert-&gt;update 合并反查字段为空,移除该newEventData字段 newEventData:&#123;&#125; oldEventData:&#123;&#125;"</span>,</span><br><span class="line">                        newEventData.toString(),oldEventData.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newColumns.addAll(temp);</span><br><span class="line">    Collections.sort(newColumns, <span class="keyword">new</span> EventColumnIndexComparable()); <span class="comment">// 排序</span></span><br><span class="line">    <span class="comment">// 把上一次变更的旧主键传递到这次变更的旧主键.</span></span><br><span class="line">    newEventData.setOldKeys(oldEventData.getOldKeys());</span><br><span class="line">    <span class="keyword">if</span> (oldEventData.getSyncConsistency() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        newEventData.setSyncConsistency(oldEventData.getSyncConsistency());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldEventData.getSyncMode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        newEventData.setSyncMode(oldEventData.getSyncMode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldEventData.isRemedy()) &#123;</span><br><span class="line">        newEventData.setRemedy(oldEventData.isRemedy());</span><br><span class="line">    &#125;</span><br><span class="line">    newEventData.setSize(oldEventData.getSize() + newEventData.getSize());</span><br><span class="line">    <span class="keyword">return</span> newEventData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5).在Extract阶段，考虑update语句中数据库反查因查不到数据导致字段为null问题，增加去除null字段；</p><h4 id="全量数据迁移支持"><a href="#全量数据迁移支持" class="headerlink" title="全量数据迁移支持"></a>全量数据迁移支持</h4><p>原生的otter可以通过自由门来实现全量数据导入和修订功能。<br>自由门原理如下：</p><blockquote></blockquote><pre><code>a.基于otter系统表retl_buffer，插入特定的数据，包含需要同步的表名，pk信息。  b.otter系统感知后会根据表名和pk提取对应的数据(整行记录)，和正常的增量同步一起同步到目标库。</code></pre><p>我们公司业务在改造过程中，涉及到以下痛点：</p><ol><li>由于原先的otter系统表需要在每一个迁移实例建立retl.buffer表，当迁移的库比较多的时候，需要每个实例分别建立retl库，不利于统一控制，同时给库表元数据管理代理一定的难度；</li><li>由于全量数据迁移需要手动导入数据，增加迁移复杂度；</li></ol><h5 id="改造点-1"><a href="#改造点-1" class="headerlink" title="改造点"></a>改造点</h5><p>1)增加总控通道，所有的全量数据迁移统一用总控通道；</p><p>2)增加全量数据一键导入功能，自动将数据迁移至总控通道；</p><p>我们在Select阶段改造，将数据进行分批处理，每批的管道改造同步管道。（统一控制相对单独控制存在一个风险点：如果同步的这批存量数据在Extract阶段后和Load阶段前存在源库数据对应记录的修改，同时修改的增量binlog又比存量同步的数据同步更快，存在数据老数据覆盖新数据的风险，不过这种场景概率极小）</p><ol><li><p>总控全量迁移通道<br><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/5.png" width="500px/"></p></li><li><p>全量数据迁移任务<br><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/6.png" width="500px/"></p></li></ol><p>1）Select阶段改造<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置profiling信息</span></span><br><span class="line"><span class="keyword">boolean</span> profiling = isProfiling();</span><br><span class="line">Long profilingStartTime = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (profiling) &#123;</span><br><span class="line">    profilingStartTime = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MDC.put(OtterConstants.splitPipelineLogFileKey, String.valueOf(pipelineId));</span><br><span class="line">String currentName = Thread.currentThread().getName();</span><br><span class="line">Thread.currentThread().setName(createTaskName(pipelineId, <span class="string">"SelectWorker"</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    pipeline = configClientService.findPipeline(pipelineId);</span><br><span class="line">    List&lt;EventData&gt; eventData = message.getDatas();</span><br><span class="line">    <span class="keyword">long</span> startTime = etlEventData.getStartTime();</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(eventData)) &#123;</span><br><span class="line">        startTime = eventData.get(<span class="number">0</span>).getExecuteTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果数据来自RETL库RETL_BUFFER表，将数据分批，每批的管道改成同步管道信息</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.equalsIgnoreCase(RETL_BUFFER, pipeline.getPairs().get(<span class="number">0</span>).getSource().getName())</span><br><span class="line">            &amp;&amp; StringUtils.equalsIgnoreCase(RETL, pipeline.getPairs().get(<span class="number">0</span>).getSource().getNamespace())) &#123;</span><br><span class="line">        <span class="comment">//modify by pangpeijie 自由门改造支持</span></span><br><span class="line">        Map&lt;Long, Map&lt;Long,RowBatch&gt;&gt; rowBatchMap = OtterMigrateMap.makeComputingMap(<span class="keyword">new</span> Function&lt;Long, Map&lt;Long, RowBatch&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Map&lt;Long, RowBatch&gt; <span class="title">apply</span><span class="params">(@Nullable Long channelId)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> OtterMigrateMap.makeComputingMap(<span class="keyword">new</span> Function&lt;Long, RowBatch&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Nullable</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> RowBatch <span class="title">apply</span><span class="params">(@Nullable Long pipelineId)</span> </span>&#123;</span><br><span class="line">                        RowBatch rowBatch = <span class="keyword">new</span> RowBatch();</span><br><span class="line">                        Identity identity = <span class="keyword">new</span> Identity();</span><br><span class="line">                        identity.setChannelId(channelId);</span><br><span class="line">                        identity.setPipelineId(pipelineId);</span><br><span class="line">                        identity.setProcessId(etlEventData.getProcessId());</span><br><span class="line">                        rowBatch.setIdentity(identity);</span><br><span class="line">                        <span class="keyword">return</span> rowBatch;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据分批准备</span></span><br><span class="line">        <span class="keyword">for</span> (EventData data : eventData) &#123;</span><br><span class="line">            <span class="comment">// 获取每一条数据对应的pipeline</span></span><br><span class="line">            EventColumn pipelineColumn = getMatchColumn(data.getColumns(), PIPELINE_ID);</span><br><span class="line">            <span class="comment">// 获取每一条数据对应的channelID</span></span><br><span class="line">            EventColumn channelColumn = getMatchColumn(data.getColumns(),CHANNEL_ID);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == pipelineColumn || <span class="keyword">null</span> == channelColumn)&#123;</span><br><span class="line">                logger.error(<span class="string">"自由门数据问题，直接跳过,data:&#123;&#125;"</span>,data);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            RowBatch rowBatch = rowBatchMap.get(Long.parseLong(channelColumn.getColumnValue())).get(Long.parseLong(pipelineColumn.getColumnValue()));</span><br><span class="line">            rowBatch.merge(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始分批推送数据</span></span><br><span class="line">        Iterator channelIterator = rowBatchMap.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (channelIterator.hasNext())&#123;</span><br><span class="line">            Map.Entry channelEntry = (Map.Entry) channelIterator.next();</span><br><span class="line">            Long channelId = (Long)channelEntry.getKey();</span><br><span class="line">            Map&lt;Long, RowBatch&gt; rowBatchMaps = (Map&lt;Long, RowBatch&gt;)channelEntry.getValue();</span><br><span class="line">            Iterator pipelineIterator = rowBatchMaps.entrySet().iterator();</span><br><span class="line">            <span class="keyword">while</span> (pipelineIterator.hasNext())&#123;</span><br><span class="line">                Map.Entry pipelineEntry = (Map.Entry) pipelineIterator.next();</span><br><span class="line">                Long pipelineTempId = (Long)pipelineEntry.getKey();</span><br><span class="line">                RowBatch rowBatch = (RowBatch)pipelineEntry.getValue();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> nextNodeId = etlEventData.getNextNid();</span><br><span class="line">                List&lt;PipeKey&gt; pipeKeys = rowDataPipeDelegate.put(<span class="keyword">new</span> DbBatch(rowBatch), nextNodeId);</span><br><span class="line">                etlEventData.setDesc(pipeKeys);</span><br><span class="line">                etlEventData.setNumber((<span class="keyword">long</span>) rowBatch.getDatas().size());</span><br><span class="line">                etlEventData.setFirstTime(startTime); <span class="comment">// 使用原始数据的第一条</span></span><br><span class="line">                etlEventData.setBatchId(message.getId());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (profiling) &#123;</span><br><span class="line">                    Long profilingEndTime = System.currentTimeMillis();</span><br><span class="line">                    stageAggregationCollector.push(pipelineTempId,</span><br><span class="line">                            StageType.SELECT,</span><br><span class="line">                            <span class="keyword">new</span> AggregationItem(profilingStartTime, profilingEndTime));</span><br><span class="line">                &#125;</span><br><span class="line">                arbitrateEventService.selectEvent().single(etlEventData);</span><br><span class="line">                logger.info(<span class="string">"自由门 分批处理 channelId:&#123;&#125; pipelineId:&#123;&#125; data size:&#123;&#125;"</span>,channelId,pipelineTempId,rowBatch.getDatas().size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        Channel channel = configClientService.findChannelByPipelineId(pipelineId);</span><br><span class="line">        RowBatch rowBatch = <span class="keyword">new</span> RowBatch();</span><br><span class="line">        <span class="comment">// 构造唯一标识</span></span><br><span class="line">        Identity identity = <span class="keyword">new</span> Identity();</span><br><span class="line">        identity.setChannelId(channel.getId());</span><br><span class="line">        identity.setPipelineId(pipelineId);</span><br><span class="line">        identity.setProcessId(etlEventData.getProcessId());</span><br><span class="line">        rowBatch.setIdentity(identity);</span><br><span class="line">        <span class="comment">// 进行数据合并</span></span><br><span class="line">        <span class="keyword">for</span> (EventData data : eventData) &#123;</span><br><span class="line">            rowBatch.merge(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> nextNodeId = etlEventData.getNextNid();</span><br><span class="line">        List&lt;PipeKey&gt; pipeKeys = rowDataPipeDelegate.put(<span class="keyword">new</span> DbBatch(rowBatch), nextNodeId);</span><br><span class="line">        etlEventData.setDesc(pipeKeys);</span><br><span class="line">        etlEventData.setNumber((<span class="keyword">long</span>) eventData.size());</span><br><span class="line">        etlEventData.setFirstTime(startTime); <span class="comment">// 使用原始数据的第一条</span></span><br><span class="line">        etlEventData.setBatchId(message.getId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (profiling) &#123;</span><br><span class="line">            Long profilingEndTime = System.currentTimeMillis();</span><br><span class="line">            stageAggregationCollector.push(pipelineId,</span><br><span class="line">                    StageType.SELECT,</span><br><span class="line">                    <span class="keyword">new</span> AggregationItem(profilingStartTime, profilingEndTime));</span><br><span class="line">        &#125;</span><br><span class="line">        arbitrateEventService.selectEvent().single(etlEventData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isInterrupt(e)) &#123;</span><br><span class="line">        logger.error(String.format(<span class="string">"[%s] selectwork executor is error! data:%s"</span>,</span><br><span class="line">            pipelineId,</span><br><span class="line">            etlEventData), e);</span><br><span class="line">        sendRollbackTermin(pipelineId, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(String.format(<span class="string">"[%s] selectwork executor is interrrupt! data:%s"</span>,</span><br><span class="line">            pipelineId,</span><br><span class="line">            etlEventData), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Thread.currentThread().setName(currentName);</span><br><span class="line">    MDC.remove(OtterConstants.splitPipelineLogFileKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="数据校验支持"><a href="#数据校验支持" class="headerlink" title="数据校验支持"></a>数据校验支持</h4><p>原生的otter有数据一致性功能，原理是根据binlog延时超过最大阈值，然后通过反查数据库同步获取最新数据 (以数据库最新版本同步，解决交替性，比如设置一致性反查数据库延迟阀值为60秒，即当同步过程中发现数据延迟超过了60秒，就会基于PK反查一次数据库，拿到当前最新值进行同步，减少交替性的问题)，业务在改造过程中，涉及以下痛点：</p><ol><li>源库和目标库不能全量数据校验，导致业务方无法相信迁移数据可靠性；</li><li>如果出现数据不一致问题，通过人工修复数据流程比较繁琐；</li></ol><h5 id="改造点-2"><a href="#改造点-2" class="headerlink" title="改造点"></a>改造点</h5><ol><li>支持全量数据校验，通过比对用主键查询源库和目标库的crc校验码，如果出现不一致则会重试3次，最终落库；</li><li>根据全量数据校验查询到的不一致数据，通过全量任务触发来修复数据不一致；</li></ol><h4 id="脱敏数据改造"><a href="#脱敏数据改造" class="headerlink" title="脱敏数据改造"></a>脱敏数据改造</h4><p>原生的otter在数据安全方面做的比较差，业务在改造过程中，涉及到以下痛点：</p><ol><li>匿名用户可以查看所有同步任务进度和数据库实例的信息；</li><li>数据库实例账号密码明文存储；</li></ol><h5 id="改造点-3"><a href="#改造点-3" class="headerlink" title="改造点"></a>改造点</h5><ol><li>数据库账号密码采用密文存储；</li><li>manager管理端改造权限，分为管理用户和普通用户；管理用户具有最高权限；普通用户只能查看任务的基本信息、同步进度和日志等；</li><li>manager管理端数据库连接改造接入pk；</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;otter简介&quot;&gt;&lt;a href=&quot;#otter简介&quot; class=&quot;headerlink&quot; title=&quot;otter简介&quot;&gt;&lt;/a&gt;otter简介&lt;/h3&gt;&lt;p&gt;Otter的业务域是支持异构数据库实时同步，数据记录变更订阅服务。&lt;br&gt;Otter需要保障数据库的事务一致性，包括DDL（表结构变更）也可以进行同步或过滤。而DBA天生就在这个坑里，绝对不能让主备不一致、或事务不完整，哪怕只是一条数据。而且DBA迫切希望以后不用通知下游了，让DRC自动适配主备切换或拆库。&lt;/p&gt;
&lt;p&gt;定位：基于数据库增量日志解析，准实时同步到本机房或异地机房的mysql/oracle数据库.一个分布式数据库同步系统.&lt;/p&gt;
&lt;p&gt;Otter具备的三大特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1)稳定性，支持HA；&lt;/li&gt;
&lt;li&gt;2)实时性;&lt;/li&gt;
&lt;li&gt;3)一致性，数据同步前后必须保证数据的一致性;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们公司对Otter的需求场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL原生复制&lt;/li&gt;
&lt;li&gt;大数据实时抽取&lt;/li&gt;
&lt;li&gt;搜索实时索引&lt;/li&gt;
&lt;li&gt;数据迁移&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Otter架构&quot;&gt;&lt;a href=&quot;#Otter架构&quot; class=&quot;headerlink&quot; title=&quot;Otter架构&quot;&gt;&lt;/a&gt;Otter架构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/1.png&quot; width=&quot;800px/&quot;&gt;&lt;/p&gt;
&lt;p&gt;数据同步过程可以分为Select–&amp;gt;Extract、Transform–&amp;gt;Load四个过程，也就是上图中的S、E、T、L，通过将这4个步骤进行服务拆分，每个服务都具有自己的线程池。通过S、L过程的串型，保证数据的一致性，E、T过程的并行提升系统处理的性能。&lt;/p&gt;
&lt;h4 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot; class=&quot;headerlink&quot; title=&quot;原理：&quot;&gt;&lt;/a&gt;原理：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;基于Canal开源产品，获取数据库增量日志数据。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;典型管理系统架构，manager(web管理)+node(工作节点)&lt;/p&gt;
&lt;p&gt; a. manager运行时推送同步配置到node节点;&lt;br&gt; b. node节点将同步状态反馈到manager上;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="otter" scheme="blog.ppjys.cn/categories/otter/"/>
    
    
      <category term="otter" scheme="blog.ppjys.cn/tags/otter/"/>
    
  </entry>
  
  <entry>
    <title>分布式主键调研文档</title>
    <link href="blog.ppjys.cn/2018/12/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%BB%E9%94%AE%E8%B0%83%E7%A0%94%E6%96%B9%E6%A1%88/"/>
    <id>blog.ppjys.cn/2018/12/20/分布式主键调研方案/</id>
    <published>2018-12-20T15:28:28.000Z</published>
    <updated>2018-12-20T15:32:49.763Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识。随着数据日渐增长，对数据分库分表后需要有一个唯一ID来标识一条数据或消息，数据库的自增ID显然不能满足需求，此时一个能够生成全局唯一ID的系统是非常必要的。概括下来，那业务系统对ID号的要求有哪些呢？</p><ol><li>全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。</li><li>趋势递增：在MySQL InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用B-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。</li><li>单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。</li><li>信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。</li></ol><p>上述123对应三类不同的场景，3和4需求还是互斥的，无法使用同一个方案满足。</p><a id="more"></a><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><p>分布式主键的生成方式分为中心化和去中心化两大类。</p><ul><li>中心化方法包括SEQUENCE区间方案、基于redis的方案、基于zookeeper顺序节点；</li><li>非中心化方案包括UUID、mongodb的ObjectId、snowflake方案、基于Ignite的分布式ID生成器；</li></ul><h4 id="SEQUENCE区间方案"><a href="#SEQUENCE区间方案" class="headerlink" title="SEQUENCE区间方案"></a>SEQUENCE区间方案</h4><p>所有应用服务器去同一个库获取可使用的sequence（乐观锁保证一致性），得到（sequence，sequence+步长]个可被这个数据源使用的id，当应用服务器插入“步长”个数据后，再次去争取新的sequence区间。</p><p>以MySQL举例，利用给字段设置auto_increment_increment和auto_increment_offset来保证ID自增，每次业务使用下列SQL读写MySQL得到ID号。</p><blockquote><p>begin;<br>REPLACE INTO Tickets64 (stub) VALUES (‘a’);<br>SELECT LAST_INSERT_ID();<br>commit;</p></blockquote><p>优点：</p><ul><li>非常简单，利用现有数据库系统的功能实现，成本小，有DBA专业维护。</li><li>ID号单调自增，可以实现一些对ID有特殊要求的业务。</li></ul><p>缺点：</p><ul><li>强依赖DB，当DB异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。</li><li>ID发号性能瓶颈限制在单台MySQL的读写性能。</li></ul><h4 id="基于redis的方案"><a href="#基于redis的方案" class="headerlink" title="基于redis的方案"></a>基于redis的方案</h4><p>另一种中心化生成分布式主键的方式是采用Redis在内存中生成自增序列，通过redis的原子自增操作(incr接口)生成一个自增的序列。</p><p>优点：</p><ul><li>生成一个 全局连续递增 的数字类型主键。</li></ul><p>缺点：</p><ul><li>强依赖Redis，一旦Redis不可用导致系统不可用，属于致命问题，另外Redis的单点问题也需要解决，部署复杂度较高。</li></ul><h4 id="UUID方案"><a href="#UUID方案" class="headerlink" title="UUID方案"></a>UUID方案</h4><p>UUID 是 通用唯一识别码（Universally Unique Identifier）的缩写，是一种软件建构的标准，亦为开放软件基金会组织在分布式计算环境领域的一部分。其目的，是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。UUID有很多变种实现，目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID）。</p><p>UUID是一个由4个连字号(-)将32个字节长的字符串分隔后生成的字符串，总共36个字节长。算法的核心思想是结合机器的网卡、当地时间、一个随即数来生成GUID。从理论上讲，如果一台机器每秒产生10000000个GUID，则可以保证（概率意义上）3240年不重复。</p><p>优点：</p><ul><li>全局唯一，各种语言都有UUID现成实现，Mysql也有UUID实现。</li></ul><p>缺点：</p><ul><li>36个字符组成，按照目前Mysql最常用的编码Utf-8，每一个字符对应的索引成本是3字节，也就是一个UUID需要108个字节的索引存储成本，是最大数字类型（8字节）的13.5倍的存储成本。</li></ul><h4 id="mongodb的ObjectId"><a href="#mongodb的ObjectId" class="headerlink" title="mongodb的ObjectId"></a>mongodb的ObjectId</h4><p>objectid有12个字节，包含时间信息（4字节、秒为单位）、机器标识（3字节）、进程id（2字节）、计数器（3字节，初始值随机）。其中，时间位精度（秒或者毫秒）与序列位数，二者决定了单位时间内，对于同一个进程最多可产生多少唯一的ObjectId，在MongoDB中，那每秒就是2^24（16777216）。但是机器标识与进程id一定要保证是不重复的，否则极大概率上会产生重复的ObjectId。由于ObjectId生成12个字节的16进制表示，无法用现有基础类型存储，只能转化为字符串存储，对应24个字符。objectid的组成结构如下</p><table><thead><tr><th>4字节</th><th>3字节</th><th>2字节</th><th>3字节</th></tr></thead><tbody><tr><td>time</td><td>machine</td><td>pid</td><td>增量</td></tr></tbody></table><p>优点：</p><ul><li>全局唯一 。</li></ul><p>缺点：</p><ul><li>非数字类型，24个字符，按照目前Mysql最常用的编码Utf-8，每一个字符对应的索引成本是3字节，也就是一个ObjectId需要72个字节的索引存储成本，是最大数字类型（8字节）的9倍的存储成本。</li></ul><h4 id="IgniteAtomicSequence方案"><a href="#IgniteAtomicSequence方案" class="headerlink" title="IgniteAtomicSequence方案"></a>IgniteAtomicSequence方案</h4><p>Ignite是apache开源的框架，IgniteAtomicSequence接口提供了分布式的原子性序列，类似于分布式原子性的Long类型，但是他的值只能增长，他特有的功能是支持预留一定范围的序列值，来避免每次序列获取下一个值时都需要的昂贵的网络消耗和缓存更新，也就是，当在一个原子性序列上执行了incrementAndGet()（或者任何其他的原子性操作），数据结构会往前预留一定范围的序列值，他会保证对于这个序列实例来说跨集群的唯一性。 这个类型的使用是非常简单的，相关代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Ignite ignite = Ignition.start();</span><br><span class="line">IgniteAtomicSequence seq = ignite.atomicSequence(<span class="string">"seqName"</span>,<span class="comment">//序列名</span></span><br><span class="line"> <span class="number">0</span>, <span class="comment">//初始值</span></span><br><span class="line"><span class="keyword">true</span><span class="comment">//如果序列不存在则创建</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">long</span> currentValue = seq.get();<span class="comment">//获取当前值</span></span><br><span class="line">  <span class="keyword">long</span> newValue = seq.incrementAndGet();<span class="comment">//先加1再取值</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照前述，直接按照初始值0创建IgniteAtomicSequence，是有很大风险的，无法在生产环境下使用，而且存在长度不固定问题，所以还需要进一步想办法，研究的重点在于解决初始值的问题。 因为IgniteAtomicSequence的值为long型，而在Java中long类型的最大值是9223372036854775807，这个数值长度为19位，对于实际应用来说，是一个很大的值，但是对于常见的没有环境依赖的ID生成器来说，还是比较短的。因此我们打算在这方面做文章。 因为系统重置的一个重要指标就是时间，那么我们以时间作为参照，然后加上一个扩展，可能是一个比较理想的选择，我们以如下的规则作为初始值： 时间的yyyyMMddHHmmss+00000 这个长度正好是19位，然后每次加1，因为现在是2018年，这个规则在常规应用场景中，是不会超过long类型的最大值的。 但是，这个规则存在一个风险，就是假设不考虑实际应用和实际性能，如果增加操作业务量特别大，会使这个序列值快速进位，如果某个时间节点宕机后瞬间重启，是有可能存在重启后的初始值小于原来的最大值的，这时就无法保证唯一性了。</p><p>优点：</p><ul><li>简单，初始值从0开始递增</li><li>带时间值，方便阅读</li></ul><p>缺点：</p><ul><li>强依赖服务器时间，时钟回拨问题</li></ul><h4 id="snowflake方案"><a href="#snowflake方案" class="headerlink" title="snowflake方案"></a>snowflake方案</h4><p>Snowflake算法产生是为了满足Twitter每秒上万条消息的请求，每条消息都必须分配一条唯一的id，这些id还需要一些大致的顺序（方便客户端排序），并且在分布式系统中不同机器产生的id必须不同。Snowflake算法把时间戳，工作机器id，序列号组合在一起。生产Id的结构如下：</p><table><thead><tr><th>63</th><th>62-22</th><th>21-12</th><th>11-0</th></tr></thead><tbody><tr><td>1位：2</td><td>41位：支持69.7年（单位ms）</td><td>10位：1024</td><td>12位：4096</td></tr></tbody></table><p>默认情况下41bit的时间戳可以支持该算法使用到2018+69年，10bit的工作机器id可以支持1023台机器，序列号支持1毫秒产生4095个自增序列id。</p><p>优点：</p><ul><li>在服务器规模不是很大（不超过1024条件） 全局唯一 ，单机递增 ，是数字类型，存储索引成本低。</li></ul><p>缺点：</p><ul><li>机器规模大于1024无法支持，需要运维配合解决单机部署多个同服务进程问题。</li></ul><h4 id="mysql-left-segment数据库方案"><a href="#mysql-left-segment数据库方案" class="headerlink" title="mysql-left-segment数据库方案"></a>mysql-left-segment数据库方案</h4><p>基于第一种SEQUENCE区间方案，做了如下改变：</p><ul><li>原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用proxy server批量获取，每次获取一个segment(step决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。</li><li>各个业务不同的发号需求用biz_tag字段来区分，每个biz-tag的ID获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对biz_tag分库分表就行。</li><li>取号段的时机是在号段消耗完的时候进行的，也就意味着号段临界点的ID下发时间取决于下一次从DB取回号段的时间，并且在这期间进来的请求也会因为DB号段没有取回来，导致线程阻塞。为此，我们设置了一个消费进度阈值，用于当号段消费到某个点时就异步的把下一个号段加载到内存中。</li></ul><hr><p>test_tag在第一台Leaf机器上是1~1000的号段，当这个号段用完时，会去加载另一个长度为step=1000的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是3001~4000。同时数据库对应的biz_tag这条数据的max_id会从3000被更新成4000</p><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/16.png"></p><hr><p>采用双buffer的方式，Leaf服务内部有两个号段缓存区segment。当前号段已下发10%时，如果下一个号段未更新，则另启一个更新线程去更新下一个号段。当前号段全部下发完后，如果下个号段准备好了则切换到下个号段为当前segment接着下发，循环往复。</p><ul><li>每个biz-tag都有消费速度监控，通常推荐segment长度设置为服务高峰期发号QPS的600倍（10分钟），这样即使DB宕机，Leaf仍能持续发号10-20分钟不受影响。</li><li>每次请求来临时都会判断下个号段的状态，从而更新此号段，所以偶尔的网络抖动不会影响下个号段的更新。</li></ul><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/17.png"></p><hr><p>数据库表设计如下：</p><p><strong>left_segment: 号段存储表</strong><br>Field | Type | Null | Default | Extra | Desc |<br>—|—|—|—|—|—|<br>id | bigint(20) | NO | | | 主键id |<br>biz_tag | varchar(128) | NO | | 唯一索引 | 业务标识 |<br>max_id | bigint(20) | NO | 1 | | 该业务所被分配的ID号段的最大值 |<br>step | int(22) | NO | | 1000 | 表示每次分配的号段长度 |<br>desc | varchar(256) | YES | Null | | 备注信息 |<br>create_time | timestamp | NO | CURRENT_TIMESTAMP | | 创建时间 |<br>update_time | timestamp | NO | Null | on update CURRENT_TIMESTAMP | 更新时间 |</p><p><strong>left_segment_log: 号段更新日志表</strong><br>Field | Type | Null | Default | Extra | Desc |<br>—|—|—|—|—|—|<br>id | bigint(20) | NO | | 主键id | |<br>min_id | bigint(20) | NO | 1 | | 初始号段 |<br>max_id | bigint(20) | NO | 1 | | 更新后号段 |<br>ip | varchar(20) | YES | Null | | 更新应用ip |<br>create_time | timestamp | NO | CURRENT_TIMESTAMP | | 创建时间 |</p><p>优点：</p><ul><li>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。</li><li>ID号码是趋势递增的8byte的64位数字，满足上述数据库存储的主键要求。</li><li>容灾性高：Leaf服务内部有号段缓存，即使DB宕机，短时间内Leaf仍能正常对外提供服务。</li><li>可以自定义max_id的大小，非常方便业务从原有的ID方式上迁移过来。</li></ul><p>缺点：</p><ul><li>ID号码不够随机，能够泄露发号数量的信息，不太安全。</li><li>DB宕机会造成整个系统不可用。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于公司业务复杂度，最终选择去中心化的雪花算法分布式主键和中心化的mysql-left-segment数据库方案。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识。随着数据日渐增长，对数据分库分表后需要有一个唯一ID来标识一条数据或消息，数据库的自增ID显然不能满足需求，此时一个能够生成全局唯一ID的系统是非常必要的。概括下来，那业务系统对ID号的要求有哪些呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。&lt;/li&gt;
&lt;li&gt;趋势递增：在MySQL InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用B-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。&lt;/li&gt;
&lt;li&gt;单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。&lt;/li&gt;
&lt;li&gt;信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述123对应三类不同的场景，3和4需求还是互斥的，无法使用同一个方案满足。&lt;/p&gt;
    
    </summary>
    
      <category term="generate key" scheme="blog.ppjys.cn/categories/generate-key/"/>
    
    
      <category term="分布式主键" scheme="blog.ppjys.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%BB%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix参数详解</title>
    <link href="blog.ppjys.cn/2018/12/20/Hystrix%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <id>blog.ppjys.cn/2018/12/20/Hystrix参数详解/</id>
    <published>2018-12-20T15:26:27.000Z</published>
    <updated>2018-12-20T15:35:37.132Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Execution相关的属性的配置："><a href="#Execution相关的属性的配置：" class="headerlink" title="Execution相关的属性的配置："></a>Execution相关的属性的配置：</h3><ul><li><p>hystrix.command.default.execution.isolation.strategy 隔离策略，默认是Thread, 可选Thread｜Semaphore</p><ul><li><p>thread 通过线程数量来限制并发请求数，可以提供额外的保护，但有一定的延迟。一般用于网络调用  </p></li><li><p>semaphore 通过semaphore count来限制并发请求数，适用于无网络的高并发请求</p></li></ul></li><li>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds 命令执行超时时间，默认1000ms</li><li>hystrix.command.default.execution.timeout.enabled 执行是否启用超时，默认启用true</li><li>hystrix.command.default.execution.isolation.thread.interruptOnTimeout 发生超时是是否中断，默认true</li><li>hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests 最大并发请求数，默认10，该参数当使用ExecutionIsolationStrategy.SEMAPHORE策略时才有效。如果达到最大并发请求数，请求会被拒绝。理论上选择semaphore size的原则和选择thread size一致，但选用semaphore时每次执行的单元要比较小且执行速度快（ms级别），否则的话应该用thread。semaphore应该占整个容器（tomcat）的线程池的一小部分。</li></ul><a id="more"></a><h3 id="Fallback相关的属性"><a href="#Fallback相关的属性" class="headerlink" title="Fallback相关的属性"></a>Fallback相关的属性</h3><p>这些参数可以应用于Hystrix的THREAD和SEMAPHORE策略</p><ul><li>hystrix.command.default.fallback.isolation.semaphore.maxConcurrentRequests 如果并发数达到该设置值，请求会被拒绝和抛出异常并且fallback不会被调用。默认10</li><li>hystrix.command.default.fallback.enabled 当执行失败或者请求被拒绝，是否会尝试调用hystrixCommand.getFallback() 。默认true</li></ul><h3 id="Circuit-Breaker相关的属性"><a href="#Circuit-Breaker相关的属性" class="headerlink" title="Circuit Breaker相关的属性"></a>Circuit Breaker相关的属性</h3><ul><li>hystrix.command.default.circuitBreaker.enabled 用来跟踪circuit的健康性，如果未达标则让request短路。默认true</li><li>hystrix.command.default.circuitBreaker.requestVolumeThreshold 一个rolling window内最小的请求数。如果设为20，那么当一个rolling window的时间内（比如说1个rolling window是10秒）收到19个请求，即使19个请求都失败，也不会触发circuit break。默认20</li><li>hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds 触发短路的时间值，当该值设为5000时，则当触发circuit break后的5000毫秒内都会拒绝request，也就是5000毫秒后才会关闭circuit。默认5000</li><li>hystrix.command.default.circuitBreaker.errorThresholdPercentage错误比率阀值，如果错误率&gt;=该值，circuit会被打开，并短路所有请求触发fallback。默认50</li><li>hystrix.command.default.circuitBreaker.forceOpen 强制打开熔断器，如果打开这个开关，那么拒绝所有request，默认false</li><li>hystrix.command.default.circuitBreaker.forceClosed 强制关闭熔断器 如果这个开关打开，circuit将一直关闭且忽略circuitBreaker.errorThresholdPercentage</li></ul><h3 id="Metrics相关参数"><a href="#Metrics相关参数" class="headerlink" title="Metrics相关参数"></a>Metrics相关参数</h3><ul><li>hystrix.command.default.metrics.rollingStats.timeInMilliseconds 设置统计的时间窗口值的，毫秒值，circuit break 的打开会根据1个rolling window的统计来计算。若rolling window被设为10000毫秒，则rolling window会被分成n个buckets，每个bucket包含success，failure，timeout，rejection的次数的统计信息。默认10000</li><li>hystrix.command.default.metrics.rollingStats.numBuckets 设置一个rolling window被划分的数量，若numBuckets＝10，rolling window＝10000，那么一个bucket的时间即1秒。必须符合rolling window % numberBuckets == 0。默认10</li><li>hystrix.command.default.metrics.rollingPercentile.enabled 执行时是否enable指标的计算和跟踪，默认true</li><li>hystrix.command.default.metrics.rollingPercentile.timeInMilliseconds 设置rolling percentile window的时间，默认60000</li><li>hystrix.command.default.metrics.rollingPercentile.numBuckets 设置rolling percentile window的numberBuckets。逻辑同上。默认6</li><li>hystrix.command.default.metrics.rollingPercentile.bucketSize 如果bucket size＝100，window＝10s，若这10s里有500次执行，只有最后100次执行会被统计到bucket里去。增加该值会增加内存开销以及排序的开销。默认100</li><li>hystrix.command.default.metrics.healthSnapshot.intervalInMilliseconds 记录health 快照（用来统计成功和错误绿）的间隔，默认500ms</li></ul><h3 id="Request-Context-相关参数"><a href="#Request-Context-相关参数" class="headerlink" title="Request Context 相关参数"></a>Request Context 相关参数</h3><ul><li>hystrix.command.default.requestCache.enabled 默认true，需要重载getCacheKey()，返回null时不缓存</li><li>hystrix.command.default.requestLog.enabled 记录日志到HystrixRequestLog，默认true</li></ul><h3 id="Collapser-Properties-相关参数"><a href="#Collapser-Properties-相关参数" class="headerlink" title="Collapser Properties 相关参数"></a>Collapser Properties 相关参数</h3><ul><li>hystrix.collapser.default.maxRequestsInBatch 单次批处理的最大请求数，达到该数量触发批处理，默认Integer.MAX_VALUE</li><li>hystrix.collapser.default.timerDelayInMilliseconds 触发批处理的延迟，也可以为创建批处理的时间＋该值，默认10</li><li>hystrix.collapser.default.requestCache.enabled 是否对HystrixCollapser.execute() and HystrixCollapser.queue()的cache，默认true</li></ul><h3 id="ThreadPool-相关参数"><a href="#ThreadPool-相关参数" class="headerlink" title="ThreadPool 相关参数"></a>ThreadPool 相关参数</h3><p>线程数默认值10适用于大部分情况（有时可以设置得更小），如果需要设置得更大，那有个基本得公式可以follow：<br>requests per second at peak when healthy × 99th percentile latency in seconds + some breathing room<br>每秒最大支撑的请求数 (99%平均响应时间 + 缓存值)<br>比如：每秒能处理1000个请求，99%的请求响应时间是60ms，那么公式是：<br>1000 （0.060+0.012）</p><p>基本得原则时保持线程池尽可能小，他主要是为了释放压力，防止资源被阻塞。<br>当一切都是正常的时候，线程池一般仅会有1到2个线程激活来提供服务</p><ul><li>hystrix.threadpool.default.coreSize 并发执行的最大线程数，默认10</li><li>hystrix.threadpool.default.maxQueueSize BlockingQueue的最大队列数，当设为－1，会使用SynchronousQueue，值为正时使用LinkedBlcokingQueue。该设置只会在初始化时有效，之后不能修改threadpool的queue size，除非reinitialising thread executor。默认－1。</li><li>hystrix.threadpool.default.queueSizeRejectionThreshold 即使maxQueueSize没有达到，达到queueSizeRejectionThreshold该值后，请求也会被拒绝。因为maxQueueSize不能被动态修改，这个参数将允许我们动态设置该值。if maxQueueSize == -1，该字段将不起作用</li><li>hystrix.threadpool.default.keepAliveTimeMinutes 如果corePoolSize和maxPoolSize设成一样（默认实现）该设置无效。如果通过plugin（<a href="https://github.com/Netflix/Hystrix/wiki/Plugins）使用自定义实现，该设置才有用，默认1" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki/Plugins）使用自定义实现，该设置才有用，默认1</a>.</li><li>hystrix.threadpool.default.metrics.rollingStats.timeInMilliseconds 线程池统计指标的时间，默认10000</li><li>hystrix.threadpool.default.metrics.rollingStats.numBuckets 将rolling window划分为n个buckets，默认10</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Execution相关的属性的配置：&quot;&gt;&lt;a href=&quot;#Execution相关的属性的配置：&quot; class=&quot;headerlink&quot; title=&quot;Execution相关的属性的配置：&quot;&gt;&lt;/a&gt;Execution相关的属性的配置：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;hystrix.command.default.execution.isolation.strategy 隔离策略，默认是Thread, 可选Thread｜Semaphore&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;thread 通过线程数量来限制并发请求数，可以提供额外的保护，但有一定的延迟。一般用于网络调用  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;semaphore 通过semaphore count来限制并发请求数，适用于无网络的高并发请求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds 命令执行超时时间，默认1000ms&lt;/li&gt;
&lt;li&gt;hystrix.command.default.execution.timeout.enabled 执行是否启用超时，默认启用true&lt;/li&gt;
&lt;li&gt;hystrix.command.default.execution.isolation.thread.interruptOnTimeout 发生超时是是否中断，默认true&lt;/li&gt;
&lt;li&gt;hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests 最大并发请求数，默认10，该参数当使用ExecutionIsolationStrategy.SEMAPHORE策略时才有效。如果达到最大并发请求数，请求会被拒绝。理论上选择semaphore size的原则和选择thread size一致，但选用semaphore时每次执行的单元要比较小且执行速度快（ms级别），否则的话应该用thread。semaphore应该占整个容器（tomcat）的线程池的一小部分。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="微服务" scheme="blog.ppjys.cn/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="限流熔断器" scheme="blog.ppjys.cn/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%99%90%E6%B5%81%E7%86%94%E6%96%AD%E5%99%A8/"/>
    
    
      <category term="hystrix" scheme="blog.ppjys.cn/tags/hystrix/"/>
    
  </entry>
  
  <entry>
    <title>并发包Callable、Future和FutureTask源码分析</title>
    <link href="blog.ppjys.cn/2018/12/11/%E5%B9%B6%E5%8F%91%E5%8C%85Callable%E3%80%81Future%E5%92%8CFutureTask%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>blog.ppjys.cn/2018/12/11/并发包Callable、Future和FutureTask源码分析/</id>
    <published>2018-12-11T15:24:30.000Z</published>
    <updated>2018-12-11T15:25:57.315Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>线程任务执行如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。</p><p>而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p><p>今天我们就来讨论一下Callable、Future和FutureTask三个类的使用方法。</p><h4 id="Callable与Runnable"><a href="#Callable与Runnable" class="headerlink" title="Callable与Runnable"></a>Callable与Runnable</h4><p>先说一下java.lang.Runnable吧，它是一个接口，在它里面只声明了一个run()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    /**</span><br><span class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span><br><span class="line">     * to create a thread, starting the thread causes the object&apos;s</span><br><span class="line">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span><br><span class="line">     * thread.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span><br><span class="line">     * take any action whatsoever.</span><br><span class="line">     *</span><br><span class="line">     * @see     java.lang.Thread#run()</span><br><span class="line">     */</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p><p>Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     */</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。</p><p>那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure></p><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p><p>Future类位于java.util.concurrent包下，它是一个接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。</span><br><span class="line">     * 参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，</span><br><span class="line">     * 如果设置true，则表示可以取消正在执行过程中的任务。</span><br><span class="line">     * 如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，</span><br><span class="line">     * 即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，</span><br><span class="line">     * 则返回true，若mayInterruptIfRunning设置为false，则返回false；</span><br><span class="line">     * 如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</span><br><span class="line">     * @param mayInterruptIfRunning</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean isCancelled();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 表示任务是否已经完成，若任务完成，则返回true；</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean isDone();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</span><br><span class="line">     * @return</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     * @throws ExecutionException</span><br><span class="line">     */</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</span><br><span class="line">     *</span><br><span class="line">     * @param timeout</span><br><span class="line">     * @param unit</span><br><span class="line">     * @return</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     * @throws ExecutionException</span><br><span class="line">     * @throws TimeoutException</span><br><span class="line">     */</span><br><span class="line">    V get(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="RunnableFuture"><a href="#RunnableFuture" class="headerlink" title="RunnableFuture"></a>RunnableFuture</h4><p>RunnableFuture作为 Runnable 的 Future。成功执行 run 方法可以完成 Future 并允许访问其结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 作为 Runnable 的 Future。成功执行 run 方法可以完成 Future 并允许访问其结果。 </span><br><span class="line"> * A &#123;@link Future&#125; that is &#123;@link Runnable&#125;. Successful execution of</span><br><span class="line"> * the &#123;@code run&#125; method causes completion of the &#123;@code Future&#125;</span><br><span class="line"> * and allows access to its results.</span><br><span class="line"> * @see FutureTask</span><br><span class="line"> * @see Executor</span><br><span class="line"> * @since 1.6</span><br><span class="line"> * @author Doug Lea</span><br><span class="line"> * @param &lt;V&gt; The result type returned by this Future&apos;s &#123;@code get&#125; method</span><br><span class="line"> */</span><br><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Sets this Future to the result of its computation</span><br><span class="line">     * unless it has been cancelled.</span><br><span class="line">     */</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>我们先来看一下FutureTask的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</span><br></pre></td></tr></table></figure></p><p>FutureTask类实现了RunnableFuture接口，我们看一下RunnableFuture接口的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。<br>FutureTask提供了2个构造器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">&#125;</span><br><span class="line">public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package com.fly.learn.aqs;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 测试future</span><br><span class="line"> * @author: peijiepang</span><br><span class="line"> * @date 2018-12-11</span><br><span class="line"> * @Description:</span><br><span class="line"> */</span><br><span class="line">public class FuthreTest &#123;</span><br><span class="line">    private final static Logger LOGGER = LoggerFactory.getLogger(FuthreTest.class);</span><br><span class="line">    private static ThreadPoolExecutor executorService = new ThreadPoolExecutor(1, 1, 1L, TimeUnit.MINUTES,</span><br><span class="line">            new ArrayBlockingQueue&lt;Runnable&gt;(100),new ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Future futureOne = executorService.submit(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                LOGGER.info(&quot;start runable one&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Future futureTwo = executorService.submit(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                LOGGER.info(&quot;start runable two&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Future futureThree=null;</span><br><span class="line">        try &#123;</span><br><span class="line">            futureThree = executorService.submit(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    LOGGER.info(&quot;start runable three&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            LOGGER.error(e.getLocalizedMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; futureFour = executorService.submit(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Integer call() throws Exception &#123;</span><br><span class="line">                Thread.sleep(5000L);</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String call() throws Exception &#123;</span><br><span class="line">                Thread.sleep(5000L);</span><br><span class="line">                return &quot;ok&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(futureTask);</span><br><span class="line"></span><br><span class="line">        LOGGER.info(&quot;task one &quot; + futureOne.get());</span><br><span class="line">        LOGGER.info(&quot;task two &quot; + futureTwo.get());</span><br><span class="line">        LOGGER.info(&quot;task three &quot; + (futureThree==null?null:futureThree.get()));</span><br><span class="line">        LOGGER.info(&quot;task fore &quot;+futureFour.get());</span><br><span class="line">        LOGGER.info(&quot;futureTask &quot;+futureTask.get());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FutureTask源码分析"><a href="#FutureTask源码分析" class="headerlink" title="FutureTask源码分析"></a>FutureTask源码分析</h3><h4 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h4><p>在使用ThreadPoolExecutor使用submit提交任务后然后交给线程池中的线程去执行，是把在ThreadPoolExecutor(其实是在AbstractExecutorService中)有如下几个submit方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    if (task == null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br><span class="line">public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123;</span><br><span class="line">    if (task == null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br><span class="line">public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;</span><br><span class="line">    if (task == null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Returns a &#123;@code RunnableFuture&#125; for the given callable task.</span><br><span class="line"> *</span><br><span class="line"> * @param callable the callable task being wrapped</span><br><span class="line"> * @param &lt;T&gt; the type of the callable&apos;s result</span><br><span class="line"> * @return a &#123;@code RunnableFuture&#125; which, when run, will call the</span><br><span class="line"> * underlying callable and which, as a &#123;@code Future&#125;, will yield</span><br><span class="line"> * the callable&apos;s result as its result and provide for</span><br><span class="line"> * cancellation of the underlying task</span><br><span class="line"> * @since 1.6</span><br><span class="line"> */</span><br><span class="line">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123;</span><br><span class="line">    return new FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Returns a &#123;@code RunnableFuture&#125; for the given runnable and default</span><br><span class="line"> * value.</span><br><span class="line"> *</span><br><span class="line"> * @param runnable the runnable task being wrapped</span><br><span class="line"> * @param value the default value for the returned future</span><br><span class="line"> * @param &lt;T&gt; the type of the given value</span><br><span class="line"> * @return a &#123;@code RunnableFuture&#125; which, when run, will run the</span><br><span class="line"> * underlying runnable and which, as a &#123;@code Future&#125;, will yield</span><br><span class="line"> * the given value as its result and provide for cancellation of</span><br><span class="line"> * the underlying task</span><br><span class="line"> * @since 1.6</span><br><span class="line"> */</span><br><span class="line">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123;</span><br><span class="line">    return new FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 任务状态</span><br><span class="line"> * The run state of this task, initially NEW.  The run state</span><br><span class="line"> * transitions to a terminal state only in methods set,</span><br><span class="line"> * setException, and cancel.  During completion, state may take on</span><br><span class="line"> * transient values of COMPLETING (while outcome is being set) or</span><br><span class="line"> * INTERRUPTING (only while interrupting the runner to satisfy a</span><br><span class="line"> * cancel(true)). Transitions from these intermediate to final</span><br><span class="line"> * states use cheaper ordered/lazy writes because values are unique</span><br><span class="line"> * and cannot be further modified.</span><br><span class="line"> *</span><br><span class="line"> * Possible state transitions:</span><br><span class="line"> * NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="line"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="line"> * NEW -&gt; CANCELLED</span><br><span class="line"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="line"> */</span><br><span class="line">private volatile int state;</span><br><span class="line">private static final int NEW          = 0;//任务执行阶段，结果赋值前</span><br><span class="line">private static final int COMPLETING   = 1;//结果赋值阶段</span><br><span class="line">private static final int NORMAL       = 2;//任务执行完毕</span><br><span class="line">private static final int EXCEPTIONAL  = 3;//任务执行时发生异常</span><br><span class="line">private static final int CANCELLED    = 4;//任务被取消</span><br><span class="line">private static final int INTERRUPTING = 5;//设置中断变量阶段</span><br><span class="line">private static final int INTERRUPTED  = 6;//任务中断</span><br><span class="line"></span><br><span class="line">/** The underlying callable; nulled out after running */</span><br><span class="line">private Callable&lt;V&gt; callable;</span><br><span class="line">//任务返回值，正常返回时是泛型指定对象，任务异常时是Throwable对象，它在state=COMPLETING阶段完成赋值操作</span><br><span class="line">/** The result to return or exception to throw from get() */</span><br><span class="line">private Object outcome; // non-volatile, protected by state reads/writes</span><br><span class="line">//当前执行任务线程，run()方法开始时进行判断和赋值，保证同一时刻只有一个线程执行FutureTask，并且FutureTask.run()只能执行一次。</span><br><span class="line">/** The thread running the callable; CASed during run() */</span><br><span class="line">private volatile Thread runner;</span><br><span class="line">//阻塞队列头节点，每个节点存储调用FutureTask.get()方法，且采用LockSupport.park()阻塞的线程。在任务对outcome完成赋值后，调用finishCompletion()唤醒所有阻塞线程。</span><br><span class="line">/** Treiber stack of waiting threads */</span><br><span class="line">private volatile WaitNode waiters;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将等待线程封装成节点，形成等待队列</span><br><span class="line"> * Simple linked list nodes to record waiting threads in a Treiber</span><br><span class="line"> * stack.  See other classes such as Phaser and SynchronousQueue</span><br><span class="line"> * for more detailed explanation.</span><br><span class="line"> */</span><br><span class="line">static final class WaitNode &#123;</span><br><span class="line">    volatile Thread thread;</span><br><span class="line">    volatile WaitNode next;</span><br><span class="line">    WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//UNSAFE类提供高效并且线程安全方式操作变量，直接和内存数据打交道，</span><br><span class="line">// 但是分配的内存需要手动释放。由于UNSAFE类只提供给JVM信任的启动类加载器所使用，这里采用反射获取UNSAFE对象。</span><br><span class="line">// Unsafe mechanics</span><br><span class="line">private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">//state参数在内存中对象的偏移量</span><br><span class="line">private static final long stateOffset;</span><br><span class="line">//runner参数在内存中对象的偏移量</span><br><span class="line">private static final long runnerOffset;</span><br><span class="line">//waiter参数在内存中对象的偏移量</span><br><span class="line">private static final long waitersOffset;</span><br><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //通过反射的方式来访问Unsafe类中的theUnsafe静态成员变量，该theUnsafe静态成员变量在Unsafe第一次使用时就已经初始化。</span><br><span class="line">        UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = FutureTask.class;</span><br><span class="line">        stateOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;state&quot;));</span><br><span class="line">        runnerOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;runner&quot;));</span><br><span class="line">        waitersOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;waiters&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isDown方法"><a href="#isDown方法" class="headerlink" title="isDown方法"></a>isDown方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 因为NEW表示任务执行阶段，因此判断任务是否完成</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean isDone() &#123;</span><br><span class="line">    return state != NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cancel方法"><a href="#cancel方法" class="headerlink" title="cancel方法"></a>cancel方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 如果任务在NEW阶段，mayInterruptIfRunning == true，且能CAS能修改state值，中断当前线程，调用finishCompletion()</span><br><span class="line"> * @param mayInterruptIfRunning</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean cancel(boolean mayInterruptIfRunning) &#123;</span><br><span class="line">    //判断当前任务状态是否为NEW，并且cas操作能否成功修改state值，如果不能，返回false</span><br><span class="line">    if (!(state == NEW &amp;&amp;</span><br><span class="line">          UNSAFE.compareAndSwapInt(this, stateOffset, NEW,</span><br><span class="line">              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        return false;</span><br><span class="line">    try &#123;    // in case call to interrupt throws exception</span><br><span class="line">        if (mayInterruptIfRunning) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                if (t != null)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; finally &#123; // final state</span><br><span class="line">                // 修改state为INTERRUPTED状态</span><br><span class="line">                UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //唤醒所有调用get方法等待线程队列</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isCancelled方法"><a href="#isCancelled方法" class="headerlink" title="isCancelled方法"></a>isCancelled方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 其实就是指线程中断中和中断状态</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean isCancelled() &#123;</span><br><span class="line">    return state &gt;= CANCELLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主流程get-方法"><a href="#主流程get-方法" class="headerlink" title="主流程get()方法"></a>主流程get()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 如果任务正在执行或者正在赋值，调用awaitDone()方法，阻塞当前线程，且封装成WaitNode，放入等待队列中</span><br><span class="line"> * 否则，调用report()，将outcome包装成返回参数类型。</span><br><span class="line"> * @throws CancellationException &#123;@inheritDoc&#125;</span><br><span class="line"> */</span><br><span class="line">public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    int s = state;</span><br><span class="line">    if (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(false, 0L);</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 功能：制定线程等待结果的具体实行策略</span><br><span class="line"> *</span><br><span class="line"> * 逻辑</span><br><span class="line"> * for中判断当前线程是否被中断，如果是抛出异常</span><br><span class="line"> *</span><br><span class="line"> * 一、如果state == NEW（运行状态）</span><br><span class="line"> * 将当前线程包装成WaitNode，并CAS放入队列头部。（期间如果状态改变，可能其中某些步骤未进行）</span><br><span class="line"> * 如果timed == true，计算超时时间，已经超过设置时间，移除队列节点，返回</span><br><span class="line"> * 未超过设置时间，阻塞线程到设置时间</span><br><span class="line"> * 这几个操作是层级关系，如果一直保持state == NEW，将进行：</span><br><span class="line"> * 创建WaitNode</span><br><span class="line"> * CAS放入队列头部</span><br><span class="line"> * 超时移除节点并返回</span><br><span class="line"> * 未超时调用parkNanos()阻塞线程</span><br><span class="line"> * 二、如果state == COMPLETING（赋值阶段）</span><br><span class="line"> * 当前线程yield(),等待状态更新</span><br><span class="line"> *</span><br><span class="line"> * 三、如果state &gt; COMPLETING</span><br><span class="line"> * 将等待队列中该线程节点的thread参数设置为null</span><br><span class="line"> *</span><br><span class="line"> * System.nanoTime :返回的可能是任意时间，甚至为负，相对于System.concurrentTime更加精确。</span><br><span class="line"> * 用于记录一个时间段。</span><br><span class="line"> *</span><br><span class="line"> * 返回结果：state</span><br><span class="line"> * state &lt;= COMPLETING,表示获取结果失败，可能是超时，可能是执行错误</span><br><span class="line"> * state &gt; COMPLETING，表示获取结果成功</span><br><span class="line"> */</span><br><span class="line">private int awaitDone(boolean timed, long nanos)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    final long deadline = timed ? System.nanoTime() + nanos : 0L;</span><br><span class="line">    WaitNode q = null;</span><br><span class="line">    boolean queued = false;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            //判断当前线程是否被中断,中断将移除等待队列中的</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int s = state;</span><br><span class="line">        if (s &gt; COMPLETING) &#123;</span><br><span class="line">            if (q != null)</span><br><span class="line">                q.thread = null;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (s == COMPLETING) // cannot time out yet</span><br><span class="line">            Thread.yield();</span><br><span class="line">        else if (q == null)</span><br><span class="line">            q = new WaitNode();</span><br><span class="line">        else if (!queued)</span><br><span class="line">            //在队列头部添加q，并将q赋值给waiters</span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        else if (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            if (nanos &lt;= 0L) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                return state;</span><br><span class="line">            &#125;</span><br><span class="line">            //将线程阻塞，设置阻塞时间为nanos</span><br><span class="line">            LockSupport.parkNanos(this, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            LockSupport.park(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 功能：返回任务结果</span><br><span class="line"> * 描述： 由于在set(),setException() 方法中设置了otcome的值，</span><br><span class="line"> *  可能是throwable对象，也可能是正常返回结果，所以需要</span><br><span class="line"> *  对outcome进行一次处理</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private V report(int s) throws ExecutionException &#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    if (s == NORMAL)</span><br><span class="line">        return (V)x;</span><br><span class="line">    if (s &gt;= CANCELLED)</span><br><span class="line">        throw new CancellationException();</span><br><span class="line">    throw new ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 定时获取结果</span><br><span class="line"> */</span><br><span class="line">public V get(long timeout, TimeUnit unit)</span><br><span class="line">throws InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">if(unit == null)</span><br><span class="line">throw new NullPointerException();</span><br><span class="line">int s = state;</span><br><span class="line">if (s &lt;= COMPLETING &amp;&amp; (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">throw new TimeoutException();</span><br><span class="line">return report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断：状态是否为NEW，并CAS成功将runner线程赋值为当前线程</span><br><span class="line"> * 线程调用run(),进行判断，运行callable.call()，再调用set()将结果设置到outcome。</span><br><span class="line"> * 失败调用setException()，将Throwable对象设置到outcome。</span><br><span class="line"> */</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(this, runnerOffset,</span><br><span class="line">                                     null, Thread.currentThread()))</span><br><span class="line">        return;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            boolean ran;</span><br><span class="line">            try &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                result = null;</span><br><span class="line">                ran = false;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // runner must be non-null until state is settled to</span><br><span class="line">        // prevent concurrent calls to run()</span><br><span class="line">        runner = null;</span><br><span class="line">        // state must be re-read after nulling runner to prevent</span><br><span class="line">        // leaked interrupts</span><br><span class="line">        int s = state;</span><br><span class="line">        if (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设置返回结果</span><br><span class="line"> * Sets the result of this future to the given value unless</span><br><span class="line"> * this future has already been set or has been cancelled.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method is invoked internally by the &#123;@link #run&#125; method</span><br><span class="line"> * upon successful completion of the computation.</span><br><span class="line"> *</span><br><span class="line"> * @param v the value</span><br><span class="line"> */</span><br><span class="line">protected void set(V v) &#123;</span><br><span class="line">    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过waiters参数，唤醒等待队列，所有因为调用get()方法而阻塞的线程 LockSupport.unpark():线程取消阻塞</span><br><span class="line"> * Removes and signals all waiting threads, invokes done(), and</span><br><span class="line"> * nulls out callable.</span><br><span class="line"> */</span><br><span class="line">private void finishCompletion() &#123;</span><br><span class="line">    // assert state &gt; COMPLETING;</span><br><span class="line">    for (WaitNode q; (q = waiters) != null;) &#123;</span><br><span class="line">        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                if (t != null) &#123;</span><br><span class="line">                    q.thread = null;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                if (next == null)</span><br><span class="line">                    break;</span><br><span class="line">                q.next = null; // unlink to help gc</span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = null;        // to reduce footprint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Protected method invoked when this task transitions to state</span><br><span class="line"> * &#123;@code isDone&#125; (whether normally or via cancellation). The</span><br><span class="line"> * default implementation does nothing.  Subclasses may override</span><br><span class="line"> * this method to invoke completion callbacks or perform</span><br><span class="line"> * bookkeeping. Note that you can query status inside the</span><br><span class="line"> * implementation of this method to determine whether this task</span><br><span class="line"> * has been cancelled.</span><br><span class="line"> */</span><br><span class="line">protected void done() &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>FutureTask内部维护一个任务状态，任何操作都是围绕着这个状态进行，并随时更新任务状态。任务发起者调用get()获取执行结果的时候，如果任务还没有执行完毕，则会把自己放入阻塞队列中然后进行阻塞等待。当任务执行完成之后，任务执行线程会依次唤醒阻塞等待的线程。调用cancel()取消任务的时候也只是简单的修改任务状态，如果需要中断任务执行线程的话则调用Thread.interrupt()中断任务执行线程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;线程任务执行如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。&lt;/p&gt;
&lt;p&gt;而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。&lt;/p&gt;
&lt;p&gt;今天我们就来讨论一下Callable、Future和FutureTask三个类的使用方法。&lt;/p&gt;
&lt;h4 id=&quot;Callable与Runnable&quot;&gt;&lt;a href=&quot;#Callable与Runnable&quot; class=&quot;headerlink&quot; title=&quot;Callable与Runnable&quot;&gt;&lt;/a&gt;Callable与Runnable&lt;/h4&gt;&lt;p&gt;先说一下java.lang.Runnable吧，它是一个接口，在它里面只声明了一个run()方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@FunctionalInterface&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public interface Runnable &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * When an object implementing interface &amp;lt;code&amp;gt;Runnable&amp;lt;/code&amp;gt; is used&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * to create a thread, starting the thread causes the object&amp;apos;s&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * &amp;lt;code&amp;gt;run&amp;lt;/code&amp;gt; method to be called in that separately executing&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * thread.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * &amp;lt;p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * The general contract of the method &amp;lt;code&amp;gt;run&amp;lt;/code&amp;gt; is that it may&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * take any action whatsoever.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @see     java.lang.Thread#run()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public abstract void run();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。&lt;/p&gt;
&lt;p&gt;Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@FunctionalInterface&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public interface Callable&amp;lt;V&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * Computes a result, or throws an exception if unable to do so.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @return computed result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @throws Exception if unable to compute a result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    V call() throws Exception;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。&lt;/p&gt;
&lt;p&gt;那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Future&amp;lt;?&amp;gt; submit(Runnable task);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;Future&quot;&gt;&lt;a href=&quot;#Future&quot; class=&quot;headerlink&quot; title=&quot;Future&quot;&gt;&lt;/a&gt;Future&lt;/h4&gt;&lt;p&gt;Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。&lt;/p&gt;
&lt;p&gt;Future类位于java.util.concurrent包下，它是一个接口：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public interface Future&amp;lt;V&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 如果设置true，则表示可以取消正在执行过程中的任务。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 则返回true，若mayInterruptIfRunning设置为false，则返回false；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @param mayInterruptIfRunning&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    boolean cancel(boolean mayInterruptIfRunning);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    boolean isCancelled();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 表示任务是否已经完成，若任务完成，则返回true；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    boolean isDone();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @throws InterruptedException&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @throws ExecutionException&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    V get() throws InterruptedException, ExecutionException;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @param timeout&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @param unit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @throws InterruptedException&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @throws ExecutionException&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @throws TimeoutException&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    V get(long timeout, TimeUnit unit)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        throws InterruptedException, ExecutionException, TimeoutException;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;RunnableFuture&quot;&gt;&lt;a href=&quot;#RunnableFuture&quot; class=&quot;headerlink&quot; title=&quot;RunnableFuture&quot;&gt;&lt;/a&gt;RunnableFuture&lt;/h4&gt;&lt;p&gt;RunnableFuture作为 Runnable 的 Future。成功执行 run 方法可以完成 Future 并允许访问其结果&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * 作为 Runnable 的 Future。成功执行 run 方法可以完成 Future 并允许访问其结果。 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * A &amp;#123;@link Future&amp;#125; that is &amp;#123;@link Runnable&amp;#125;. Successful execution of&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * the &amp;#123;@code run&amp;#125; method causes completion of the &amp;#123;@code Future&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * and allows access to its results.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @see FutureTask&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @see Executor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @since 1.6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @author Doug Lea&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @param &amp;lt;V&amp;gt; The result type returned by this Future&amp;apos;s &amp;#123;@code get&amp;#125; method&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * Sets this Future to the result of its computation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * unless it has been cancelled.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void run();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;FutureTask&quot;&gt;&lt;a href=&quot;#FutureTask&quot; class=&quot;headerlink&quot; title=&quot;FutureTask&quot;&gt;&lt;/a&gt;FutureTask&lt;/h4&gt;&lt;p&gt;我们先来看一下FutureTask的实现：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;FutureTask类实现了RunnableFuture接口，我们看一下RunnableFuture接口的实现：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void run();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; 可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。&lt;br&gt;FutureTask提供了2个构造器：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public FutureTask(Callable&amp;lt;V&amp;gt; callable) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public FutureTask(Runnable runnable, V result) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="juc" scheme="blog.ppjys.cn/categories/juc/"/>
    
    
      <category term="futureTask" scheme="blog.ppjys.cn/tags/futureTask/"/>
    
  </entry>
  
  <entry>
    <title>使用JMH做Java微基准测试</title>
    <link href="blog.ppjys.cn/2018/12/09/%E4%BD%BF%E7%94%A8JMH%E5%81%9AJava%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/"/>
    <id>blog.ppjys.cn/2018/12/09/使用JMH做Java微基准测试/</id>
    <published>2018-12-09T13:06:59.000Z</published>
    <updated>2018-12-11T15:25:46.092Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在使用Java编程过程中，我们对于一些代码调用的细节有多种编写方式，但是不确定它们性能时，往往采用重复多次计数的方式来解决。但是随着JVM不断的进化，随着代码执行次数的增加，JVM会不断的进行编译优化，使得重复多少次才能够得到一个稳定的测试结果变得让人疑惑，这时候有经验的同学就会在测试执行前先循环上万次并注释为预热。</p><p>没错！这样做确实可以获得一个偏向正确的测试结果，但是我们试想如果每到需要斟酌性能的时候，都要根据场景写一段预热的逻辑吗？当预热完成后，需要多少次迭代来进行正式内容的测量呢？每次测试结果的输出报告是不是都需要用System.out来输出呢？</p><p>其实这些工作都可以交给 JMH (the Java Microbenchmark Harness) ，它被作为Java9的一部分来发布，但是我们完全不需要等待Java9，而可以方便的使用它来简化我们测试，它能够照看好JVM的预热、代码优化，让你的测试过程变得更加简单。</p><a id="more"></a><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><p>首先在项目中新增依赖，jmh-core以及jmh-generator-annprocess的依赖可以在maven仓库中找寻最新版本。</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写基准测试</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxy.keygen.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dxy.keygen.utils.KeyGeneratorUtils;</span><br><span class="line"><span class="keyword">import</span> com.dxy.keygen.utils.OrderNoGeneratorUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基准测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peijiepang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-12-07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenchmarkTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基准测试类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RunnerException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">benchmarkTest</span><span class="params">()</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(<span class="string">"defaultKeyGeneratorBenchmarkTest"</span>)</span><br><span class="line">                .include(<span class="string">"DefaultGeneratorOrderNoBenchmarkTest"</span>)</span><br><span class="line">                .include(<span class="string">"TimestampGeneratorOrderNoBenchmarkTest"</span>)</span><br><span class="line">                .warmupIterations(<span class="number">5</span>)<span class="comment">//预热做5轮</span></span><br><span class="line">                .measurementIterations(<span class="number">10</span>)<span class="comment">//正式计量测试做10轮</span></span><br><span class="line">                .forks(<span class="number">3</span>)<span class="comment">//做3轮测试</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分布式主键生成基准测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@BenchmarkMode</span>(&#123;Mode.Throughput,Mode.AverageTime&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultKeyGeneratorBenchmarkTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        KeyGeneratorUtils.generateKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认订单号生成基准测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@State</span>(Scope.Benchmark)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultGeneratorOrderNoBenchmarkTest</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 订单号生成init</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Setup</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            OrderNoGeneratorUtils.init(OrderNoGeneratorUtils.OrderNoGeneratorEnum.DEFAULT);</span><br><span class="line">            System.out.println(<span class="string">"init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 分布式主键生成基准测试</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Benchmark</span></span><br><span class="line">        <span class="meta">@BenchmarkMode</span>(&#123;Mode.Throughput,Mode.AverageTime&#125;)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderNoGeneratorBenchmarkTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            OrderNoGeneratorUtils.generateOrderNo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间戳订单号生成基准测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@State</span>(Scope.Benchmark)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimestampGeneratorOrderNoBenchmarkTest</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 订单号生成init</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Setup</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            OrderNoGeneratorUtils.init(OrderNoGeneratorUtils.OrderNoGeneratorEnum.TIMESTAMP);</span><br><span class="line">            System.out.println(<span class="string">"init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 分布式主键生成基准测试</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Benchmark</span></span><br><span class="line">        <span class="meta">@BenchmarkMode</span>(&#123;Mode.Throughput,Mode.AverageTime&#125;)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderNoGeneratorBenchmarkTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            OrderNoGeneratorUtils.generateOrderNo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基准测试结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Run complete. Total time: 00:06:32</span><br><span class="line"></span><br><span class="line">Benchmark                                                                            Mode  Cnt        Score      Error  Units</span><br><span class="line">BenchmarkTest.DefaultGeneratorOrderNoBenchmarkTest.orderNoGeneratorBenchmarkTest    thrpt   <span class="number">30</span>     <span class="number">8612.597</span> ± <span class="number">1864.319</span>  ops/s</span><br><span class="line">BenchmarkTest.TimestampGeneratorOrderNoBenchmarkTest.orderNoGeneratorBenchmarkTest  thrpt   <span class="number">30</span>     <span class="number">8899.778</span> ± <span class="number">2066.678</span>  ops/s</span><br><span class="line">BenchmarkTest.defaultKeyGeneratorBenchmarkTest                                      thrpt   <span class="number">30</span>  <span class="number">1024568.969</span> ±  <span class="number">146.663</span>  ops/s</span><br><span class="line">BenchmarkTest.DefaultGeneratorOrderNoBenchmarkTest.orderNoGeneratorBenchmarkTest     avgt   <span class="number">30</span>       ≈ <span class="number">10</span>⁻⁴              s/op</span><br><span class="line">BenchmarkTest.TimestampGeneratorOrderNoBenchmarkTest.orderNoGeneratorBenchmarkTest   avgt   <span class="number">30</span>       ≈ <span class="number">10</span>⁻⁴              s/op</span><br><span class="line">BenchmarkTest.defaultKeyGeneratorBenchmarkTest                                       avgt   <span class="number">30</span>       ≈ <span class="number">10</span>⁻⁶              s/op</span><br></pre></td></tr></table></figure></li></ol><h3 id="注解介绍"><a href="#注解介绍" class="headerlink" title="注解介绍"></a>注解介绍</h3><p>好了，当你对JMH有了一个基本认识后，现在来详细解释一下前面代码中的各个注解含义。</p><h4 id="BenchmarkMode"><a href="#BenchmarkMode" class="headerlink" title="@BenchmarkMode"></a>@BenchmarkMode</h4><p>基准测试类型。这里选择的是Throughput也就是吞吐量。根据源码点进去，每种类型后面都有对应的解释，比较好理解，吞吐量会得到单位时间内可以进行的操作数。</p><ul><li>Throughput: 整体吞吐量，例如“1秒内可以执行多少次调用”。</li><li>AverageTime: 调用的平均时间，例如“每次调用平均耗时xxx毫秒”。</li><li>SampleTime: 随机取样，最后输出取样结果的分布，例如“99%的调用在xxx毫秒以内，99.99%的调用在xxx毫秒以内”</li><li>SingleShotTime: 以上模式都是默认一次 iteration 是 1s，唯有 SingleShotTime 是只运行一次。往往同时把 warmup 次数设为0，用于测试冷启动时的性能。</li><li>All(“all”, “All benchmark modes”);</li></ul><h4 id="Warmup"><a href="#Warmup" class="headerlink" title="@Warmup"></a>@Warmup</h4><p>上面我们提到了，进行基准测试前需要进行预热。一般我们前几次进行程序测试的时候都会比较慢， 所以要让程序进行几轮预热，保证测试的准确性。其中的参数iterations也就非常好理解了，就是预热轮数。</p><p>为什么需要预热？因为 JVM 的 JIT 机制的存在，如果某个函数被调用多次之后，JVM 会尝试将其编译成为机器码从而提高执行速度。所以为了让 benchmark 的结果更加接近真实情况就需要进行预热。</p><h4 id="Measurement"><a href="#Measurement" class="headerlink" title="@Measurement"></a>@Measurement</h4><p>度量，其实就是一些基本的测试参数。</p><ol><li>iterations 进行测试的轮次</li><li>time 每轮进行的时长</li><li>timeUnit 时长单位</li></ol><p>都是一些基本的参数，可以根据具体情况调整。一般比较重的东西可以进行大量的测试，放到服务器上运行。</p><h4 id="Threads"><a href="#Threads" class="headerlink" title="@Threads"></a>@Threads</h4><p>每个进程中的测试线程，这个非常好理解，根据具体情况选择，一般为cpu乘以2。</p><h4 id="Fork"><a href="#Fork" class="headerlink" title="@Fork"></a>@Fork</h4><p>进行 fork 的次数。如果 fork 数是2的话，则 JMH 会 fork 出两个进程来进行测试。</p><h4 id="OutputTimeUnit"><a href="#OutputTimeUnit" class="headerlink" title="@OutputTimeUnit"></a>@OutputTimeUnit</h4><p>这个比较简单了，基准测试结果的时间类型。一般选择秒、毫秒、微秒。</p><h4 id="Benchmark"><a href="#Benchmark" class="headerlink" title="@Benchmark"></a>@Benchmark</h4><p>方法级注解，表示该方法是需要进行 benchmark 的对象，用法和 JUnit 的 @Test 类似。</p><h4 id="Param"><a href="#Param" class="headerlink" title="@Param"></a>@Param</h4><p>属性级注解，@Param 可以用来指定某项参数的多种情况。特别适合用来测试一个函数在不同的参数输入的情况下的性能。</p><h4 id="Setup"><a href="#Setup" class="headerlink" title="@Setup"></a>@Setup</h4><p>方法级注解，这个注解的作用就是我们需要在测试之前进行一些准备工作，比如对一些数据的初始化之类的。</p><h4 id="TearDown"><a href="#TearDown" class="headerlink" title="@TearDown"></a>@TearDown</h4><p>方法级注解，这个注解的作用就是我们需要在测试之后进行一些结束工作，比如关闭线程池，数据库连接等的，主要用于资源的回收等。</p><h4 id="State"><a href="#State" class="headerlink" title="@State"></a>@State</h4><p>当使用@Setup参数的时候，必须在类上加这个参数，不然会提示无法运行。</p><p>State 用于声明某个类是一个“状态”，然后接受一个 Scope 参数用来表示该状态的共享范围。 因为很多 benchmark 会需要一些表示状态的类，JMH 允许你把这些类以依赖注入的方式注入到 benchmark 函数里。Scope 主要分为三种。</p><ol><li>Thread: 该状态为每个线程独享。</li><li>Group: 该状态为同一个组里面所有线程共享。</li><li>Benchmark: 该状态在所有线程间共享。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在使用Java编程过程中，我们对于一些代码调用的细节有多种编写方式，但是不确定它们性能时，往往采用重复多次计数的方式来解决。但是随着JVM不断的进化，随着代码执行次数的增加，JVM会不断的进行编译优化，使得重复多少次才能够得到一个稳定的测试结果变得让人疑惑，这时候有经验的同学就会在测试执行前先循环上万次并注释为预热。&lt;/p&gt;
&lt;p&gt;没错！这样做确实可以获得一个偏向正确的测试结果，但是我们试想如果每到需要斟酌性能的时候，都要根据场景写一段预热的逻辑吗？当预热完成后，需要多少次迭代来进行正式内容的测量呢？每次测试结果的输出报告是不是都需要用System.out来输出呢？&lt;/p&gt;
&lt;p&gt;其实这些工作都可以交给 JMH (the Java Microbenchmark Harness) ，它被作为Java9的一部分来发布，但是我们完全不需要等待Java9，而可以方便的使用它来简化我们测试，它能够照看好JVM的预热、代码优化，让你的测试过程变得更加简单。&lt;/p&gt;
    
    </summary>
    
      <category term="test" scheme="blog.ppjys.cn/categories/test/"/>
    
    
      <category term="jmh" scheme="blog.ppjys.cn/tags/jmh/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池ScheduledThreadPoolExecutor分析2</title>
    <link href="blog.ppjys.cn/2018/12/04/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0ScheduledThreadPoolExecutor%E5%88%86%E6%9E%902/"/>
    <id>blog.ppjys.cn/2018/12/04/Java线程池ScheduledThreadPoolExecutor分析2/</id>
    <published>2018-12-04T14:51:01.000Z</published>
    <updated>2018-12-04T14:53:49.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面。</p><p><strong>堆结构如下图所示：</strong></p><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/3.png" width="500px"></p><p><strong>为什么要使用DelayedWorkQueue呢？</strong><br>定时任务执行时需要取出最近要执行的任务，所以任务在队列中每次出队时一定要是当前队列中执行时间最靠前的，所以自然要使用优先级队列。</p><p>DelayedWorkQueue是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的，由于它是基于堆结构的队列，堆结构在执行插入和删除操作时的最坏时间复杂度是 O(logN)。</p><h4 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则"></a>排序规则</h4><ul><li>执行时间距离当前时间越近，越靠前</li><li>如果执行时间相同，则先执行插入时间靠前的任务。</li></ul><h4 id="新增-获取任务"><a href="#新增-获取任务" class="headerlink" title="新增/获取任务"></a>新增/获取任务</h4><p>DelayedWorkQueue通过put或者add来新增一条任务，但其底层都是调用offer来新增任务的。对于获取任务，我们知道在ThreadPoolExecutor中线程根据getTask来获取任务队列中的任务，而在getTask中任务队列通过poll或者take函数来获取任务队列中的任务，由于ScheduleThreadPoolExecutor继承自ThreadPoolExecutor，因此其底层获取任务方式相同，只需要DelayedWorkQueue提供take及pool方法即可。</p><p>DelayWorkQueue底层是用最小堆数据结构实现的，需要最先执行的任务在堆的顶部，因此在每次插入或者删除任务时需要调整二叉树节点的顺序，但不同于最小堆的地方在于DelayWorkQueue不关心兄弟节点之间的顺序，只要父节点的任务先于子节点执行即可。</p><p>在一个最小堆的队列中，假如索引从0开始，子节点索引值为k，父节点索引值为p，则存在如下规律：</p><ul><li>一个节点的左子节点的索引为：k = p * 2 + 1</li><li>一个节点的右子节点的索引为：k = (p + 1) * 2</li><li>一个节点的父节点的索引为：p = (k - 1) / 2</li></ul><a id="more"></a><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="DelayedWorkQueue的属性"><a href="#DelayedWorkQueue的属性" class="headerlink" title="DelayedWorkQueue的属性"></a>DelayedWorkQueue的属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 根据初始容量创建RunnableScheduledFuture类型的数组</span></span><br><span class="line"><span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue =</span><br><span class="line">    <span class="keyword">new</span> RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// leader线程</span></span><br><span class="line"><span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 当较新的任务在队列的头部可用时，或者新线程可能需要成为leader，则通过该条件发出信号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br></pre></td></tr></table></figure><p>注意这里的leader，它是Leader-Follower模式的变体，用于减少不必要的定时等待。什么意思呢？对于多线程的网络模型来说：</p><blockquote><p>所有线程会有三种身份中的一种：leader和follower，以及一个干活中的状态：proccesser。它的基本原则就是，永远最多只有一个leader。而所有follower都在等待成为leader。线程池启动时会自动产生一个Leader负责等待网络IO事件，当有一个事件产生时，Leader线程首先通知一个Follower线程将其提拔为新的Leader，然后自己就去干活了，去处理这个网络事件，处理完毕后加入Follower线程等待队列，等待下次成为Leader。这种方法可以增强CPU高速缓存相似性，及消除动态内存分配和线程间的数据交换。</p></blockquote><h4 id="offer方法"><a href="#offer方法" class="headerlink" title="offer方法"></a>offer方法</h4><p>既然是阻塞队列，入队的操作如add和put方法都调用了offer方法，下面查看一下offer方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入队操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = size;</span><br><span class="line">        <span class="comment">// queue是一个RunnableScheduledFuture类型的数组，如果容量不够需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            grow();</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// i == 0 说明堆中还没有数据，设置索引</span></span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">            setIndex(e, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// i != 0 时，需要对堆进行重新排序</span></span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果传入的任务已经是队列的第一个节点了，这时available需要发出信号</span></span><br><span class="line">        <span class="keyword">if</span> (queue[<span class="number">0</span>] == e) &#123;</span><br><span class="line">            <span class="comment">// leader设置为null为了使在take方法中的线程在通过available.signal();后会执行available.awaitNanos(delay);</span></span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="siftUp方法"><a href="#siftUp方法" class="headerlink" title="siftUp方法"></a>siftUp方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sifts element added at bottom up to its heap-ordered spot.</span></span><br><span class="line"><span class="comment"> * Call only when holding lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//查找到父节点</span></span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; e = queue[parent]; <span class="comment">//获取父节点任务</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(e) &gt;= <span class="number">0</span>) <span class="comment">//如果父节点先于该任务执行，则跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e; <span class="comment">//与父节点交换位置</span></span><br><span class="line">        setIndex(e, k);</span><br><span class="line">        k = parent; <span class="comment">//重新向上追溯父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">    setIndex(key, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很好理解，就是循环的根据key节点与它的父节点来判断，如果key节点的执行时间小于父节点，则将两个节点交换，使执行时间靠前的节点排列在队列的前面。</p><p>假设新入队的节点的延迟时间（调用getDelay()方法获得）是5，执行过程如下：</p><ol><li>先将新的节点添加到数组的尾部，这时新节点的索引k为7：</li></ol><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/4.png" width="500px"></p><ol start="2"><li>计算新父节点的索引：parent = (k - 1) &gt;&gt;&gt; 1，parent = 那么queue[3]的时间间隔值为8，因为 5 &lt; 8 ，将执行queue[7] = queue[3]</li></ol><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/5.png" width="500px"></p><ol start="3"><li>这时将k设置为3，继续循环，再次计算parent为1，queue[1]的时间间隔为3，因为 5 &gt; 3 ，这时退出循环，最终k为3：</li></ol><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/6.png" width="500px"></p><p>可见，每次新增节点时，只是根据父节点来判断，而不会影响兄弟节点。</p><p>另外，setIndex方法只是设置了ScheduledFutureTask中的heapIndex属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(RunnableScheduledFuture&lt;?&gt; f, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ScheduledFutureTask)</span><br><span class="line">        ((ScheduledFutureTask)f).heapIndex = idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="take方法"><a href="#take方法" class="headerlink" title="take方法"></a>take方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 计算当前时间到执行时间的时间间隔</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// leader不为空，阻塞线程</span></span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// leader为空，则把leader设置为当前线程</span></span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 阻塞到执行时间</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 设置leader = null，让其他线程执行available.awaitNanos(delay);</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果leader不为空，则说明leader的线程正在执行available.awaitNanos(delay);</span></span><br><span class="line">        <span class="comment">// 如果queue[0] == null，说明队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>take方法是什么时候调用的呢，工作线程会循环地从workQueue中取任务。但定时任务却不同，因为如果一旦getTask方法取出了任务就开始执行了，而这时可能还没有到执行的时间，所以在take方法中，要保证只有在到指定的执行时间的时候任务才可以被取走。</p><p>再来说一下leader的作用，这里的leader是为了减少不必要的定时等待，当一个线程成为leader时，它只等待下一个节点的时间间隔，但其它线程无限期等待。 leader线程必须在从take（）或poll（）返回之前signal其它线程，除非其他线程成为了leader。</p><p>举例来说，如果没有leader，那么在执行take时，都要执行available.awaitNanos(delay)，假设当前线程执行了该段代码，这时还没有signal，第二个线程也执行了该段代码，则第二个线程也要被阻塞。多个这时执行该段代码是没有作用的，因为只能有一个线程会从take中返回queue[0]（因为有lock），其他线程这时再返回for循环执行时取的queue[0]，已经不是之前的queue[0]了，然后又要继续阻塞。</p><p>所以，为了不让多个线程频繁的做无用的定时等待，这里增加了leader，如果leader不为空，则说明队列中第一个节点已经在等待出队，这时其它的线程会一直阻塞，减少了无用的阻塞（注意，在finally中调用了signal()来唤醒一个线程，而不是signalAll()）。</p><h4 id="poll方法"><a href="#poll方法" class="headerlink" title="poll方法"></a>poll方法</h4><p>与take类似，但这里要提供超时功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="comment">// 如果delay &lt;= 0，说明已经到了任务执行的时间，返回</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">                <span class="comment">// 如果nanos &lt;= 0，说明已经超时，返回null</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="comment">// nanos &lt; delay 说明需要等待的时间小于任务要执行的延迟时间</span></span><br><span class="line">                <span class="comment">// leader != null 说明有其它线程正在对任务进行阻塞</span></span><br><span class="line">                <span class="comment">// 这时阻塞当前线程nanos纳秒</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="keyword">null</span>)</span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 这里的timeLeft表示delay减去实际的等待时间</span></span><br><span class="line">                        <span class="keyword">long</span> timeLeft = available.awaitNanos(delay);</span><br><span class="line">                        <span class="comment">// 计算剩余的等待时间</span></span><br><span class="line">                        nanos -= delay - timeLeft;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="finishPoll方法"><a href="#finishPoll方法" class="headerlink" title="finishPoll方法"></a>finishPoll方法</h4><p>当调用了take或者poll方法能够获取到任务时，会调用该方法进行返回：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs common bookkeeping for poll and take: Replaces</span></span><br><span class="line"><span class="comment"> * first element with last and sifts it down.  Call only when</span></span><br><span class="line"><span class="comment"> * holding lock.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f the task to remove and return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123;</span><br><span class="line">    <span class="comment">// 数组长度-1</span></span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="comment">// 取出最后一个节点</span></span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; x = queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 长度不为0，则从第一个元素开始排序，目的是要把最后一个节点放到合适的位置上</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line">    setIndex(f, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="siftDown方法"><a href="#siftDown方法" class="headerlink" title="siftDown方法"></a>siftDown方法</h4><p>siftDown方法使堆从k开始向下调整<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sifts element added at top down to its heap-ordered spot.</span></span><br><span class="line"><span class="comment"> * Call only when holding lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据二叉树的特性，数组长度除以2，表示取有子节点的索引</span></span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 判断索引为k的节点是否有子节点</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">// 左子节点的索引</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; c = queue[child];</span><br><span class="line">        <span class="comment">// 右子节点的索引</span></span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果有右子节点并且左子节点的时间间隔大于右子节点，取时间间隔最小的节点</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="comment">// 如果key的时间间隔小于等于c的时间间隔，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        <span class="comment">// 设置要移除索引的节点为其子节点</span></span><br><span class="line">        setIndex(c, k);</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">    <span class="comment">// 将key放入索引为k的位置</span></span><br><span class="line">    setIndex(key, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>siftDown方法执行时包含两种情况，一种是没有子节点，一种是有子节点（根据half判断）。例如：</p><p><strong>没有子节点的情况：</strong></p><p>假设初始的堆如下：<br><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/7.png" width="500px"></p><p>假设 k = 3 ，那么 k = half ，没有子节点，在执行siftDown方法时直接把索引为3的节点设置为数组的最后一个节点：</p><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/8.png" width="500px"></p><p><strong>有子节点的情况：</strong></p><p>假设 k = 0 ，那么执行以下步骤：</p><ol><li>获取左子节点，child = 1 ，获取右子节点， right = 2 ：</li></ol><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/9.png" width="500px"></p><ol start="2"><li>由于 right &lt; size ，这时比较左子节点和右子节点时间间隔的大小，这里 3 &lt; 7 ，所以 c = queue[child] </li><li>比较key的时间间隔是否小于c的时间间隔，这里不满足，继续执行，把索引为k的节点设置为c，然后将k设置为child</li></ol><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/10.png" width="500px"></p><ol start="4"><li>因为 half = 3 ，k = 1 ，继续执行循环，这时的索引变为</li></ol><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/11.png" width="500px"></p><ol start="5"><li>这时再经过如上判断后，将k的值为3，最终的结果如下</li></ol><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/12.png" width="500px"></p><ol start="6"><li>最后，如果在finishPoll方法中调用的话，会把索引为0的节点的索引设置为-1，表示已经删除了该节点，并且size也减了1，最后的结果如下</li></ol><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/13.png" width="500px"></p><p>可见，siftdown方法在执行完并不是有序的，但可以发现，子节点的下次执行时间一定比父节点的下次执行时间要大，由于每次都会取左子节点和右子节点中下次执行时间最小的节点，所以还是可以保证在take和poll时出队是有序的。</p><h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = indexOf(x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        setIndex(queue[i], -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; replacement = queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (s != i) &#123;</span><br><span class="line">            <span class="comment">// 从i开始向下调整</span></span><br><span class="line">            siftDown(i, replacement);</span><br><span class="line">            <span class="comment">// 如果queue[i] == replacement，说明i是叶子节点</span></span><br><span class="line">            <span class="comment">// 如果是这种情况，不能保证子节点的下次执行时间比父节点的大</span></span><br><span class="line">            <span class="comment">// 这时需要进行一次向上调整</span></span><br><span class="line">            <span class="keyword">if</span> (queue[i] == replacement)</span><br><span class="line">                siftUp(i, replacement);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设初始的堆结构如下：<br><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/14.png" width="500px"></p><p>这时要删除8的节点，那么这时 k = 1，key为最后一个节点：<br><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/15.png" width="500px"></p><p>这时通过上文对siftDown方法的分析，siftDown方法执行后的结果如下：<br><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/16.png" width="500px"></p><p>这时会发现，最后一个节点的值比父节点还要小，所以这里要执行一次siftUp方法来保证子节点的下次执行时间要比父节点的大，所以最终结果如下：<br><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/17.png" width="500px"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文详细分析了ScheduedThreadPoolExecutor的实现，主要介绍了以下方面：</p><p>与Timer执行定时任务的比较，相比Timer，ScheduedThreadPoolExecutor有什么优点；</p><ul><li>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，所以它也是一个线程池，也有coorPoolSize和workQueue，ScheduledThreadPoolExecutor特殊的地方在于，自己实现了优先工作队列DelayedWorkQueue；</li><li>ScheduedThreadPoolExecutor实现了ScheduledExecutorService，所以就有了任务调度的方法，如schedule，scheduleAtFixedRate和scheduleWithFixedDelay，同时注意他们之间的区别；</li><li>内部类ScheduledFutureTask继承自FutureTask，实现了任务的异步执行并且可以获取返回结果。同时也实现了Delayed接口，可以通过getDelay方法获取将要执行的时间间隔；</li><li>周期任务的执行其实是调用了FutureTask类中的runAndReset方法，每次执行完不设置结果和状态。参考FutureTask源码解析；</li><li>详细分析了DelayedWorkQueue的数据结构，它是一个基于最小堆结构的优先队列，并且每次出队时能够保证取出的任务是当前队列中下次执行时间最小的任务。同时注意一下优先队列中堆的顺序，堆中的顺序并不是绝对的，但要保证子节点的值要比父节点的值要大，这样就不会影响出队的顺序。</li></ul><p>总体来说，ScheduedThreadPoolExecutor的重点是要理解下次执行时间的计算，以及优先队列的出队、入队和删除的过程，这两个是理解ScheduedThreadPoolExecutor的关键。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆结构如下图所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/3.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要使用DelayedWorkQueue呢？&lt;/strong&gt;&lt;br&gt;定时任务执行时需要取出最近要执行的任务，所以任务在队列中每次出队时一定要是当前队列中执行时间最靠前的，所以自然要使用优先级队列。&lt;/p&gt;
&lt;p&gt;DelayedWorkQueue是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的，由于它是基于堆结构的队列，堆结构在执行插入和删除操作时的最坏时间复杂度是 O(logN)。&lt;/p&gt;
&lt;h4 id=&quot;排序规则&quot;&gt;&lt;a href=&quot;#排序规则&quot; class=&quot;headerlink&quot; title=&quot;排序规则&quot;&gt;&lt;/a&gt;排序规则&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;执行时间距离当前时间越近，越靠前&lt;/li&gt;
&lt;li&gt;如果执行时间相同，则先执行插入时间靠前的任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;新增-获取任务&quot;&gt;&lt;a href=&quot;#新增-获取任务&quot; class=&quot;headerlink&quot; title=&quot;新增/获取任务&quot;&gt;&lt;/a&gt;新增/获取任务&lt;/h4&gt;&lt;p&gt;DelayedWorkQueue通过put或者add来新增一条任务，但其底层都是调用offer来新增任务的。对于获取任务，我们知道在ThreadPoolExecutor中线程根据getTask来获取任务队列中的任务，而在getTask中任务队列通过poll或者take函数来获取任务队列中的任务，由于ScheduleThreadPoolExecutor继承自ThreadPoolExecutor，因此其底层获取任务方式相同，只需要DelayedWorkQueue提供take及pool方法即可。&lt;/p&gt;
&lt;p&gt;DelayWorkQueue底层是用最小堆数据结构实现的，需要最先执行的任务在堆的顶部，因此在每次插入或者删除任务时需要调整二叉树节点的顺序，但不同于最小堆的地方在于DelayWorkQueue不关心兄弟节点之间的顺序，只要父节点的任务先于子节点执行即可。&lt;/p&gt;
&lt;p&gt;在一个最小堆的队列中，假如索引从0开始，子节点索引值为k，父节点索引值为p，则存在如下规律：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个节点的左子节点的索引为：k = p * 2 + 1&lt;/li&gt;
&lt;li&gt;一个节点的右子节点的索引为：k = (p + 1) * 2&lt;/li&gt;
&lt;li&gt;一个节点的父节点的索引为：p = (k - 1) / 2&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="juc" scheme="blog.ppjys.cn/categories/juc/"/>
    
    
      <category term="ScheduledThreadPoolExecutor" scheme="blog.ppjys.cn/tags/ScheduledThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池ScheduledThreadPoolExecutor分析1</title>
    <link href="blog.ppjys.cn/2018/11/27/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0ScheduledThreadPoolExecutor%E5%88%86%E6%9E%901/"/>
    <id>blog.ppjys.cn/2018/11/27/Java线程池ScheduledThreadPoolExecutor分析1/</id>
    <published>2018-11-27T15:35:05.000Z</published>
    <updated>2018-11-27T15:38:50.505Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>自JDK1.5开始，JDK提供了ScheduledThreadPoolExecutor类来支持周期性任务的调度。在这之前的实现需要依靠Timer和TimerTask或者其它第三方工具来完成。但Timer有不少的缺陷：</p><ul><li>Timer是单线程模式；</li><li>如果在执行任务期间某个TimerTask耗时较久，那么就会影响其它任务的调度；</li><li>Timer的任务调度是基于绝对时间的，对系统时间敏感；</li><li>Timer不会捕获执行TimerTask时所抛出的异常，由于Timer是单线程，所以一旦出现异常，则线程就会终止，其他任务也得不到执行。</li></ul><p>ScheduledThreadPoolExecutor继承ThreadPoolExecutor来重用线程池的功能，它的实现方式如下：</p><ul><li>将任务封装成ScheduledFutureTask对象，ScheduledFutureTask基于相对时间，不受系统时间的改变所影响；</li><li>ScheduledFutureTask实现了java.lang.Comparable接口和java.util.concurrent.Delayed接口，所以有两个重要的方法：compareTo和getDelay。compareTo方法用于比较任务之间的优先级关系，如果距离下次执行的时间间隔较短，则优先级高；getDelay方法用于返回距离下次任务执行时间的时间间隔；</li><li>ScheduledThreadPoolExecutor定义了一个DelayedWorkQueue，它是一个有序队列，会通过每个任务按照距离下次执行时间间隔的大小来排序；</li><li>ScheduledFutureTask继承自FutureTask，可以通过返回Future对象来获取执行的结果。</li></ul><p><strong>类图</strong></p><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/2.png" width="500px"></p><p>从ScheduledThreadPoolExecutor类声明可以看出：</p><p>ScheduledThreadPoolExecutor是ThreadPoolExecutor的子类，并且实现了接口ScheduledExecutorService；</p><a id="more"></a><p><strong>Demo</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fly.learn.executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池test</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peijiepang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(ThreadPoolExecutorTest.class);</span><br><span class="line">    <span class="comment">//private static ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 30, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(10));</span></span><br><span class="line">    <span class="comment">//private static Executor executor = Executors.newFixedThreadPool(5);</span></span><br><span class="line">    <span class="comment">//private static Executor executor = Executors.newSingleThreadExecutor();</span></span><br><span class="line">    <span class="comment">//private static Executor executor = Executors.newCachedThreadPool();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Task1 task1 = <span class="keyword">new</span> Task1();<span class="comment">//构建任务</span></span><br><span class="line"><span class="comment">//        executor.execute(task1);//执行任务</span></span><br><span class="line">        executor.scheduleAtFixedRate(task1,<span class="number">0</span>,<span class="number">1</span>,TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 基本任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Task1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//具体任务的业务</span></span><br><span class="line">            LOGGER.info(<span class="string">"&#123;&#125;..."</span>,i.incrementAndGet());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadPoolExecutorTest test = <span class="keyword">new</span> ThreadPoolExecutorTest();</span><br><span class="line">        test.executeTask();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造方法可以看出，ScheduledThreadPoolExecutor使用DelayQueue来作为线程池的工作队列，由于DelayQueue是无界队列，根据线程池的工作原理，核心参数maximumPoolSize在ScheduledThreadPoolExecutor中是没有什么意义的。<br>总的来说，ScheduledThreadPoolExecutor为了实现周期性执行任务，对ThreadPoolExecutor做了以下改动：   </p><ul><li>工作队列使用DelayQueue；</li><li>任务提交之后统统都进工作队列；</li><li>获取任务的方式改变，执行了任务之后，也增加了额外的处理，具体的改变后文会一一给出详细的分析。</li></ul><h4 id="任务提交与调度"><a href="#任务提交与调度" class="headerlink" title="任务提交与调度"></a>任务提交与调度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                   <span class="keyword">long</span> delay,</span><br><span class="line">                                   TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(delay, unit)));</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">long</span> delay,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;V&gt;(callable,</span><br><span class="line">                                   triggerTime(delay, unit)));</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交延时任务，下一次执行时间相当于是上一次的执行时间加上period，它是采用已固定的频率来执行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException   &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                              <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                              <span class="keyword">long</span> period,</span><br><span class="line">                                              TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//构造ScheduledFutureTask</span></span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                      <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit),</span><br><span class="line">                                      unit.toNanos(period));</span><br><span class="line">    <span class="comment">//提供可被子类重载或者修改的方法</span></span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    <span class="comment">//真正提交任务</span></span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与scheduleAtFixedRate方法不同的是，下一次执行时间是上一次任务执行完的系统时间加上period，</span></span><br><span class="line"><span class="comment"> * 因而具体执行时间不是固定的，但周期是固定的，是采用相对固定的延迟来执行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException   &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                 <span class="keyword">long</span> delay,</span><br><span class="line">                                                 TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                      <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit),</span><br><span class="line">                                      unit.toNanos(-delay));</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ScheduledFutureTask"><a href="#ScheduledFutureTask" class="headerlink" title="ScheduledFutureTask"></a>ScheduledFutureTask</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务被添加到ScheduledThreadPoolExecutor中的序号</span></span><br><span class="line"><span class="comment">/** Sequence number to break ties FIFO */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务将要被执行的具体时间</span></span><br><span class="line"><span class="comment">/** The time the task is enabled to execute in nanoTime units */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务执行的间隔周期</span></span><br><span class="line"><span class="comment"> * Period in nanoseconds for repeating tasks.  A positive</span></span><br><span class="line"><span class="comment"> * value indicates fixed-rate execution.  A negative value</span></span><br><span class="line"><span class="comment"> * indicates fixed-delay execution.  A value of 0 indicates a</span></span><br><span class="line"><span class="comment"> * non-repeating task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a one-shot action with given nanoTime-based trigger time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a periodic action with given nano time and period.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = period;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a one-shot action with given nanoTime-based trigger time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">    <span class="keyword">super</span>(callable);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ScheduledThreadPoolExecutor会把待执行的任务放到工作队列DelayQueue中，</span></span><br><span class="line"><span class="comment"> * DelayQueue封装了一个PriorityQueue，PriorityQueue会对队列中的ScheduledFutureTask进行排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> other</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero if same object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">        <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">        <span class="comment">//首先按照time排序，time小的排在前面，time大的排在后面；</span></span><br><span class="line">        <span class="comment">//如果time相同，按照sequenceNumber排序，sequenceNumber小的排在前面，</span></span><br><span class="line">        <span class="comment">//sequenceNumber大的排在后面，换句话说，如果两个task的执行时间相同，优先执行先提交的task。</span></span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);</span><br><span class="line">    <span class="keyword">return</span> (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : (diff &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//执行时间减去当前系统时间</span></span><br><span class="line">    <span class="keyword">return</span> unit.convert(time - now(), NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务执行逻辑</span></span><br><span class="line"><span class="comment"> * Overrides FutureTask version so as to reset/requeue if periodic.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否是周期性任务</span></span><br><span class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</span><br><span class="line">    <span class="comment">// 当前线程池运行状态下如果不可以执行任务，取消该任务</span></span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        cancel(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 如果不是周期性任务，调用FutureTask中的run方法执行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">    <span class="comment">// 如果是周期性任务，调用FutureTask中的runAndReset方法执行</span></span><br><span class="line">    <span class="comment">// runAndReset方法不会设置执行结果，所以可以重复执行任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">        setNextRunTime();</span><br><span class="line">        reExecutePeriodic(outerTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置下次执行时间</span></span><br><span class="line"><span class="comment"> * Sets the next time to run for a periodic task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p = period;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">        time += p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        time = triggerTime(-p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mayInterruptIfRunning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> cancelled = <span class="keyword">super</span>.cancel(mayInterruptIfRunning);</span><br><span class="line">    <span class="keyword">if</span> (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= <span class="number">0</span>)</span><br><span class="line">        remove(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> cancelled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 周期性任务，重新添加任务</span></span><br><span class="line"><span class="comment"> * Requeues a periodic task unless current run state precludes it.</span></span><br><span class="line"><span class="comment"> * Same idea as delayedExecute except drops task rather than rejecting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reExecutePeriodic</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canRunInCurrentRunState(<span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(<span class="keyword">true</span>) &amp;&amp; remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//添加工作work线程</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadPoolExecutor中的钩子方法</span></span><br><span class="line"><span class="comment"> * Cancels and clears the queue of all tasks that should not be run</span></span><br><span class="line"><span class="comment"> * due to shutdown policy.  Invoked within super.shutdown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">onShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = <span class="keyword">super</span>.getQueue();</span><br><span class="line">    <span class="comment">// 获取在线程池已 shutdown 的情况下是否继续执行现有延迟任务</span></span><br><span class="line">    <span class="keyword">boolean</span> keepDelayed =</span><br><span class="line">        getExecuteExistingDelayedTasksAfterShutdownPolicy();</span><br><span class="line">    <span class="comment">// 获取在线程池已 shutdown 的情况下是否继续执行现有定期任务</span></span><br><span class="line">    <span class="keyword">boolean</span> keepPeriodic =</span><br><span class="line">        getContinueExistingPeriodicTasksAfterShutdownPolicy();</span><br><span class="line">    <span class="comment">// 如果在线程池已 shutdown 的情况下不继续执行延迟任务和定期任务</span></span><br><span class="line">    <span class="comment">// 则依次取消任务，否则则根据取消状态来判断</span></span><br><span class="line">    <span class="keyword">if</span> (!keepDelayed &amp;&amp; !keepPeriodic) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray())</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture&lt;?&gt;)</span><br><span class="line">                ((RunnableScheduledFuture&lt;?&gt;) e).cancel(<span class="keyword">false</span>);</span><br><span class="line">        q.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Traverse snapshot to avoid iterator exceptions</span></span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture) &#123;</span><br><span class="line">                RunnableScheduledFuture&lt;?&gt; t =</span><br><span class="line">                    (RunnableScheduledFuture&lt;?&gt;)e;</span><br><span class="line">                <span class="comment">// 如果有在 shutdown 后不继续的延迟任务或周期任务，则从队列中删除并取消任务</span></span><br><span class="line">                <span class="keyword">if</span> ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) ||</span><br><span class="line">                    t.isCancelled()) &#123; <span class="comment">// also remove if already cancelled</span></span><br><span class="line">                    <span class="keyword">if</span> (q.remove(t))</span><br><span class="line">                        t.cancel(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delayedExecute"><a href="#delayedExecute" class="headerlink" title="delayedExecute"></a>delayedExecute</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果线程池已经关闭，使用拒绝策略拒绝任务</span></span><br><span class="line">    <span class="keyword">if</span> (isShutdown())</span><br><span class="line">        reject(task);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 添加到阻塞队列中</span></span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp;</span><br><span class="line">            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;</span><br><span class="line">            remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 确保线程池中至少有一个线程启动，即使corePoolSize为0</span></span><br><span class="line">            <span class="comment">// 该方法在ThreadPoolExecutor中实现</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//aqs源码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensurePrestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wc = workerCountOf(ctl.get());</span><br><span class="line">    <span class="keyword">if</span> (wc &lt; corePoolSize)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，实现了ScheduledExecutorService接口，该接口定义了schedule等任务调度的方法。<br>同时ScheduledThreadPoolExecutor有两个重要的内部类：DelayedWorkQueue和ScheduledFutureTask。ScheduledFutureTask继承自FutureTask，并且实现了Delayed接口，DelayedWorkQueue将会在接下来的篇幅分析，敬请期待。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;自JDK1.5开始，JDK提供了ScheduledThreadPoolExecutor类来支持周期性任务的调度。在这之前的实现需要依靠Timer和TimerTask或者其它第三方工具来完成。但Timer有不少的缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Timer是单线程模式；&lt;/li&gt;
&lt;li&gt;如果在执行任务期间某个TimerTask耗时较久，那么就会影响其它任务的调度；&lt;/li&gt;
&lt;li&gt;Timer的任务调度是基于绝对时间的，对系统时间敏感；&lt;/li&gt;
&lt;li&gt;Timer不会捕获执行TimerTask时所抛出的异常，由于Timer是单线程，所以一旦出现异常，则线程就会终止，其他任务也得不到执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ScheduledThreadPoolExecutor继承ThreadPoolExecutor来重用线程池的功能，它的实现方式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将任务封装成ScheduledFutureTask对象，ScheduledFutureTask基于相对时间，不受系统时间的改变所影响；&lt;/li&gt;
&lt;li&gt;ScheduledFutureTask实现了java.lang.Comparable接口和java.util.concurrent.Delayed接口，所以有两个重要的方法：compareTo和getDelay。compareTo方法用于比较任务之间的优先级关系，如果距离下次执行的时间间隔较短，则优先级高；getDelay方法用于返回距离下次任务执行时间的时间间隔；&lt;/li&gt;
&lt;li&gt;ScheduledThreadPoolExecutor定义了一个DelayedWorkQueue，它是一个有序队列，会通过每个任务按照距离下次执行时间间隔的大小来排序；&lt;/li&gt;
&lt;li&gt;ScheduledFutureTask继承自FutureTask，可以通过返回Future对象来获取执行的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;类图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/2.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
&lt;p&gt;从ScheduledThreadPoolExecutor类声明可以看出：&lt;/p&gt;
&lt;p&gt;ScheduledThreadPoolExecutor是ThreadPoolExecutor的子类，并且实现了接口ScheduledExecutorService；&lt;/p&gt;
    
    </summary>
    
      <category term="juc" scheme="blog.ppjys.cn/categories/juc/"/>
    
    
      <category term="ScheduledThreadPoolExecutor" scheme="blog.ppjys.cn/tags/ScheduledThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池Executors分析</title>
    <link href="blog.ppjys.cn/2018/11/23/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0Executors%E5%88%86%E6%9E%90/"/>
    <id>blog.ppjys.cn/2018/11/23/Java线程池Executors分析/</id>
    <published>2018-11-23T15:43:27.000Z</published>
    <updated>2018-11-23T16:04:12.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Executors 这个类，因为它仅仅是工具类，它的所有方法都是 static 的。</p><p><strong>Demo</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fly.learn.executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池test</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peijiepang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(ThreadPoolExecutorTest.class);</span><br><span class="line">    <span class="comment">//private static ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 30, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(10));</span></span><br><span class="line">    <span class="comment">//private static Executor executor = Executors.newFixedThreadPool(5);</span></span><br><span class="line">    <span class="comment">//private static Executor executor = Executors.newSingleThreadExecutor();</span></span><br><span class="line">    <span class="comment">//private static Executor executor = Executors.newCachedThreadPool();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Task1 task1 = <span class="keyword">new</span> Task1();<span class="comment">//构建任务</span></span><br><span class="line">        executor.execute(task1);<span class="comment">//执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 基本任务2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Task1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//具体任务的业务</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">                LOGGER.info(<span class="string">"&#123;&#125;..."</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutorTest test = <span class="keyword">new</span> ThreadPoolExecutorTest();</span><br><span class="line">        test.executeTask();</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated())&#123;</span><br><span class="line">            LOGGER.info(<span class="string">"finish......"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="Executors可以创建的几种线程"><a href="#Executors可以创建的几种线程" class="headerlink" title="Executors可以创建的几种线程"></a>Executors可以创建的几种线程</h3><ol><li>newFixedThreadPool(int corePoolSize)  <ul><li>创建一个线程数固定（corePoolSize==maximumPoolSize）的线程池</li><li>核心线程会一直运行</li><li>如果一个核心线程由于异常挂了，会新创建一个线程</li><li>无界队列LinkedBlockingQueue</li></ul></li><li>newSingleThreadExecutor<ul><li>创建一个线程数固定（corePoolSize==maximumPoolSize==1）的线程池</li><li>核心线程会一直运行</li><li>无界队列LinkedBlockingQueue</li><li>所有task都是串行执行的（即同一时刻只有一个任务在执行）</li></ul></li><li>newCachedThreadPool<ul><li>corePoolSize==0</li><li>maximumPoolSize==Integer.MAX_VALUE</li><li>队列：SynchronousQueue</li><li>创建一个线程池：当池中的线程都处于忙碌状态时，会立即新建一个线程来处理新来的任务</li><li>这种池将会在执行许多耗时短的异步任务的时候提高程序的性能</li><li>60秒内没有使用的线程将会被中止，并且从线程池中移除，因此几乎不必担心耗费资源</li></ul></li><li>newScheduledThreadPool(int corePoolSize)<ul><li>用于执行定时或延迟执行的任务，最典型的：异步操作时的超时回调</li></ul></li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 1、创建一个线程数固定（corePoolSize==maximumPoolSize）的线程池,</span><br><span class="line"> * 2、核心线程会一直运行</span><br><span class="line"> * 3、无界队列LinkedBlockingQueue</span><br><span class="line"> */</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用于创建ForkJoin框架中用到的ForkJoinPool线程</span><br><span class="line"> * @param parallelism 并行数</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static ExecutorService newWorkStealingPool(int parallelism) &#123;</span><br><span class="line">    return new ForkJoinPool</span><br><span class="line">        (parallelism,</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         null, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ExecutorService newWorkStealingPool() &#123;</span><br><span class="line">    return new ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         null, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 1、创建一个线程数固定（corePoolSize==maximumPoolSize==1）的线程池</span><br><span class="line"> * 2、核心线程会一直运行</span><br><span class="line"> * 3、无界队列LinkedBlockingQueue</span><br><span class="line"> * 注意：所有task都是串行执行的</span><br><span class="line"> */</span><br><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 1、创建一个线程池：当池中的线程都处于忙碌状态时，会立即新建一个线程来处理新来的任务</span><br><span class="line"> * 2、这种池将会在执行许多耗时短的异步任务的时候提高程序的性能。</span><br><span class="line"> * 3、60秒内没有使用的线程将会被中止，并且从线程池中移除，因此几乎不必担心耗费资源</span><br><span class="line"> * 4、队列：SynchronousQueue</span><br><span class="line"> * 5、maximumPoolSize为Integer.MAX_VALUE</span><br><span class="line"> */</span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 创建一个线程池：该线程池可以用于执行延时任务或者定时任务</span><br><span class="line"> */</span><br><span class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123;</span><br><span class="line">    return new DelegatedScheduledExecutorService</span><br><span class="line">        (new ScheduledThreadPoolExecutor(1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new DelegatedScheduledExecutorService</span><br><span class="line">        (new ScheduledThreadPoolExecutor(1, threadFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ScheduledExecutorService newScheduledThreadPool(</span><br><span class="line">        int corePoolSize, ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 主要用于包装现有的线程池，包装之后的线程池不能修改</span><br><span class="line"> * @param executor</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static ExecutorService unconfigurableExecutorService(ExecutorService executor) &#123;</span><br><span class="line">    if (executor == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return new DelegatedExecutorService(executor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用于包装可以周期性执行任务的线程池，包装之后的线程池不能修改</span><br><span class="line"> * @param executor</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor) &#123;</span><br><span class="line">    if (executor == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return new DelegatedScheduledExecutorService(executor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 默认的工厂方法类</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static ThreadFactory defaultThreadFactory() &#123;</span><br><span class="line">    return new DefaultThreadFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;Executors 这个类，因为它仅仅是工具类，它的所有方法都是 static 的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Demo&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; com.fly.learn.executor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; org.slf4j.Logger;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; org.slf4j.LoggerFactory;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.Executor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.ExecutorService;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.Executors;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 线程池test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@author&lt;/span&gt;: peijiepang&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@date&lt;/span&gt; 2018/11/23&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@Description&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadPoolExecutorTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(ThreadPoolExecutorTest.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//private static ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 30, TimeUnit.SECONDS, new ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(10));&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//private static Executor executor = Executors.newFixedThreadPool(5);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//private static Executor executor = Executors.newSingleThreadExecutor();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//private static Executor executor = Executors.newCachedThreadPool();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; ExecutorService executor = Executors.newScheduledThreadPool(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;executeTask&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Task1 task1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Task1();&lt;span class=&quot;comment&quot;&gt;//构建任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        executor.execute(task1);&lt;span class=&quot;comment&quot;&gt;//执行任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 基本任务2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Task1&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runnable&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//具体任务的业务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                LOGGER.info(&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;&amp;#125;...&quot;&lt;/span&gt;,i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ThreadPoolExecutorTest test = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutorTest();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        test.executeTask();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        executor.shutdown();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (!executor.isTerminated())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            LOGGER.info(&lt;span class=&quot;string&quot;&gt;&quot;finish......&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="juc" scheme="blog.ppjys.cn/categories/juc/"/>
    
    
      <category term="executors" scheme="blog.ppjys.cn/tags/executors/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务在Sharding-Sphere中的实现</title>
    <link href="blog.ppjys.cn/2018/11/23/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%9C%A8Sharding-Sphere%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>blog.ppjys.cn/2018/11/23/分布式事务在Sharding-Sphere中的实现/</id>
    <published>2018-11-23T13:05:58.000Z</published>
    <updated>2018-11-23T13:23:15.666Z</updated>
    
    <content type="html"><![CDATA[<p>本文根据dbaplus社群第156期线上分享整理而成.地址：<a href="https://m.qlchat.com/topic/details?topicId=2000001669563722&amp;tracePage=liveCenter" target="_blank" rel="noopener">https://m.qlchat.com/topic/details?topicId=2000001669563722&amp;tracePage=liveCenter</a></p><p>讲解人：赵俊 京东金融高级Java开发工程师</p><h3 id="分布式事务的使用场景"><a href="#分布式事务的使用场景" class="headerlink" title="分布式事务的使用场景"></a>分布式事务的使用场景</h3><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><ul><li>Atomicity：原子性  <blockquote><p>事务作为整体来执行，要么全部执行，要么全不执行。</p></blockquote></li><li>Consistency：一致性<blockquote><p>事务应确保数据从一个一致的状态转变为另一个一致的状态。</p></blockquote></li><li>Isolation：隔离性<blockquote><p>多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</p></blockquote></li><li>Durability：持久性<blockquote><p>已提交的事务修改数据会被持久保持。</p></blockquote></li></ul><p>关系型数据库的本地事务完美的提供了对ACID的原生支持。但在分布式的场景下，它却成为系统性能的桎梏。如何让数据库在分布式场景下满足ACID的特性或找寻相应的替代方案，是本文将要阐述的话题。</p><h4 id="CAP和Base理论"><a href="#CAP和Base理论" class="headerlink" title="CAP和Base理论"></a>CAP和Base理论</h4><p>对于互联网应用而言，随着访问量和数据量的激增，传统的单体架构模式将无法满足业务的高速发展。这时，开发者需要把单体应用拆分为多个独立的小应用，把单个数据库按照分片规则拆分为多个库和多个表。</p><p>数据拆分后，如何在多个数据库节点间保证本地事务的ACID特性则成为一个技术难题，并且由此而衍生出了CAP和BASE经典理论。</p><p>CAP理论指出，对于分布式的应用而言，不可能同时满足C（一致性），A（可用性），P（分区容错性），由于网络分区是分布式应用的基本要素，因此开发者需要在C和A上做出平衡。</p><p>由于C和A互斥性，其权衡的结果就是BASE理论。</p><p>对于大部分的分布式应用而言，只要数据在规定的时间内达到最终一致性即可。我们可以把符合传统的ACID叫做刚性事务，把满足BASE理论的最终一致性事务叫做柔性事务。</p><p>一味的追求强一致性，并非最佳方案。对于分布式应用来说，刚柔并济是更加合理的设计方案，即在本地服务中采用强一致事务，在跨系统调用中采用最终一致性。如何权衡系统的性能与一致性，是十分考验架构师与开发者的设计功力的。</p><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/1.png" width="500px"></p><a id="more"></a><h3 id="业界方法"><a href="#业界方法" class="headerlink" title="业界方法"></a>业界方法</h3><p>具体到分布式事务的实现上，业界主要采用了XA协议的强一致规范以及柔性事务的最终一致规范。</p><h4 id="XA事物"><a href="#XA事物" class="headerlink" title="XA事物"></a>XA事物</h4><p>XA是X/Open CAE Specification (Distributed Transaction Processing)模型中定义的TM（Transaction Manager）与RM（Resource Manager）之间进行通信的接口。</p><p>Java中的javax.transaction.xa.XAResource定义了XA接口，它依赖数据库厂商对jdbc-driver的具体实现。</p><p>mysql-connector-java-5.1.30的实现可参考com.mysql.jdbc.jdbc2.optional.MysqlXAConnection。</p><p>在XA规范中，数据库充当RM角色，应用需要充当TM的角色，即生成全局的txId，调用XAResource接口，把多个本地事务协调为全局统一的分布式事务。</p><p>一阶段提交：弱XA</p><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/2.png" width="500px"></p><p>弱XA通过去掉XA的Prepare阶段，以达到减少资源锁定范围而提升并发性能的效果。典型的实现为在一个业务线程中，遍历所有的数据库连接，依次做commit或者rollback。弱XA同本地事务相比，性能损耗低，但在事务提交的执行过程中，若出现网络故障、数据库宕机等预期之外的异常，将会造成数据不一致，且无法进行回滚。基于弱XA的事务无需额外的实现成本，因此Sharding-Sphere默认支持。</p><p>二阶段提交：2PC</p><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/3.png" width="500px"></p><p>二阶段提交是XA的标准实现。它将分布式事务的提交拆分为2个阶段：prepare和commit/rollback。</p><p>开启XA全局事务后，所有子事务会按照本地默认的隔离级别锁定资源，并记录undo和redo日志，然后由TM发起prepare投票，询问所有的子事务是否可以进行提交：当所有子事务反馈的结果为“yes”时，TM再发起commit；若其中任何一个子事务反馈的结果为“no”，TM则发起rollback；如果在prepare阶段的反馈结果为yes，而commit的过程中出现宕机等异常时，则在节点服务重启后，可根据XA recover再次进行commit补偿，以保证数据的一致性。</p><p>2PC模型中，在prepare阶段需要等待所有参与子事务的反馈，因此可能造成数据库资源锁定时间过长，不适合并发高以及子事务生命周长较长的业务场景。</p><p>Sharding-Sphere支持基于XA的强一致性事务解决方案，可以通过SPI注入不同的第三方组件作为事务管理器实现XA协议，如Atomikos和Narayana。</p><h4 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h4><p>柔性事务是对XA协议的妥协和补偿，它通过对强一致性要求的降低，已达到降低数据库资源锁定时间的效果。柔性事务的种类很多，可以通过各种不同的策略来权衡使用。</p><p>一阶段提交 + 补偿 ：最大努力送达（BED）</p><p>最大努力送达，是针对于弱XA的一种补偿策略。它采用事务表记录所有的事务操作SQL，如果子事务提交成功，将会删除事务日志；如果执行失败，则会按照配置的重试次数，尝试再次提交，即最大努力的进行提交，尽量保证数据的一致性，这里可以根据不同的业务场景，平衡C和A，采用同步重试或异步重试。</p><p>这种策略的优点是无锁定资源时间，性能损耗小。缺点是尝试多次提交失败后，无法回滚，它仅适用于事务最终一定能够成功的业务场景。因此BED是通过事务回滚功能上的妥协，来换取性能的提升。</p><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/4.png" width="500px"></p><h5 id="TCC：-Try-Confirm-Cancel"><a href="#TCC：-Try-Confirm-Cancel" class="headerlink" title="TCC： Try-Confirm-Cancel"></a>TCC： Try-Confirm-Cancel</h5><p>TCC模型是把锁的粒度完全交给业务处理，它需要每个子事务业务都实现Try-Confirm/Cancel接口。</p><ul><li><p>Try:</p><blockquote><p>尝试执行业务；<br>完成所有业务检查（一致性）；<br>预留必须业务资源（准隔离性）；</p></blockquote></li><li><p>Confirm:</p><blockquote><p>确认执行业务；<br>真正执行业务，不作任何业务检查；<br>只使用Try阶段预留的业务资源；<br>Confirm操作满足幂等性；</p></blockquote></li><li><p>Cancel:</p><blockquote><p>取消执行业务；<br>释放Try阶段预留的业务资源；<br>Cancel操作满足幂等性。  </p></blockquote></li></ul><p>这三个阶段都会按本地事务的方式执行，不同于XA的prepare，TCC无需将XA的投票期间的所有资源挂起，因此极大的提高了吞吐量。</p><p>下面对TCC模式下，A账户往B账户汇款100元为例子，对业务的改造进行详细的分析：</p><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/5.png" width="500px"></p><p>汇款服务和收款服务分别需要实现，Try-Confirm-Cancel接口，并在业务初始化阶段将其注入到TCC事务管理器中。</p><h5 id="消息驱动"><a href="#消息驱动" class="headerlink" title="消息驱动"></a>消息驱动</h5><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/6.png" width="500px"></p><p>消息一致性方案是通过消息中间件保证上下游应用数据操作的一致性。基本思路是将本地操作和发送消息放在一个事务中，下游应用向消息系统订阅该消息，收到消息后执行相应操作。本质上是依靠消息的重试机制，达到最终一致性。消息驱动的缺点是：耦合度高，需要在业务系统中引入MQ，导致系统复杂度增加。</p><h5 id="SAGA"><a href="#SAGA" class="headerlink" title="SAGA"></a>SAGA</h5><p>Saga起源于1987年Hector &amp; Kenneth发表的论文Sagas。</p><p>参考地址：<a href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf" target="_blank" rel="noopener">https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf</a></p><p>Saga工作原理</p><p>Saga模型把一个分布式事务拆分为多个本地事务，每个本地事务都有相应的执行模块和补偿模块（ TCC中的Confirm和Cancel）。当Saga事务中任意一个本地事务出错时，可以通过调用相关的补偿方法恢复之前的事务，达到事务最终的一致性。</p><p>当每个Saga子事务 T1, T2, …, Tn 都有对应的补偿定义 C1, C2, …, Cn-1,那么Saga系统可以保证：</p><p>子事务序列 T1, T2, …, Tn得以完成 (最佳情况)；<br>或者序列 T1, T2, …, Tj, Cj, …, C2, C1, 0 &lt; j &lt; n, 得以完成。<br>由于Saga模型中没有Prepare阶段，因此事务间不能保证隔离性，当多个Saga事务操作同一资源时，就会产生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：</p><p>在应用层面加锁；<br>应用层面预先冻结资源。<br>Saga恢复方式</p><p>Saga支持向前和向后恢复：</p><p>向后恢复：补偿所有已完成的事务，如果任一子事务失败；<br>向前恢复：重试失败的事务，假设每个子事务最终都会成功。<br>显然，向前恢复没有必要提供补偿事务，如果你的业务中，子事务（最终）总会成功，或补偿事务难以定义或不可能，向前恢复更符合你的需求。理论上补偿事务永不失败，然而，在分布式世界中，服务器可能会宕机、网络可能会失败，甚至数据中心也可能会停电，这时需要提供故障恢复后回退的机制，比如人工干预。</p><p>总的来说，TCC和MQ都是以服务为范围进行分布式事务的处理，而XA、BED、SAGA则是以数据库为范围进行分布式处理，我们更趋向于选择后者，对于业务而言侵入小，改造的成本低。</p><h3 id="Sharding-Sphere对分布式事务的支持"><a href="#Sharding-Sphere对分布式事务的支持" class="headerlink" title="Sharding-Sphere对分布式事务的支持"></a>Sharding-Sphere对分布式事务的支持</h3><p>Sharding-Sphere是一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar这3款相互独立的产品组成。它们均提供标准化的数据分片、读写分离、柔性事务和数据治理功能，可适用于如Java同构、异构语言、容器、云原生等各种多样化的应用场景。</p><p>项目地址：<a href="https://github.com/sharding-sphere/sharding-sphere/" target="_blank" rel="noopener">https://github.com/sharding-sphere/sharding-sphere/</a></p><p>Sharding-Sphere同时支持XA和柔性事务，它允许每次对数据库的访问，可以自由选择事务类型。分布式事务对业务操作完全透明，极大地降低了引入分布式事务的成本。</p><ol><li>事务模型</li></ol><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/7.png" width="500px"></p><p>Sharding-Sphere事务管理器集成了XA和柔性事务模型：</p><p>对于XA事务而言，采用SPI的方式让弱XA、Atomikos、Narayana间保持互斥；<br>对于柔性事务而言，根据每次连接中事务的类型，可以选择独立的事务管理器进行处理，每个事务管理器都会实现标准的ShardingTransaction接口，在TransactionEvent到来时，执行对应的begin、commit、rollback操作。<br>下面将Sharding-Sphere内部如何用事件驱动方式，将事务从分片主流程中解耦进行详细说明：</p><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/8.png" width="500px"></p><p>从图可以看出在Sharding-core在调用执行引擎时，会根据SQL的种类产生事件进行分发。事务监听线程在收到符合要求的事件后，再调用对应的事务处理器进行处理。</p><ol start="2"><li>Sharding-Proxy事务实现<br>Sharding-Proxy是基于netty开发的数据库中间代理层，实现了标准的MySQL协议，可以看做是一个实现了数据分片的数据库。Sharding-Proxy已经实现了基于Atomikos的XA事务，为了保证所有的子事务都处于同一个线程之中，整个Proxy的线程模型进行了如下的调整：</li></ol><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/9.png" width="500px"></p><p>当开启事务后，Proxy后端的SQL命令执行引擎将采用一通道一线程的模式，此事务线程的生命周期同通道保持一致。事务处理的具体过程与Proxy彻底解耦，即Proxy将发布事务类型的事件，然后Sharding-Sphere-TM根据传入的事务消息，选择具体的TM进行处理。</p><p>压测结果表明：XA事务的插入和更新的性能，基本上同跨库的个数呈线性关系，查询的性能基本不受影响，建议在并发量不大，每次事务涉及的库在10个以内时，可以使用XA。</p><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/10.png" width="500px"><br><br><br><br><br><br><br>Atomikos事务管理器原理分析<br><br><br><br></p><p>Atomikos的事务管理器可以内嵌到业务进程中，当应用调用TransactionManager.begin时，将会创建本次XA事务，并且与当前线程关联。同时Atomikos也对DataSource中的connection做了二次封装，代理connection中含有本次事务相关信息的状态，并且拦截了connection的JDBC操作。</p><p>在createStatement时，调用XAResource.start进行资源注册；在close时，调用XAResource.end让XA事务处于idel可提交状态；在commit或rollback时，依次调用prepare和commit进行二阶段提交。</p><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/11.png" width="500px"></p><h3 id="Sharding-Sphere的Saga事务实现"><a href="#Sharding-Sphere的Saga事务实现" class="headerlink" title="Sharding-Sphere的Saga事务实现"></a>Sharding-Sphere的Saga事务实现</h3><p>Sharding-Sphere通过与Apache Service Comb的合作，将采用Service Comb的Saga事务引擎作为的分布式事务实现。</p><p>Apache Service Comb是华为开源的微服务框架，其中微服务事务处理框架分为集中式和分布式协调器。未来会在Sharding-Sphere内部集成Saga集中式协调器，支持同一线程内不同服务（本地）间的分布式事务。</p><p>参考链接：<a href="https://github.com/apache/incubator-servicecomb-saga" target="_blank" rel="noopener">https://github.com/apache/incubator-servicecomb-saga</a></p><p>Service Comb 集中式事务协调器</p><p>集中式的协调器，包含了Saga调用请求接收、分析、执行以及结果查询的内容。任务代理模块需要预先知道Saga事务调用关系图，执行模块根据生成的调用图产生调用任务，调用相关微服务服务接口。如果服务调用执行出错，会调用服务的相关的补偿方法回滚。</p><p>Saga执行模块通过分析请求的JSON数据，来构建一个调用关系图。Sharding-Sphere是通过JSON描述Saga事务串行调用子事务或者并行调用子事务。关系调用图被Saga实现中的任务运行模块分解成为一个一个执行任务，执行任务由任务消费者获取并生成相关的调用 （同时支持串行和并行调用）。Saga任务会根据执行的情况向Saga Log中记录对应的Saga事务的关键事件，并可以通过事件查看器查查询执行情况。</p><h4 id="Sharding-Sphere内嵌Saga事务管理器"><a href="#Sharding-Sphere内嵌Saga事务管理器" class="headerlink" title="Sharding-Sphere内嵌Saga事务管理器"></a>Sharding-Sphere内嵌Saga事务管理器</h4><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/13.png" width="500px"></p><p>Saga以jar包的形式提供分布式事务治理能力。</p><p>对Sharding-Sphere而言，confirm和cancel过程代表了子事务中的正常执行SQL和逆向执行SQL，（未来Sharding-Sphere将提供自动生成逆向SQL的能力）。当启用Saga柔性事务后，路由完成之后的物理数据源将开启本地自动提交事务，每次confirm和cancel都会直接提交。</p><p>在Sharding-Sphere内部，触发SQL执行引擎后，将会产生Saga事务事件，这时Sharding-Sphere事务监听器会注册本次子事务的confirm和cancel至Saga事务管理器的队列中；在业务线程触发commit和rollback后，Saga事务管理器再根据子事务执行的结果，判断进行confirm重试或者cancel流程。</p><h3 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h3><p>未来Sharding-Sphere将按照文中介绍的Sharding-Sphere-TM逐步完善整个事务框架：</p><ul><li>弱XA事务 （已发布）</li><li>基于Atomikos的XA事务（近期发布）</li><li>基于Narayana的XA事务（规划中）</li><li>BED柔性事务（已发布）</li><li>SAGA（开发中）</li><li>TCC（规划中）<br>如果前面的分享太过冗长，那么千言万语汇聚成一张表格，欢迎阅读。</li></ul><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/14.png" width="500px"></p><h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><p><strong>Q1：</strong> 基于XA的事物，可以应用到微服务架构中吗？</p><p><strong>A1：</strong> 目前我们是把事务管理器内嵌到JVM进程中，对于并发量小，短事务的业务，可以用XA。</p><p><strong>Q2：</strong> 对于各个事务框架开发计划的先后顺序是基本什么来确定的呢？</p><p><strong>A2：</strong> 基于难易程度，所以我们把TCC放到了最后。</p><p><strong>Q3：</strong> 支持多语言吗？比如golang？</p><p><strong>A3：</strong> 多语言可以用Sharding-Proxy。</p><p><strong>Q4：</strong> 这次是Proxy实现分布式事务吧？我记得之前Sharding-JDBC有实现。</p><p><strong>A4：</strong> 这次是整个SS的事务实现，包含Sharding-JDBC和Proxy，目前SJ的实现是弱XA和BED（最大努力送达），以后会增加SAGA和TCC。</p><p><strong>Q5：</strong> 如果我只想用SS里的事务模块，可以吗？</p><p><strong>A5：</strong> SS是以事件驱动的方式进行的架构，未来事务模块只负责事务相关的处理。</p><p><strong>Q6：</strong> SAGA不支持ACID中的I，咱们这边怎么考虑的呢？</p><p><strong>A6：</strong> 目前暂不支持隔离性，今后我们有增加I的规划，其实所有的柔性事务都不支持I，TCC增加了Try阶段，可以理解是准隔离性，使用SAGA时，可以在业务层面控制并发，防止脏读等产生。</p><p><strong>Q7：</strong> 那意思，现在3的版本还不能单独用事务的模块？</p><p><strong>A7：</strong> 现在3.0版本，事务模块依赖了Sharding-JDBC模块，事务模块需要监听Sharding-JDBC和Proxy中的事件，然后进行事务操作。如果你想单独用事务模块，需要按Core中定义的事件，在你的业务里进行发布。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文根据dbaplus社群第156期线上分享整理而成.地址：&lt;a href=&quot;https://m.qlchat.com/topic/details?topicId=2000001669563722&amp;amp;tracePage=liveCenter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://m.qlchat.com/topic/details?topicId=2000001669563722&amp;amp;tracePage=liveCenter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;讲解人：赵俊 京东金融高级Java开发工程师&lt;/p&gt;
&lt;h3 id=&quot;分布式事务的使用场景&quot;&gt;&lt;a href=&quot;#分布式事务的使用场景&quot; class=&quot;headerlink&quot; title=&quot;分布式事务的使用场景&quot;&gt;&lt;/a&gt;分布式事务的使用场景&lt;/h3&gt;&lt;h4 id=&quot;ACID&quot;&gt;&lt;a href=&quot;#ACID&quot; class=&quot;headerlink&quot; title=&quot;ACID&quot;&gt;&lt;/a&gt;ACID&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Atomicity：原子性  &lt;blockquote&gt;
&lt;p&gt;事务作为整体来执行，要么全部执行，要么全不执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Consistency：一致性&lt;blockquote&gt;
&lt;p&gt;事务应确保数据从一个一致的状态转变为另一个一致的状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Isolation：隔离性&lt;blockquote&gt;
&lt;p&gt;多个事务并发执行时，一个事务的执行不应影响其他事务的执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Durability：持久性&lt;blockquote&gt;
&lt;p&gt;已提交的事务修改数据会被持久保持。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关系型数据库的本地事务完美的提供了对ACID的原生支持。但在分布式的场景下，它却成为系统性能的桎梏。如何让数据库在分布式场景下满足ACID的特性或找寻相应的替代方案，是本文将要阐述的话题。&lt;/p&gt;
&lt;h4 id=&quot;CAP和Base理论&quot;&gt;&lt;a href=&quot;#CAP和Base理论&quot; class=&quot;headerlink&quot; title=&quot;CAP和Base理论&quot;&gt;&lt;/a&gt;CAP和Base理论&lt;/h4&gt;&lt;p&gt;对于互联网应用而言，随着访问量和数据量的激增，传统的单体架构模式将无法满足业务的高速发展。这时，开发者需要把单体应用拆分为多个独立的小应用，把单个数据库按照分片规则拆分为多个库和多个表。&lt;/p&gt;
&lt;p&gt;数据拆分后，如何在多个数据库节点间保证本地事务的ACID特性则成为一个技术难题，并且由此而衍生出了CAP和BASE经典理论。&lt;/p&gt;
&lt;p&gt;CAP理论指出，对于分布式的应用而言，不可能同时满足C（一致性），A（可用性），P（分区容错性），由于网络分区是分布式应用的基本要素，因此开发者需要在C和A上做出平衡。&lt;/p&gt;
&lt;p&gt;由于C和A互斥性，其权衡的结果就是BASE理论。&lt;/p&gt;
&lt;p&gt;对于大部分的分布式应用而言，只要数据在规定的时间内达到最终一致性即可。我们可以把符合传统的ACID叫做刚性事务，把满足BASE理论的最终一致性事务叫做柔性事务。&lt;/p&gt;
&lt;p&gt;一味的追求强一致性，并非最佳方案。对于分布式应用来说，刚柔并济是更加合理的设计方案，即在本地服务中采用强一致事务，在跨系统调用中采用最终一致性。如何权衡系统的性能与一致性，是十分考验架构师与开发者的设计功力的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/1.png&quot; width=&quot;500px&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="distributed transaction" scheme="blog.ppjys.cn/categories/distributed-transaction/"/>
    
    
      <category term="shard-sphere" scheme="blog.ppjys.cn/tags/shard-sphere/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池AbstractExecutorService原理分析</title>
    <link href="blog.ppjys.cn/2018/11/22/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0AbstractExecutorService%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>blog.ppjys.cn/2018/11/22/Java线程池AbstractExecutorService原理分析/</id>
    <published>2018-11-22T15:34:04.000Z</published>
    <updated>2018-11-22T15:37:19.975Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>AbstractExecutorService 抽象类派生自 ExecutorService 接口，然后在其基础上实现了几个实用的方法，这些方法提供给子类进行调用。ExecutorService又是继承Executor接口。接下来我们就来一一分析。</p><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><ol><li>Executor接口<br>我们可以看到 Executor 接口非常简单，就一个 void execute(Runnable command) 方法，代表提交一个任务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * @since 1.5</span></span><br><span class="line"><span class="comment"> * @author Doug Lea</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="2"><li><p>ExecutorServer接口<br>这些方法都很好理解，一个简单的线程池主要就是这些功能，能提交任务，能获取结果，能关闭线程池，这也是为什么我们经常用这个接口的原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭线程池，已提交的任务继续执行，不接受继续提交新任务</span></span><br><span class="line"><span class="comment">     * Initiates an orderly shutdown in which previously submitted</span></span><br><span class="line"><span class="comment">     * tasks are executed, but no new tasks will be accepted.</span></span><br><span class="line"><span class="comment">     * Invocation has no additional effect if already shut down.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method does not wait for previously submitted tasks to</span></span><br><span class="line"><span class="comment">     * complete execution.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125;</span></span><br><span class="line"><span class="comment">     * to do that.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SecurityException if a security manager exists and</span></span><br><span class="line"><span class="comment">     *         shutting down this ExecutorService may manipulate</span></span><br><span class="line"><span class="comment">     *         threads that the caller is not permitted to modify</span></span><br><span class="line"><span class="comment">     *         because it does not hold &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *         java.lang.RuntimePermission&#125;&#123;<span class="doctag">@code</span> ("modifyThread")&#125;,</span></span><br><span class="line"><span class="comment">     *         or the security manager's &#123;<span class="doctag">@code</span> checkAccess&#125; method</span></span><br><span class="line"><span class="comment">     *         denies access.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭线程池，尝试停止正在执行的所有任务，不接受继续提交新任务</span></span><br><span class="line"><span class="comment">     * 它和前面的方法相比，加了一个单词“now”，区别在于它会去停止当前正在进行的任务</span></span><br><span class="line"><span class="comment">     * Attempts to stop all actively executing tasks, halts the</span></span><br><span class="line"><span class="comment">     * processing of waiting tasks, and returns a list of the tasks</span></span><br><span class="line"><span class="comment">     * that were awaiting execution.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method does not wait for actively executing tasks to</span></span><br><span class="line"><span class="comment">     * terminate.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125; to</span></span><br><span class="line"><span class="comment">     * do that.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;There are no guarantees beyond best-effort attempts to stop</span></span><br><span class="line"><span class="comment">     * processing actively executing tasks.  For example, typical</span></span><br><span class="line"><span class="comment">     * implementations will cancel via &#123;<span class="doctag">@link</span> Thread#interrupt&#125;, so any</span></span><br><span class="line"><span class="comment">     * task that fails to respond to interrupts may never terminate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> list of tasks that never commenced execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SecurityException if a security manager exists and</span></span><br><span class="line"><span class="comment">     *         shutting down this ExecutorService may manipulate</span></span><br><span class="line"><span class="comment">     *         threads that the caller is not permitted to modify</span></span><br><span class="line"><span class="comment">     *         because it does not hold &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *         java.lang.RuntimePermission&#125;&#123;<span class="doctag">@code</span> ("modifyThread")&#125;,</span></span><br><span class="line"><span class="comment">     *         or the security manager's &#123;<span class="doctag">@code</span> checkAccess&#125; method</span></span><br><span class="line"><span class="comment">     *         denies access.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池是否已关闭</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this executor has been shut down.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this executor has been shut down</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法必须在调用shutdown或shutdownNow方法之后调用才会返回true</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if all tasks have completed following shut down.</span></span><br><span class="line"><span class="comment">     * Note that &#123;<span class="doctag">@code</span> isTerminated&#125; is never &#123;<span class="doctag">@code</span> true&#125; unless</span></span><br><span class="line"><span class="comment">     * either &#123;<span class="doctag">@code</span> shutdown&#125; or &#123;<span class="doctag">@code</span> shutdownNow&#125; was called first.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if all tasks have completed following shut down</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待所有任务完成，并设置超时时间</span></span><br><span class="line"><span class="comment">     * Blocks until all tasks have completed execution after a shutdown</span></span><br><span class="line"><span class="comment">     * request, or the timeout occurs, or the current thread is</span></span><br><span class="line"><span class="comment">     * interrupted, whichever happens first.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this executor terminated and</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> false&#125; if the timeout elapsed before termination</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交一个 Callable 任务</span></span><br><span class="line"><span class="comment">     * Submits a value-returning task for execution and returns a</span></span><br><span class="line"><span class="comment">     * Future representing the pending results of the task. The</span></span><br><span class="line"><span class="comment">     * Future's &#123;<span class="doctag">@code</span> get&#125; method will return the task's result upon</span></span><br><span class="line"><span class="comment">     * successful completion.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * If you would like to immediately block waiting</span></span><br><span class="line"><span class="comment">     * for a task, you can use constructions of the form</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> result = exec.submit(aCallable).get();&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note: The &#123;<span class="doctag">@link</span> Executors&#125; class includes a set of methods</span></span><br><span class="line"><span class="comment">     * that can convert some other common closure-like objects,</span></span><br><span class="line"><span class="comment">     * for example, &#123;<span class="doctag">@link</span> java.security.PrivilegedAction&#125; to</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Callable&#125; form so they can be submitted.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to submit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the task's result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Future representing pending completion of the task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交一个 Runnable 任务，第二个参数将会放到 Future 中，作为返回值</span></span><br><span class="line"><span class="comment">     * 因为 Runnable 的 run 方法本身并不返回任何东西</span></span><br><span class="line"><span class="comment">     * Submits a Runnable task for execution and returns a Future</span></span><br><span class="line"><span class="comment">     * representing that task. The Future's &#123;<span class="doctag">@code</span> get&#125; method will</span></span><br><span class="line"><span class="comment">     * return the given result upon successful completion.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to submit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result the result to return</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Future representing pending completion of the task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交一个 Runnable 任务</span></span><br><span class="line"><span class="comment">     * Submits a Runnable task for execution and returns a Future</span></span><br><span class="line"><span class="comment">     * representing that task. The Future's &#123;<span class="doctag">@code</span> get&#125; method will</span></span><br><span class="line"><span class="comment">     * return &#123;<span class="doctag">@code</span> null&#125; upon &lt;em&gt;successful&lt;/em&gt; completion.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to submit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Future representing pending completion of the task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行所有任务，返回 Future 类型的一个 list</span></span><br><span class="line"><span class="comment">     * Executes the given tasks, returning a list of Futures holding</span></span><br><span class="line"><span class="comment">     * their status and results when all complete.</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Future#isDone&#125; is &#123;<span class="doctag">@code</span> true&#125; for each</span></span><br><span class="line"><span class="comment">     * element of the returned list.</span></span><br><span class="line"><span class="comment">     * Note that a &lt;em&gt;completed&lt;/em&gt; task could have</span></span><br><span class="line"><span class="comment">     * terminated either normally or by throwing an exception.</span></span><br><span class="line"><span class="comment">     * The results of this method are undefined if the given</span></span><br><span class="line"><span class="comment">     * collection is modified while this operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a list of Futures representing the tasks, in the same</span></span><br><span class="line"><span class="comment">     *         sequential order as produced by the iterator for the</span></span><br><span class="line"><span class="comment">     *         given task list, each of which has completed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting, in</span></span><br><span class="line"><span class="comment">     *         which case unfinished tasks are cancelled</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks or any of its elements are &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if any task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 也是执行所有任务，但是这里设置了超时时间</span></span><br><span class="line"><span class="comment">     * Executes the given tasks, returning a list of Futures holding</span></span><br><span class="line"><span class="comment">     * their status and results</span></span><br><span class="line"><span class="comment">     * when all complete or the timeout expires, whichever happens first.</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Future#isDone&#125; is &#123;<span class="doctag">@code</span> true&#125; for each</span></span><br><span class="line"><span class="comment">     * element of the returned list.</span></span><br><span class="line"><span class="comment">     * Upon return, tasks that have not completed are cancelled.</span></span><br><span class="line"><span class="comment">     * Note that a &lt;em&gt;completed&lt;/em&gt; task could have</span></span><br><span class="line"><span class="comment">     * terminated either normally or by throwing an exception.</span></span><br><span class="line"><span class="comment">     * The results of this method are undefined if the given</span></span><br><span class="line"><span class="comment">     * collection is modified while this operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a list of Futures representing the tasks, in the same</span></span><br><span class="line"><span class="comment">     *         sequential order as produced by the iterator for the</span></span><br><span class="line"><span class="comment">     *         given task list. If the operation did not time out,</span></span><br><span class="line"><span class="comment">     *         each task will have completed. If it did time out, some</span></span><br><span class="line"><span class="comment">     *         of these tasks will not have completed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting, in</span></span><br><span class="line"><span class="comment">     *         which case unfinished tasks are cancelled</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks, any of its elements, or</span></span><br><span class="line"><span class="comment">     *         unit are &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if any task cannot be scheduled</span></span><br><span class="line"><span class="comment">     *         for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果</span></span><br><span class="line"><span class="comment">     * Executes the given tasks, returning the result</span></span><br><span class="line"><span class="comment">     * of one that has completed successfully (i.e., without throwing</span></span><br><span class="line"><span class="comment">     * an exception), if any do. Upon normal or exceptional return,</span></span><br><span class="line"><span class="comment">     * tasks that have not completed are cancelled.</span></span><br><span class="line"><span class="comment">     * The results of this method are undefined if the given</span></span><br><span class="line"><span class="comment">     * collection is modified while this operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result returned by one of the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks or any element task</span></span><br><span class="line"><span class="comment">     *         subject to execution is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if tasks is empty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException if no task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if tasks cannot be scheduled</span></span><br><span class="line"><span class="comment">     *         for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同上一个方法，只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果，</span></span><br><span class="line"><span class="comment">     * 不过这个带超时，超过指定的时间，抛出 TimeoutException 异常</span></span><br><span class="line"><span class="comment">     * Executes the given tasks, returning the result</span></span><br><span class="line"><span class="comment">     * of one that has completed successfully (i.e., without throwing</span></span><br><span class="line"><span class="comment">     * an exception), if any do before the given timeout elapses.</span></span><br><span class="line"><span class="comment">     * Upon normal or exceptional return, tasks that have not</span></span><br><span class="line"><span class="comment">     * completed are cancelled.</span></span><br><span class="line"><span class="comment">     * The results of this method are undefined if the given</span></span><br><span class="line"><span class="comment">     * collection is modified while this operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result returned by one of the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks, or unit, or any element</span></span><br><span class="line"><span class="comment">     *         task subject to execution is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TimeoutException if the given timeout elapses before</span></span><br><span class="line"><span class="comment">     *         any task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException if no task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if tasks cannot be scheduled</span></span><br><span class="line"><span class="comment">     *         for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AbstractExecutorService抽象类<br>AbstractExecutorService 抽象类派生自 ExecutorService 接口，然后在其基础上实现了几个实用的方法，这些方法提供给子类进行调用。<br>这个抽象类实现了 invokeAny 方法和 invokeAll 方法，这里的两个 newTaskFor 方法也比较有用，用于将任务包装成 FutureTask。定义于最上层接口 Executor中的 void execute(Runnable command) 由于不需要获取结果，不会进行 FutureTask 的包装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RunnableFuture 是用于获取执行结果的，我们常用它的子类 FutureTask</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 1. 将任务包装成 FutureTask</span></span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 2. 交给执行器执行，execute 方法由具体的子类来实现</span></span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此方法目的：将 tasks 集合中的任务提交到线程池执行，任意一个线程执行完后就可以结束了</span></span><br><span class="line"><span class="comment"> * 第二个参数 timed 代表是否设置超时机制，超时时间为第三个参数，</span></span><br><span class="line"><span class="comment"> * 如果 timed 为 true，同时超时了还没有一个线程返回结果，那么抛出 TimeoutException 异常</span></span><br><span class="line"><span class="comment"> * the main mechanics of invokeAny.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doInvokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 任务数</span></span><br><span class="line">    <span class="keyword">int</span> ntasks = tasks.size();</span><br><span class="line">    <span class="keyword">if</span> (ntasks == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);</span><br><span class="line">    <span class="comment">// ExecutorCompletionService 不是一个真正的执行器，参数 this 才是真正的执行器</span></span><br><span class="line">    <span class="comment">// 它对执行器进行了包装，每个任务结束后，将结果保存到内部的一个 completionQueue 队列中</span></span><br><span class="line">    <span class="comment">// 这也是为什么这个类的名字里面有个 Completion 的原因吧。</span></span><br><span class="line">    ExecutorCompletionService&lt;T&gt; ecs =</span><br><span class="line">        <span class="keyword">new</span> ExecutorCompletionService&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For efficiency, especially in executors with limited</span></span><br><span class="line">    <span class="comment">// parallelism, check to see if previously submitted tasks are</span></span><br><span class="line">    <span class="comment">// done before submitting more of them. This interleaving</span></span><br><span class="line">    <span class="comment">// plus the exception mechanics account for messiness of main</span></span><br><span class="line">    <span class="comment">// loop.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 用于保存异常信息，此方法如果没有得到任何有效的结果，那么我们可以抛出最后得到的一个异常</span></span><br><span class="line">        <span class="comment">// Record exceptions so that if we fail to obtain any</span></span><br><span class="line">        <span class="comment">// result, we can throw the last exception we got.</span></span><br><span class="line">        ExecutionException ee = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        Iterator&lt;? extends Callable&lt;T&gt;&gt; it = tasks.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先先提交一个任务，后面的任务到下面的 for 循环一个个提交</span></span><br><span class="line">        <span class="comment">// Start one task for sure; the rest incrementally</span></span><br><span class="line">        futures.add(ecs.submit(it.next()));</span><br><span class="line">        <span class="comment">// 提交了一个任务，所以任务数量减 1</span></span><br><span class="line">        --ntasks;</span><br><span class="line">        <span class="comment">// 正在执行的任务数(提交的时候 +1，任务结束的时候 -1)</span></span><br><span class="line">        <span class="keyword">int</span> active = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// ecs 上面说了，其内部有一个 completionQueue 用于保存执行完成的结果</span></span><br><span class="line">            <span class="comment">// BlockingQueue 的 poll 方法不阻塞，返回 null 代表队列为空</span></span><br><span class="line">            Future&lt;T&gt; f = ecs.poll();</span><br><span class="line">            <span class="comment">// 为 null，说明刚刚提交的第一个线程还没有执行完成</span></span><br><span class="line">            <span class="comment">// 在前面先提交一个任务，加上这里做一次检查，也是为了提高性能</span></span><br><span class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ntasks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    --ntasks;</span><br><span class="line">                    futures.add(ecs.submit(it.next()));</span><br><span class="line">                    ++active;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里是 else if，不是 if。这里说明，没有任务了，同时 active 为 0 说明</span></span><br><span class="line">                <span class="comment">// 任务都执行完成了。其实我也没理解为什么这里做一次 break？</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (active == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 这里也是 else if。这里说的是，没有任务了，但是设置了超时时间，这里检测是否超时</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                    <span class="comment">// 带等待的 poll 方法</span></span><br><span class="line">                    f = ecs.poll(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                    <span class="comment">// 如果已经超时，抛出 TimeoutException 异常，这整个方法就结束了</span></span><br><span class="line">                    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                    nanos = deadline - System.nanoTime();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里是 else。说明，没有任务需要提交，但是池中的任务没有完成，还没有超时(如果设置了超时)</span></span><br><span class="line">                <span class="comment">// take() 方法会阻塞，直到有元素返回，说明有任务结束了</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f = ecs.take();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有任务结束了</span></span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">                --active;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 返回执行结果，如果有异常，都包装成 ExecutionException</span></span><br><span class="line">                    <span class="keyword">return</span> f.get();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException eex) &#123;</span><br><span class="line">                    ee = eex;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException rex) &#123;</span><br><span class="line">                    ee = <span class="keyword">new</span> ExecutionException(rex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ee == <span class="keyword">null</span>)</span><br><span class="line">            ee = <span class="keyword">new</span> ExecutionException();</span><br><span class="line">        <span class="keyword">throw</span> ee;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 方法退出之前，取消其他的任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">            futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> doInvokeAny(tasks, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException cannotHappen) &#123;</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doInvokeAny(tasks, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行所有的任务，返回任务结果。</span></span><br><span class="line"><span class="comment">// 先不要看这个方法，我们先想想，其实我们自己提交任务到线程池，也是想要线程池执行所有的任务</span></span><br><span class="line"><span class="comment">// 只不过，我们是每次 submit 一个任务，这里以一个集合作为参数提交</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">            <span class="comment">// 包装成 FutureTask</span></span><br><span class="line">            RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br><span class="line">            futures.add(f);</span><br><span class="line">            <span class="comment">// 提交任务</span></span><br><span class="line">            execute(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++) &#123;</span><br><span class="line">            Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 这是一个阻塞方法，直到获取到值，或抛出了异常</span></span><br><span class="line">                    <span class="comment">// 这里有个小细节，其实 get 方法签名上是会抛出 InterruptedException 的</span></span><br><span class="line">                    <span class="comment">// 可是这里没有进行处理，而是抛给外层去了。此异常发生于还没执行完的任务被取消了</span></span><br><span class="line">                    f.get();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 为什么要这个？就是上面说的有异常的情况</span></span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                     <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks)</span><br><span class="line">            futures.add(newTaskFor(t));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanos;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = futures.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Interleave time checks and calls to execute in case</span></span><br><span class="line">        <span class="comment">// executor doesn't have any/much parallelism.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">// 提交一个任务，检测一次是否超时</span></span><br><span class="line">            execute((Runnable)futures.get(i));</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> futures;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用带超时的 get 方法，这里的参数 nanos 是剩余的时间，</span></span><br><span class="line">                    <span class="comment">// 因为上面其实已经用掉了一些时间了</span></span><br><span class="line">                    f.get(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">                &#125;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>到这里，我们发现，这个抽象类包装了一些基本的方法，可是像 submit、invokeAny、invokeAll 等方法，它们都没有真正开启线程来执行任务，它们都只是在方法内部调用了 execute 方法。至于execute是怎么实现的，可以查看另一篇文章 <a href="http://www.ppjys.cn/2018/11/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">Java线程池ThreadPoolExecutor原理分析</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;AbstractExecutorService 抽象类派生自 ExecutorService 接口，然后在其基础上实现了几个实用的方法，这些方法提供给子类进行调用。ExecutorService又是继承Executor接口。接下来我们就来一一分析。&lt;/p&gt;
&lt;h3 id=&quot;源码解析&quot;&gt;&lt;a href=&quot;#源码解析&quot; class=&quot;headerlink&quot; title=&quot;源码解析&quot;&gt;&lt;/a&gt;源码解析&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Executor接口&lt;br&gt;我们可以看到 Executor 接口非常简单，就一个 void execute(Runnable command) 方法，代表提交一个任务。&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @since 1.5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @author Doug Lea&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Executor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Runnable command)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="juc" scheme="blog.ppjys.cn/categories/juc/"/>
    
    
      <category term="AbstractExecutorService" scheme="blog.ppjys.cn/tags/AbstractExecutorService/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池ThreadPoolExecutor原理分析</title>
    <link href="blog.ppjys.cn/2018/11/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>blog.ppjys.cn/2018/11/20/Java线程池ThreadPoolExecutor原理分析/</id>
    <published>2018-11-20T15:49:45.000Z</published>
    <updated>2018-11-20T15:53:27.114Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>线程池可以简单看做是一组线程的集合，通过使用线程池，我们可以方便的复用线程，避免了频繁创建和销毁线程所带来的开销。</p><p><strong>类图</strong><br><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/1.png" width="500px/"></p><p>如上图，最顶层的接口 Executor 仅声明了一个方法execute。ExecutorService 接口在其父类接口基础上，声明了包含但不限于shutdown、submit、invokeAll、invokeAny 等方法。至于 ScheduledExecutorService 接口，则是声明了一些和定时任务相关的方法，比如 schedule和scheduleAtFixedRate。线程池的核心实现是在 ThreadPoolExecutor 类中，我们使用 Executors 调用newFixedThreadPool、newSingleThreadExecutor和newCachedThreadPool等方法创建线程池均是 ThreadPoolExecutor 类型。</p><a id="more"></a><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><ol><li><p>构造函数<br>线程池的核心实现即 ThreadPoolExecutor 类。该类包含了几个核心属性，这些属性在可在构造方法进行初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 概念：</span></span><br><span class="line"><span class="comment"> * corePoolSize：核心线程数，当线程数小于该值时，线程池会优先创建新线程来执行新任务</span></span><br><span class="line"><span class="comment"> * maximumPoolSize：线程池所能维护的最大线程数</span></span><br><span class="line"><span class="comment"> * keepAliveTime：空闲线程的存活时间</span></span><br><span class="line"><span class="comment"> * workQueue：任务队列，用于缓存未执行的任务</span></span><br><span class="line"><span class="comment"> * threadFactory：线程工厂。可通过工厂为新建的线程设置更有意义的名字</span></span><br><span class="line"><span class="comment"> * handler：拒绝策略。当线程池和任务队列均处于饱和状态时，使用拒绝策略处理新任务。默认是 AbortPolicy，即直接抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 规则流程：</span></span><br><span class="line"><span class="comment"> * 1.线程数量小于 corePoolSize，直接创建新线程处理新的任务。</span></span><br><span class="line"><span class="comment"> * 2.线程数量大于等于 corePoolSize，workQueue 未满，则缓存新任务。</span></span><br><span class="line"><span class="comment"> * 3.线程数量大于等于 corePoolSize，但小于 maximumPoolSize，且 workQueue 已满。则创建新线程处理新任务</span></span><br><span class="line"><span class="comment"> * 4.线程数量大于等于 maximumPoolSize，且 workQueue 已满，则使用拒绝策略处理新任务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 排队策略（当线程数量大于等于 corePoolSize，workQueue 未满时，则缓存新任务）：</span></span><br><span class="line"><span class="comment"> * 同步队列（SynchronousQueue）：该队列不存储元素，每个插入操作必须等待另一个线程调用移除操作，否则插入操作会一直阻塞</span></span><br><span class="line"><span class="comment"> * 有界队列（ArrayBlockingQueue）：基于数组的阻塞队列，按照 FIFO 原则对元素进行排序</span></span><br><span class="line"><span class="comment"> * 无界队列（LinkedBlockingQueue）：基于链表的阻塞队列，按照 FIFO 原则对元素进行排序</span></span><br><span class="line"><span class="comment"> * 优先级队列（PriorityBlockingQueue）：具有优先级的阻塞队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 拒绝策略（线程数量大于等于 maximumPoolSize，且 workQueue 已满，则使用拒绝策略处理新任务。）：</span></span><br><span class="line"><span class="comment"> * AbortPolicy：丢弃新任务，并抛出 RejectedExecutionException</span></span><br><span class="line"><span class="comment"> * DiscardPolicy：不做任何操作，直接丢弃新任务</span></span><br><span class="line"><span class="comment"> * DiscardOldestPolicy：丢弃队列队首的元素，并执行新任务</span></span><br><span class="line"><span class="comment"> * CallerRunsPolicy：由调用线程执行新任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>状态和线程数</p></li></ol><p><strong>线程池状态</strong>  </p><ul><li>RUNNING：这个没什么好说的，这是最正常的状态：接受新的任务，处理等待队列中的任务  </li><li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务  </li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程  </li><li>TIDYING：所有的任务都销毁了，workCount 为 0。线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()  </li><li>TERMINATED：terminated() 方法结束后，线程池的状态就会变成这个</li></ul><p><strong>状态转换</strong></p><ul><li>RUNNING -&gt; SHUTDOWN：当调用了 shutdown() 后，会发生这个状态转换，这也是最重要的</li><li>(RUNNING or SHUTDOWN) -&gt; STOP：当调用 shutdownNow() 后，会发生这个状态转换，这下要清楚 shutDown() 和 shutDownNow() 的区别了</li><li>SHUTDOWN -&gt; TIDYING：当任务队列和线程池都清空后，会由 SHUTDOWN 转换为 TIDYING</li><li>STOP -&gt; TIDYING：当任务队列清空后，发生这个转换</li><li>TIDYING -&gt; TERMINATED：这个前面说了，当 terminated() 方法结束后</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用一个 32 位的整数来存放线程池的状态和当前池中的线程数，其中高 3 位用于存放线程池状态，低 29 位表示线程数（即使只有 29 位，也已经不小了，大概 500 多万）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 这里 COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 000 11111111111111111111111111111</span></span><br><span class="line"><span class="comment">// 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1=536860911</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们说了，线程池的状态存放在高 3 位中</span></span><br><span class="line"><span class="comment">// 运算结果为 111跟29个0：111 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">// 备注：负数的二进制用正数的补码表示（https://blog.csdn.net/onewalkingman/article/details/3746154）</span></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 000 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 001 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 010 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 011 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将整数 c 的低 29 位修改为 0，就得到了线程池的状态</span></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>线程池中做任务的线程Worker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真正的线程</span></span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为什么叫 firstTask？因为在创建线程的时候，如果同时指定了这个线程起来以后需要执行的第一个任务,</span></span><br><span class="line"><span class="comment">     * 那么第一个任务就是存放在这里的(线程可不止执行这一个任务)</span></span><br><span class="line"><span class="comment">     * 当然了，也可以为 null，这样线程起来了，自己到任务队列（BlockingQueue）中取任务（getTask 方法）就行了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">//用于存放此线程完全的任务数，注意了，这里用了 volatile，保证可见性</span></span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Worker 只有这一个构造方法，传入 firstTask，也可以传 null</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 调用 ThreadFactory 来创建一个新的线程</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里调用了外部类的 runWorker 方法</span></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下是aqs独占锁实现...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>execute方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Executes the given task sometime in the future.  The task</span><br><span class="line"> * may execute in a new thread or in an existing pooled thread.</span><br><span class="line"> *</span><br><span class="line"> * If the task cannot be submitted for execution, either because this</span><br><span class="line"> * executor has been shutdown or because its capacity has been reached,</span><br><span class="line"> * the task is handled by the current &#123;@code RejectedExecutionHandler&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param command the task to execute</span><br><span class="line"> * @throws RejectedExecutionException at discretion of</span><br><span class="line"> *         &#123;@code RejectedExecutionHandler&#125;, if the task</span><br><span class="line"> *         cannot be accepted for execution</span><br><span class="line"> * @throws NullPointerException if &#123;@code command&#125; is null</span><br><span class="line"> */</span><br><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    /*</span><br><span class="line">     * Proceed in 3 steps:</span><br><span class="line">     *</span><br><span class="line">     * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">     * start a new thread with the given command as its first</span><br><span class="line">     * task.  The call to addWorker atomically checks runState and</span><br><span class="line">     * workerCount, and so prevents false alarms that would add</span><br><span class="line">     * threads when it shouldn&apos;t, by returning false.</span><br><span class="line">     *</span><br><span class="line">     * 2. If a task can be successfully queued, then we still need</span><br><span class="line">     * to double-check whether we should have added a thread</span><br><span class="line">     * (because existing ones died since last checking) or that</span><br><span class="line">     * the pool shut down since entry into this method. So we</span><br><span class="line">     * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">     * stopped, or start a new thread if there are none.</span><br><span class="line">     *</span><br><span class="line">     * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">     * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">     * and so reject the task.</span><br><span class="line">     */</span><br><span class="line">    //获取运行状态和线程数</span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    // 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span><br><span class="line">    // 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        // 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span><br><span class="line">        // 至于执行的结果，到时候会包装到 FutureTask 中。</span><br><span class="line">        // 返回 false 代表线程池不允许提交任务</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        /* 如果任务进入了 workQueue，我们是否需要开启新的线程</span><br><span class="line">         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span><br><span class="line">         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span><br><span class="line">         */</span><br><span class="line">        int recheck = ctl.get();</span><br><span class="line">        // 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            // 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span><br><span class="line">        else if (workerCountOf(recheck) == 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果 workQueue 队列满了，那么进入到这个分支</span><br><span class="line">    // 以 maximumPoolSize 为界创建新的 worker，</span><br><span class="line">    // 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void reject(Runnable command) &#123;</span><br><span class="line">    // 执行拒绝策略</span><br><span class="line">    handler.rejectedExecution(command, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>addWorker方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一个参数是准备提交给这个线程执行的任务，之前说了，可以为 null</span></span><br><span class="line"><span class="comment"> * 第二个参数为 true 代表使用核心线程数 corePoolSize 作为创建线程的界线，也就说创建这个线程的时候，</span></span><br><span class="line"><span class="comment"> *  如果线程池中的线程总数已经达到 corePoolSize，那么不能响应这次创建线程的请求</span></span><br><span class="line"><span class="comment"> *  如果是 false，代表使用最大线程数 maximumPoolSize 作为界线</span></span><br><span class="line"><span class="comment"> * Checks if a new worker can be added with respect to current</span></span><br><span class="line"><span class="comment"> * pool state and the given bound (either core or maximum). If so,</span></span><br><span class="line"><span class="comment"> * the worker count is adjusted accordingly, and, if possible, a</span></span><br><span class="line"><span class="comment"> * new worker is created and started, running firstTask as its</span></span><br><span class="line"><span class="comment"> * first task. This method returns false if the pool is stopped or</span></span><br><span class="line"><span class="comment"> * eligible to shut down. It also returns false if the thread</span></span><br><span class="line"><span class="comment"> * factory fails to create a thread when asked.  If the thread</span></span><br><span class="line"><span class="comment"> * creation fails, either due to the thread factory returning</span></span><br><span class="line"><span class="comment"> * null, or due to an exception (typically OutOfMemoryError in</span></span><br><span class="line"><span class="comment"> * Thread.start()), we roll back cleanly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask the task the new thread should run first (or</span></span><br><span class="line"><span class="comment"> * null if none). Workers are created with an initial first task</span></span><br><span class="line"><span class="comment"> * (in method execute()) to bypass queuing when there are fewer</span></span><br><span class="line"><span class="comment"> * than corePoolSize threads (in which case we always start one),</span></span><br><span class="line"><span class="comment"> * or when the queue is full (in which case we must bypass queue).</span></span><br><span class="line"><span class="comment"> * Initially idle threads are usually created via</span></span><br><span class="line"><span class="comment"> * prestartCoreThread or to replace other dying workers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core if true use corePoolSize as bound, else</span></span><br><span class="line"><span class="comment"> * maximumPoolSize. (A boolean indicator is used here rather than a</span></span><br><span class="line"><span class="comment"> * value to ensure reads of fresh values after checking other pool</span></span><br><span class="line"><span class="comment"> * state).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">// 如果线程池已关闭，并满足以下条件之一，那么不创建新的 worker：</span></span><br><span class="line">        <span class="comment">// 1. 线程池状态大于 SHUTDOWN，其实也就是 STOP, TIDYING, 或 TERMINATED</span></span><br><span class="line">        <span class="comment">// 2. firstTask != null</span></span><br><span class="line">        <span class="comment">// 3. workQueue.isEmpty()</span></span><br><span class="line">        <span class="comment">// 简单分析下：</span></span><br><span class="line">        <span class="comment">// 还是状态控制的问题，当线程池处于 SHUTDOWN 的时候，不允许提交任务，但是已有的任务继续执行</span></span><br><span class="line">        <span class="comment">// 当状态大于 SHUTDOWN 时，不允许提交任务，且中断正在执行的任务</span></span><br><span class="line">        <span class="comment">// 多说一句：如果线程池处于 SHUTDOWN，但是 firstTask 为 null，且 workQueue 非空，那么是允许创建 worker 的</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了</span></span><br><span class="line">            <span class="comment">// 这里失败的话，说明有其他线程也在尝试往线程池中创建线程</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 由于有并发，重新再读取一下 ctl</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了</span></span><br><span class="line">            <span class="comment">// 可是如果是因为其他线程的操作，导致线程池的状态发生了变更，如有其他线程关闭了这个线程池</span></span><br><span class="line">            <span class="comment">// 那么需要回到外层的for循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//到这里，我们认为在当前这个时刻，可以开始创建线程来执行任务了</span></span><br><span class="line">    <span class="comment">// worker 是否已经启动</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 是否已将这个 worker 添加到 workers 这个 HashSet 中</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 把 firstTask 传给 worker 的构造方法</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="comment">// 取 worker 中的线程对象，之前说了，Worker的构造方法会调用 ThreadFactory 来创建一个新的线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// 小于 SHUTTDOWN 那就是 RUNNING，这个自不必说，是最正常的情况</span></span><br><span class="line">                <span class="comment">// 如果等于 SHUTDOWN，前面说了，不接受新的任务，但是会继续执行等待队列中的任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// worker 里面的 thread 可不能是已经启动的</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// 加到 workers 这个 HashSet 中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">// largestPoolSize 用于记录 workers 中的个数的最大值</span></span><br><span class="line">                    <span class="comment">// 因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加成功的话，启动这个线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回线程是否启动成功</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>addWorkFailed方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// workers 中删除掉相应的 worker</span></span><br><span class="line"><span class="comment">// workCount 减 1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">// rechecks for termination, in case the existence of this worker was holding up termination</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>runWorker方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Worker 类的 run() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此方法由 worker 线程启动后调用，这里用一个 while 循环来不断地从等待队列中获取任务并执行</span></span><br><span class="line"><span class="comment"> * 前面说了，worker 在初始化的时候，可以指定 firstTask，那么第一个任务也就可以不需要从队列中获取</span></span><br><span class="line"><span class="comment"> * Main worker run loop.  Repeatedly gets tasks from queue and</span></span><br><span class="line"><span class="comment"> * executes them, while coping with a number of issues:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. We may start out with an initial task, in which case we</span></span><br><span class="line"><span class="comment"> * don't need to get the first one. Otherwise, as long as pool is</span></span><br><span class="line"><span class="comment"> * running, we get tasks from getTask. If it returns null then the</span></span><br><span class="line"><span class="comment"> * worker exits due to changed pool state or configuration</span></span><br><span class="line"><span class="comment"> * parameters.  Other exits result from exception throws in</span></span><br><span class="line"><span class="comment"> * external code, in which case completedAbruptly holds, which</span></span><br><span class="line"><span class="comment"> * usually leads processWorkerExit to replace this thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. Before running any task, the lock is acquired to prevent</span></span><br><span class="line"><span class="comment"> * other pool interrupts while the task is executing, and then we</span></span><br><span class="line"><span class="comment"> * ensure that unless pool is stopping, this thread does not have</span></span><br><span class="line"><span class="comment"> * its interrupt set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. Each task run is preceded by a call to beforeExecute, which</span></span><br><span class="line"><span class="comment"> * might throw an exception, in which case we cause thread to die</span></span><br><span class="line"><span class="comment"> * (breaking loop with completedAbruptly true) without processing</span></span><br><span class="line"><span class="comment"> * the task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. Assuming beforeExecute completes normally, we run the task,</span></span><br><span class="line"><span class="comment"> * gathering any of its thrown exceptions to send to afterExecute.</span></span><br><span class="line"><span class="comment"> * We separately handle RuntimeException, Error (both of which the</span></span><br><span class="line"><span class="comment"> * specs guarantee that we trap) and arbitrary Throwables.</span></span><br><span class="line"><span class="comment"> * Because we cannot rethrow Throwables within Runnable.run, we</span></span><br><span class="line"><span class="comment"> * wrap them within Errors on the way out (to the thread's</span></span><br><span class="line"><span class="comment"> * UncaughtExceptionHandler).  Any thrown exception also</span></span><br><span class="line"><span class="comment"> * conservatively causes thread to die.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5. After task.run completes, we call afterExecute, which may</span></span><br><span class="line"><span class="comment"> * also throw an exception, which will also cause thread to</span></span><br><span class="line"><span class="comment"> * die. According to JLS Sec 14.20, this exception is the one that</span></span><br><span class="line"><span class="comment"> * will be in effect even if task.run throws.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The net effect of the exception mechanics is that afterExecute</span></span><br><span class="line"><span class="comment"> * and the thread's UncaughtExceptionHandler have as accurate</span></span><br><span class="line"><span class="comment"> * information as we can provide about any problems encountered by</span></span><br><span class="line"><span class="comment"> * user code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 该线程的第一个任务(如果有的话)</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环调用 getTask 获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 如果线程池状态大于等于 STOP，那么意味着该线程也要中断</span></span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这是一个钩子方法，留给需要的子类实现</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 到这里终于可以执行任务了</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 也是一个钩子方法，将 task 和异常作为参数，留给需要的子类实现</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 置空 task，准备 getTask 获取下一个任务</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 累加完成的任务数</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">// 释放掉 worker 的独占锁</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果到这里，需要执行线程关闭：</span></span><br><span class="line">        <span class="comment">// 1. 说明 getTask 返回 null，也就是说，这个 worker 的使命结束了，执行关闭</span></span><br><span class="line">        <span class="comment">// 2. 任务执行过程中发生了异常</span></span><br><span class="line">        <span class="comment">// 第一种情况，已经在代码处理了将 workCount 减 1，这个在 getTask 方法分析中会说</span></span><br><span class="line">        <span class="comment">// 第二种情况，workCount 没有进行处理，所以需要在 processWorkerExit 中处理</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>getTask方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此方法有三种可能：</span></span><br><span class="line"><span class="comment"> * 1. 阻塞直到获取到任务返回。我们知道，默认 corePoolSize 之内的线程是不会被回收的，</span></span><br><span class="line"><span class="comment"> *       它们会一直等待任务</span></span><br><span class="line"><span class="comment"> * 2. 超时退出。keepAliveTime 起作用的时候，也就是如果这么多时间内都没有任务，那么应该执行关闭</span></span><br><span class="line"><span class="comment"> * 3. 如果发生了以下条件，此方法必须返回 null:</span></span><br><span class="line"><span class="comment"> *     - 池中有大于 maximumPoolSize 个 workers 存在(通过调用 setMaximumPoolSize 进行设置)</span></span><br><span class="line"><span class="comment"> *     - 线程池处于 SHUTDOWN，而且 workQueue 是空的，前面说了，这种不再接受新的任务</span></span><br><span class="line"><span class="comment"> *     - 线程池处于 STOP，不仅不接受新的线程，连 workQueue 中的线程也不再执行</span></span><br><span class="line"><span class="comment"> * Performs blocking or timed wait for a task, depending on</span></span><br><span class="line"><span class="comment"> * current configuration settings, or returns null if this worker</span></span><br><span class="line"><span class="comment"> * must exit because of any of:</span></span><br><span class="line"><span class="comment"> * 1. There are more than maximumPoolSize workers (due to</span></span><br><span class="line"><span class="comment"> *    a call to setMaximumPoolSize).</span></span><br><span class="line"><span class="comment"> * 2. The pool is stopped.</span></span><br><span class="line"><span class="comment"> * 3. The pool is shutdown and the queue is empty.</span></span><br><span class="line"><span class="comment"> * 4. This worker timed out waiting for a task, and timed-out</span></span><br><span class="line"><span class="comment"> *    workers are subject to termination (that is,</span></span><br><span class="line"><span class="comment"> *    &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span></span><br><span class="line"><span class="comment"> *    both before and after the timed wait, and if the queue is</span></span><br><span class="line"><span class="comment"> *    non-empty, this worker is not the last thread in the pool.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> task, or null if the worker must exit, in which case</span></span><br><span class="line"><span class="comment"> *         workerCount is decremented</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 允许核心线程数内的线程回收，或当前线程数超过了核心线程数，那么有可能发生超时关闭</span></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 到 workQueue 中获取任务</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 如果此 worker 发生了中断，采取的方案是重试</span></span><br><span class="line">            <span class="comment">// 解释下为什么会发生中断，这个读者要去看 setMaximumPoolSize 方法，</span></span><br><span class="line">            <span class="comment">// 如果开发者将 maximumPoolSize 调小了，导致其小于当前的 workers 数量，</span></span><br><span class="line">            <span class="comment">// 那么意味着超出的部分线程要被关闭。重新进入 for 循环，自然会有部分线程会返回 null</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ThreadPoolExecutor是线程池最底层的实现，需要知道几个参数的含义，还有线程work的工作流程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;线程池可以简单看做是一组线程的集合，通过使用线程池，我们可以方便的复用线程，避免了频繁创建和销毁线程所带来的开销。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类图&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/1.png&quot; width=&quot;500px/&quot;&gt;&lt;/p&gt;
&lt;p&gt;如上图，最顶层的接口 Executor 仅声明了一个方法execute。ExecutorService 接口在其父类接口基础上，声明了包含但不限于shutdown、submit、invokeAll、invokeAny 等方法。至于 ScheduledExecutorService 接口，则是声明了一些和定时任务相关的方法，比如 schedule和scheduleAtFixedRate。线程池的核心实现是在 ThreadPoolExecutor 类中，我们使用 Executors 调用newFixedThreadPool、newSingleThreadExecutor和newCachedThreadPool等方法创建线程池均是 ThreadPoolExecutor 类型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ThreadPoolExecutor" scheme="blog.ppjys.cn/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>Java线程同步组件Semaphore分析</title>
    <link href="blog.ppjys.cn/2018/11/17/Java%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6Semaphore%E5%88%86%E6%9E%90/"/>
    <id>blog.ppjys.cn/2018/11/17/Java线程同步组件Semaphore分析/</id>
    <published>2018-11-17T14:19:54.000Z</published>
    <updated>2018-11-17T14:24:23.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Semaphore 主要用于限量控制并发执行代码的工具类, 其内部通过 一个 permit 来进行定义并发执行的数量,本质就是aqs的共享锁.</p><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a><strong>类图</strong></h4><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/semphore/1.png" height="300px"><br><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/semphore/2.png" height="300px"></p><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a><strong>Demo</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fly.learn.reentrantlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peijiepang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(SemaphoreTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SemaphoreTest</span><span class="params">(String threadName,Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        <span class="keyword">this</span>.setName(threadName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000l</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.info(<span class="string">"&#123;&#125;......"</span>,Thread.currentThread().getName());</span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//公平锁</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>,<span class="keyword">true</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> SemaphoreTest(<span class="string">"thread_"</span>+<span class="number">1</span>,semaphore));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        LOGGER.info(<span class="string">"finish......."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">46.644</span> [pool-<span class="number">2</span>-thread-<span class="number">1</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">1</span>......</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">46.645</span> [pool-<span class="number">2</span>-thread-<span class="number">2</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">2</span>......</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">47.647</span> [pool-<span class="number">2</span>-thread-<span class="number">4</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">4</span>......</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">47.647</span> [pool-<span class="number">2</span>-thread-<span class="number">3</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">3</span>......</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">48.650</span> [pool-<span class="number">2</span>-thread-<span class="number">6</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">6</span>......</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">48.650</span> [pool-<span class="number">2</span>-thread-<span class="number">5</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">5</span>......</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">49.652</span> [pool-<span class="number">2</span>-thread-<span class="number">7</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">7</span>......</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">49.652</span> [pool-<span class="number">2</span>-thread-<span class="number">8</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">8</span>......</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">50.657</span> [pool-<span class="number">2</span>-thread-<span class="number">9</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">9</span>......</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">50.658</span> [pool-<span class="number">2</span>-thread-<span class="number">10</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">10</span>......</span><br></pre></td></tr></table></figure></p><p>从上面的执行结果来看，每1s都会获取到2个令牌，符合预期Semaphore配置为2的结论。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><pre><code>1.Semaphore方法的实现通过 Sync(AQS的继承类)代理来实现2.支持公平与非公平模式, 都是在AQS的子类里面进行, 主要区分在 tryAcquire</code></pre><a id="more"></a><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><ol><li><p>构造函数<br>Semaphore 的功能均由内部类 NonfairSync, FairSync 代理来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认使用非公平模式</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> Semaphore&#125; with the given number of</span></span><br><span class="line"><span class="comment"> * permits and nonfair fairness setting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permits the initial number of permits available.</span></span><br><span class="line"><span class="comment"> *        This value may be negative, in which case releases</span></span><br><span class="line"><span class="comment"> *        must occur before any acquires will be granted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要指定公平或者非公平模式</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> Semaphore&#125; with the given number of</span></span><br><span class="line"><span class="comment"> * permits and the given fairness setting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permits the initial number of permits available.</span></span><br><span class="line"><span class="comment"> *        This value may be negative, in which case releases</span></span><br><span class="line"><span class="comment"> *        must occur before any acquires will be granted.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this semaphore will guarantee</span></span><br><span class="line"><span class="comment"> *        first-in first-out granting of permits under contention,</span></span><br><span class="line"><span class="comment"> *        else &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Semaphore内部类Sync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  AQS 的子类主要定义获取释放 lock</span></span><br><span class="line"><span class="comment"> * Synchronization implementation for semaphore.  Uses AQS state</span></span><br><span class="line"><span class="comment"> * to represent permits. Subclassed into fair and nonfair</span></span><br><span class="line"><span class="comment"> * versions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定许可 初始化 Semaphore</span></span><br><span class="line"><span class="comment">     * 许可对应aqs中的state</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permits</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取许可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平方式获取多个许可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquires</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;<span class="comment">// 判断获取 acquires 的剩余 permit 数目</span></span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))<span class="comment">// cas改变 state</span></span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放许可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> releases</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 减少许可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> reductions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将许可设置为0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Semaphore 内部类 FairSync, NonfairSync<br>这两个类均继承 Sync, 两者的区别主要在于在获取时判断是否有线程在 AQS 的 Sync Queue 里面进行等待获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非公平模式</span></span><br><span class="line"><span class="comment"> * NonFair version</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);<span class="comment">//直接调用父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公平模式</span></span><br><span class="line"><span class="comment"> * Fair version</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平版本获取 permit 主要看是否由前继节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquires</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())<span class="comment">// 1. 判断是否Sync Queue 里面是否有前继节点</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))<span class="comment">// 2. cas 改变state</span></span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Semaphore permit获取方式<br>这边值贴释放1个许可的源码，释放多个许可源码无非只是增加前置校验而已</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用 acquireSharedInterruptibly 响应中断的方式获取 permit</span></span><br><span class="line"><span class="comment"> * Acquires a permit from this semaphore, blocking until one is</span></span><br><span class="line"><span class="comment"> * available, or the thread is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Acquires a permit, if one is available and returns immediately,</span></span><br><span class="line"><span class="comment"> * reducing the number of available permits by one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If no permit is available then the current thread becomes</span></span><br><span class="line"><span class="comment"> * disabled for thread scheduling purposes and lies dormant until</span></span><br><span class="line"><span class="comment"> * one of two things happens:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Some other thread invokes the &#123;<span class="doctag">@link</span> #release&#125; method for this</span></span><br><span class="line"><span class="comment"> * semaphore and the current thread is next to be assigned a permit; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Some other thread &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupts&#125;</span></span><br><span class="line"><span class="comment"> * the current thread.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current thread:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;has its interrupted status set on entry to this method; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125; while waiting</span></span><br><span class="line"><span class="comment"> * for a permit,</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * then &#123;<span class="doctag">@link</span> InterruptedException&#125; is thrown and the current thread's</span></span><br><span class="line"><span class="comment"> * interrupted status is cleared.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//aqs代码--调用到aqs中的方法，然后在调用到子类实现的tryAcquireShared</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用 acquireUninterruptibly 非响应中断的方式获取 permit</span></span><br><span class="line"><span class="comment"> * Acquires a permit from this semaphore, blocking until one is</span></span><br><span class="line"><span class="comment"> * available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Acquires a permit, if one is available and returns immediately,</span></span><br><span class="line"><span class="comment"> * reducing the number of available permits by one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If no permit is available then the current thread becomes</span></span><br><span class="line"><span class="comment"> * disabled for thread scheduling purposes and lies dormant until</span></span><br><span class="line"><span class="comment"> * some other thread invokes the &#123;<span class="doctag">@link</span> #release&#125; method for this</span></span><br><span class="line"><span class="comment"> * semaphore and the current thread is next to be assigned a permit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current thread is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;</span></span><br><span class="line"><span class="comment"> * while waiting for a permit then it will continue to wait, but the</span></span><br><span class="line"><span class="comment"> * time at which the thread is assigned a permit may change compared to</span></span><br><span class="line"><span class="comment"> * the time it would have received the permit had no interruption</span></span><br><span class="line"><span class="comment"> * occurred.  When the thread does return from this method its interrupt</span></span><br><span class="line"><span class="comment"> * status will be set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//aqs源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试获取 permit,其实就是调用非公平锁的获取许可方法</span></span><br><span class="line"><span class="comment"> * Acquires a permit from this semaphore, only if one is available at the</span></span><br><span class="line"><span class="comment"> * time of invocation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Acquires a permit, if one is available and returns immediately,</span></span><br><span class="line"><span class="comment"> * with the value &#123;<span class="doctag">@code</span> true&#125;,</span></span><br><span class="line"><span class="comment"> * reducing the number of available permits by one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If no permit is available then this method will return</span></span><br><span class="line"><span class="comment"> * immediately with the value &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Even when this semaphore has been set to use a</span></span><br><span class="line"><span class="comment"> * fair ordering policy, a call to &#123;<span class="doctag">@code</span> tryAcquire()&#125; &lt;em&gt;will&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> * immediately acquire a permit if one is available, whether or not</span></span><br><span class="line"><span class="comment"> * other threads are currently waiting.</span></span><br><span class="line"><span class="comment"> * This &amp;quot;barging&amp;quot; behavior can be useful in certain</span></span><br><span class="line"><span class="comment"> * circumstances, even though it breaks fairness. If you want to honor</span></span><br><span class="line"><span class="comment"> * the fairness setting, then use</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #tryAcquire(long, TimeUnit) tryAcquire(0, TimeUnit.SECONDS) &#125;</span></span><br><span class="line"><span class="comment"> * which is almost equivalent (it also detects interruption).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if a permit was acquired and &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment"> *         otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquireShared(<span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试的获取 permit, 支持超时与中断</span></span><br><span class="line"><span class="comment"> * Acquires the given number of permits from this semaphore, if all</span></span><br><span class="line"><span class="comment"> * become available within the given waiting time and the current</span></span><br><span class="line"><span class="comment"> * thread has not been &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Acquires the given number of permits, if they are available and</span></span><br><span class="line"><span class="comment"> * returns immediately, with the value &#123;<span class="doctag">@code</span> true&#125;,</span></span><br><span class="line"><span class="comment"> * reducing the number of available permits by the given amount.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If insufficient permits are available then</span></span><br><span class="line"><span class="comment"> * the current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment"> * purposes and lies dormant until one of three things happens:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Some other thread invokes one of the &#123;<span class="doctag">@link</span> #release() release&#125;</span></span><br><span class="line"><span class="comment"> * methods for this semaphore, the current thread is next to be assigned</span></span><br><span class="line"><span class="comment"> * permits and the number of available permits satisfies this request; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Some other thread &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupts&#125;</span></span><br><span class="line"><span class="comment"> * the current thread; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;The specified waiting time elapses.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the permits are acquired then the value &#123;<span class="doctag">@code</span> true&#125; is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current thread:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;has its interrupted status set on entry to this method; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125; while waiting</span></span><br><span class="line"><span class="comment"> * to acquire the permits,</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * then &#123;<span class="doctag">@link</span> InterruptedException&#125; is thrown and the current thread's</span></span><br><span class="line"><span class="comment"> * interrupted status is cleared.</span></span><br><span class="line"><span class="comment"> * Any permits that were to be assigned to this thread, are instead</span></span><br><span class="line"><span class="comment"> * assigned to other threads trying to acquire permits, as if</span></span><br><span class="line"><span class="comment"> * the permits had been made available by a call to &#123;<span class="doctag">@link</span> #release()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the specified waiting time elapses then the value &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment"> * is returned.  If the time is less than or equal to zero, the method</span></span><br><span class="line"><span class="comment"> * will not wait at all.  Any permits that were to be assigned to this</span></span><br><span class="line"><span class="comment"> * thread, are instead assigned to other threads trying to acquire</span></span><br><span class="line"><span class="comment"> * permits, as if the permits had been made available by a call to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #release()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permits the number of permits to acquire</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout the maximum time to wait for the permits</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit of the &#123;<span class="doctag">@code</span> timeout&#125; argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if all permits were acquired and &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment"> *         if the waiting time elapsed before all permits were acquired</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> permits&#125; is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(permits, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//aqs源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</span><br><span class="line">        doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Semaphore permit 释放方法<br>这边值贴释放1个许可的源码，释放多个许可源码无非只是增加前置校验而已</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放 permit</span></span><br><span class="line"><span class="comment"> * Releases the given number of permits, returning them to the semaphore.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Releases the given number of permits, increasing the number of</span></span><br><span class="line"><span class="comment"> * available permits by that amount.</span></span><br><span class="line"><span class="comment"> * If any threads are trying to acquire permits, then one</span></span><br><span class="line"><span class="comment"> * is selected and given the permits that were just released.</span></span><br><span class="line"><span class="comment"> * If the number of available permits satisfies that thread's request</span></span><br><span class="line"><span class="comment"> * then that thread is (re)enabled for thread scheduling purposes;</span></span><br><span class="line"><span class="comment"> * otherwise the thread will wait until sufficient permits are available.</span></span><br><span class="line"><span class="comment"> * If there are still permits available</span></span><br><span class="line"><span class="comment"> * after this thread's request has been satisfied, then those permits</span></span><br><span class="line"><span class="comment"> * are assigned in turn to other threads trying to acquire permits.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;There is no requirement that a thread that releases a permit must</span></span><br><span class="line"><span class="comment"> * have acquired that permit by calling &#123;<span class="doctag">@link</span> Semaphore#acquire acquire&#125;.</span></span><br><span class="line"><span class="comment"> * Correct usage of a semaphore is established by programming convention</span></span><br><span class="line"><span class="comment"> * in the application.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permits the number of permits to release</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> permits&#125; is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.releaseShared(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//aqs源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Semaphore 通过 AQS中的 state 来进行控制 permit 的获取控制, 其实它就是一个限制数量的 ReadLock; 但要真正理解 Semaphore, 还需要看 <a href="http://www.ppjys.cn/2018/11/10/AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码分析</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;Semaphore 主要用于限量控制并发执行代码的工具类, 其内部通过 一个 permit 来进行定义并发执行的数量,本质就是aqs的共享锁.&lt;/p&gt;
&lt;h4 id=&quot;类图&quot;&gt;&lt;a href=&quot;#类图&quot; class=&quot;headerlink&quot; title=&quot;类图&quot;&gt;&lt;/a&gt;&lt;strong&gt;类图&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ppj19891020/pictures/master/semphore/1.png&quot; height=&quot;300px&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ppj19891020/pictures/master/semphore/2.png&quot; height=&quot;300px&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;&lt;strong&gt;Demo&lt;/strong&gt;&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; com.fly.learn.reentrantlock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; org.slf4j.Logger;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; org.slf4j.LoggerFactory;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.ExecutorService;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.Executors;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.Semaphore;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@author&lt;/span&gt;: peijiepang&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@date&lt;/span&gt; 2018/11/17&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@Description&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SemaphoreTest&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Thread&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(SemaphoreTest.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Semaphore semaphore;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SemaphoreTest&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String threadName,Semaphore semaphore)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.semaphore = semaphore;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.setName(threadName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            semaphore.acquire();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Thread.sleep(&lt;span class=&quot;number&quot;&gt;1000l&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LOGGER.info(&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;&amp;#125;......&quot;&lt;/span&gt;,Thread.currentThread().getName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        semaphore.release();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//公平锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Semaphore semaphore = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Semaphore(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ExecutorService executorService = Executors.newFixedThreadPool(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            executorService.submit(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SemaphoreTest(&lt;span class=&quot;string&quot;&gt;&quot;thread_&quot;&lt;/span&gt;+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,semaphore));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        executorService.shutdown();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LOGGER.info(&lt;span class=&quot;string&quot;&gt;&quot;finish.......&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行结果如下&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2018&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;17&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;05&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;46.644&lt;/span&gt; [pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2018&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;17&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;05&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;46.645&lt;/span&gt; [pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2018&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;17&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;05&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;47.647&lt;/span&gt; [pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2018&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;17&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;05&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;47.647&lt;/span&gt; [pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2018&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;17&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;05&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;48.650&lt;/span&gt; [pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2018&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;17&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;05&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;48.650&lt;/span&gt; [pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2018&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;17&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;05&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;49.652&lt;/span&gt; [pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2018&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;17&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;05&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;49.652&lt;/span&gt; [pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2018&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;17&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;05&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;50.657&lt;/span&gt; [pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2018&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;17&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;05&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;50.658&lt;/span&gt; [pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-thread-&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;......&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;从上面的执行结果来看，每1s都会获取到2个令牌，符合预期Semaphore配置为2的结论。&lt;/p&gt;
&lt;h4 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1.Semaphore方法的实现通过 Sync(AQS的继承类)代理来实现
2.支持公平与非公平模式, 都是在AQS的子类里面进行, 主要区分在 tryAcquire
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="juc" scheme="blog.ppjys.cn/categories/juc/"/>
    
    
      <category term="Semaphore" scheme="blog.ppjys.cn/tags/Semaphore/"/>
    
  </entry>
  
</feed>
